{
    "count": 60,
    "next": null,
    "previous": null,
    "results": [
        {
            "_class": "assessment",
            "id": 56168692,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>A collection called <code>players</code><em> </em>contains the following documents:</p><p><br></p><pre class=\"prettyprint linenums\">[\n  { _id: 1, user: 'Tom', scores: [ 23, 56, 3, 52, 62 ], bonus: 5 },\n  { _id: 2, user: 'Jane', scores: [ 42, 50, 10 ], bonus: 3 }\n]</pre><p><br></p><p>You want to add additional fields to each document:</p><p>-&gt; <code>total_score</code><em> </em>(sum of the <em>scores </em>Array)</p><p>-&gt; <code>avg_score</code><em> </em>(average score in <em>scores </em>Array)</p><p>-&gt; <code>total_score_with_bonus</code><em> </em>(<code>total_score</code><em> </em>+&nbsp;<code>bonus</code>)</p><p><br></p><p><strong>Expected output:</strong></p><p><br></p><pre class=\"prettyprint linenums\">[\n  {\n    _id: 1,\n    user: 'Tom',\n    scores: [ 23, 56, 3, 52, 62 ],\n    bonus: 5,\n    total_score: 196,\n    avg_score: 39.2,\n    total_score_with_bonus: 201\n  },\n  {\n    _id: 2,\n    user: 'Jane',\n    scores: [ 42, 50, 10 ],\n    bonus: 3,\n    total_score: 102,\n    avg_score: 34,\n    total_score_with_bonus: 105\n  }\n]</pre><p><br></p><p>Which query do you need to use?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>db.collection.aggregate(pipeline, options)</code><strong> </strong>calculates aggregate values for the data in a collection or a view. </p><p><br></p><p><code>$addField</code> adds new fields to documents. <code>$addFields</code> outputs documents that contain all existing fields from the input documents and newly added fields.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/</p><p>https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.players.aggregate([{\n&nbsp;&nbsp;&nbsp;&nbsp;$addFields:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$avg:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n},&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;$addFields:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score_with_bonus:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$add:&nbsp;['$total_score',&nbsp;'$bonus']\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}])</pre>",
                    "<pre class=\"prettyprint linenums\">db.players.aggregate([{\n&nbsp;&nbsp;&nbsp;&nbsp;$addFields:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$avg:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score_with_bonus:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$add:&nbsp;['$total_score',&nbsp;'$bonus']\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}])</pre>",
                    "<pre class=\"prettyprint linenums\">db.players.aggregate([{\n&nbsp;&nbsp;&nbsp;&nbsp;$add:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$avg:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n},&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;$add:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score_with_bonus:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$add:&nbsp;['$total_score',&nbsp;'$bonus']\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}])</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "A collection called players contains the following documents:[\n  { _id: 1, user: 'Tom', scores: [ 23, 56, 3, 52, 62 ], bonus: 5 },\n  { _id: 2, user: 'Jane', scores: [ 42, 50, 10 ], bonus: 3 }\n]You want to add additional fields to each document:-&gt; total_score (sum of the scores Array)-&gt; avg_score (average score in scores Array)-&gt; total_score_with_bonus (total_score +&nbsp;bonus)Expected output:[\n  {\n    _id: 1,\n    user: 'Tom',\n    scores: [ 23, 56, 3, 52, 62 ],\n    bonus: 5,\n    total_score: 196,\n    avg_score: 39.2,\n    total_score_with_bonus: 201\n  },\n  {\n    _id: 2,\n    user: 'Jane',\n    scores: [ 42, 50, 10 ],\n    bonus: 3,\n    total_score: 102,\n    avg_score: 34,\n    total_score_with_bonus: 105\n  }\n]Which query do you need to use?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168694,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>A collection called <code>players</code> contains documents with the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{ _id: 1, user: 'Tom', scores: [ 23, 56, 3, 52, 62 ], bonus: 5 }\n{ _id: 2, user: 'Jane', scores: [ 42, 50, 10 ], bonus: 3 }</pre><p><br></p><p>You have the following query:</p><p><br></p><pre class=\"prettyprint linenums\">db.players.aggregate([{\n&nbsp;&nbsp;&nbsp;&nbsp;$addFields:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$avg:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n},&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;$addFields:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score_with_bonus:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$add:&nbsp;['$total_score',&nbsp;'$bonus']\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n},&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;$match:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bonus:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$gt:&nbsp;4\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}])</pre><p><br></p><p>How can you optimize this query?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>$match</code> filters the documents to pass only the documents that match the specified condition(s) to the next pipeline stage. Place the <code>$match</code> as early in the aggregation pipeline as possible. Because <code>$match</code> limits the total number of documents in the aggregation pipeline, earlier <code>$match</code> operations minimize the amount of processing down the pipe.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/aggregation/match/</p><p>https://docs.mongodb.com/manual/core/aggregation-pipeline-optimization/</p>",
                "answers": [
                    "<p>Moving the <code>$match</code> stage to the beginning of the pipeline.</p><p><br></p><pre class=\"prettyprint linenums\">[{\n    $match: {\n        bonus: {\n            $gt: 4\n        }\n    }\n}, {\n    $addFields: {\n        total_score: {\n            $sum: '$scores'\n        },\n        avg_score: {\n            $avg: '$scores'\n        }\n    }\n}, {\n    $addFields: {\n        total_score_with_bonus: {\n            $add: ['$total_score', '$bonus']\n        }\n    }\n}]</pre>",
                    "<p>Moving the <code>$match</code> stage to the second stage of this pipeline.</p><p><br></p><pre class=\"prettyprint linenums\">[{\n    $addFields: {\n        total_score: {\n            $sum: '$scores'\n        },\n        avg_score: {\n            $avg: '$scores'\n        }\n    }\n}, {\n    $match: {\n        bonus: {\n            $gt: 4\n        }\n    }\n}, {\n    $addFields: {\n        total_score_with_bonus: {\n            $add: ['$total_score', '$bonus']\n        }\n    }\n}]</pre>",
                    "<p>This query cannot be optimized.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "A collection called players contains documents with the following structure:{ _id: 1, user: 'Tom', scores: [ 23, 56, 3, 52, 62 ], bonus: 5 }\n{ _id: 2, user: 'Jane', scores: [ 42, 50, 10 ], bonus: 3 }You have the following query:db.players.aggregate([{\n&nbsp;&nbsp;&nbsp;&nbsp;$addFields:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$avg:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n},&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;$addFields:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score_with_bonus:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$add:&nbsp;['$total_score',&nbsp;'$bonus']\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n},&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;$match:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bonus:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$gt:&nbsp;4\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}])How can you optimize this query?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168696,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Suppose you have a <code>developers</code><em> </em>collection with only two documents:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;1,\n&nbsp;&nbsp;lname:&nbsp;'Smith',\n&nbsp;&nbsp;tech_stack:&nbsp;[&nbsp;'sql',&nbsp;'git',&nbsp;'python',&nbsp;'django'&nbsp;],\n&nbsp;&nbsp;fname:&nbsp;'Bob'\n},\n{\n&nbsp;&nbsp;_id:&nbsp;2,\n&nbsp;&nbsp;fname:&nbsp;'Michael',\n&nbsp;&nbsp;lname:&nbsp;'Doe',\n&nbsp;&nbsp;tech_stack:&nbsp;[&nbsp;'git',&nbsp;'python',&nbsp;'sqlite',&nbsp;'linux',&nbsp;'flask'&nbsp;]\n}</pre><p><br></p><p>Using Aggregation&nbsp;Framework you run the following stage:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    $unwind: {\n        path: '$tech_stack'\n    }\n}</pre><p><br></p><p>How many documents will you have in the pipeline after the <code>$unwind</code> stage?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>$unwind</code> deconstructs an array field from the input documents to output a document for <em>each</em> element. Each output document is the input document with the value of the array field replaced by the element.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/</p>",
                "answers": [
                    "<p>9</p>",
                    "<p>2</p>",
                    "<p>4</p>",
                    "<p>5</p>",
                    "<p>7</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Suppose you have a developers collection with only two documents:{\n&nbsp;&nbsp;_id:&nbsp;1,\n&nbsp;&nbsp;lname:&nbsp;'Smith',\n&nbsp;&nbsp;tech_stack:&nbsp;[&nbsp;'sql',&nbsp;'git',&nbsp;'python',&nbsp;'django'&nbsp;],\n&nbsp;&nbsp;fname:&nbsp;'Bob'\n},\n{\n&nbsp;&nbsp;_id:&nbsp;2,\n&nbsp;&nbsp;fname:&nbsp;'Michael',\n&nbsp;&nbsp;lname:&nbsp;'Doe',\n&nbsp;&nbsp;tech_stack:&nbsp;[&nbsp;'git',&nbsp;'python',&nbsp;'sqlite',&nbsp;'linux',&nbsp;'flask'&nbsp;]\n}Using Aggregation&nbsp;Framework you run the following stage:{\n    $unwind: {\n        path: '$tech_stack'\n    }\n}How many documents will you have in the pipeline after the $unwind stage?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168698,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Select all true statements regarding to <code>$match</code> stage in Aggregation Framework. (select 2)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>$match</code> filters the documents to pass only the documents that match the specified condition(s) to the next pipeline stage. Place the <code>$match</code> as early in the aggregation pipeline as possible. Because <code>$match</code> limits the total number of documents in the aggregation pipeline, earlier <code>$match</code> operations minimize the amount of processing down the pipe.&nbsp; </p><p>To use <code>$text</code> in the <code>$match</code> stage, the <code>$match</code> stage has to be the <strong>first </strong>stage of the pipeline.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/aggregation/match/</p>",
                "answers": [
                    "<p>We should use <code>$match</code> stage as early as possible in the aggregation pipeline.</p>",
                    "<p>It can only be used once in the aggregation pipeline.</p>",
                    "<p>It has a syntax similar to <code>find()</code> method.</p>",
                    "<p>To use <code>$text</code> in the <code>$match</code> stage, the <code>$match</code> stage has to be the last stage of the pipeline.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "",
            "question_plain": "Select all true statements regarding to $match stage in Aggregation Framework. (select 2)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168700,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Which of the following stages do you need to use to randomly select 10 documents from a specific collection?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>$sample</code> randomly selects the specified number of documents from the input documents. The <code>$sample</code> stage has the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">{ $sample: { size: &lt;positive integer N&gt; } }</pre><p><br></p><p><code>N</code> is the number of documents to randomly select.</p><p><br></p><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/aggregation/sample/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">{ $sample: { size: 10 } }</pre>",
                    "<pre class=\"prettyprint linenums\">{ $sample: { get: 10 } }</pre>",
                    "<pre class=\"prettyprint linenums\">{ $rand: { size: 10 } }</pre>",
                    "<pre class=\"prettyprint linenums\">{ $sampleRate: { size: 10 } }</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Which of the following stages do you need to use to randomly select 10 documents from a specific collection?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168702,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Suppose you have an <code>accounts</code><em> </em>collection in your database. Only the following documents are stored in this collection:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063714\"),\n&nbsp;&nbsp;account_id:&nbsp;1010,\n&nbsp;&nbsp;type:&nbsp;'investment',\n&nbsp;&nbsp;limit:&nbsp;2000000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063715\"),\n&nbsp;&nbsp;account_id:&nbsp;4336,\n&nbsp;&nbsp;type:&nbsp;'derivatives',\n&nbsp;&nbsp;limit:&nbsp;100000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063716\"),\n&nbsp;&nbsp;account_id:&nbsp;4336,\n&nbsp;&nbsp;type:&nbsp;'commodity',\n&nbsp;&nbsp;limit:&nbsp;1000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d067825\"),\n&nbsp;&nbsp;account_id:&nbsp;7355,\n&nbsp;&nbsp;type:&nbsp;'commodity',\n&nbsp;&nbsp;limit:&nbsp;500000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61b1bde1ceb6f770f56b0cd9\"),\n&nbsp;&nbsp;account_id:&nbsp;4915,\n&nbsp;&nbsp;type:&nbsp;'investment',\n&nbsp;&nbsp;limit:&nbsp;2000000\n}</pre><p><br></p><p>How many documents will be returned in response to the following aggregation pipeline?</p><p><br></p><pre class=\"prettyprint linenums\">[{ $group: {\n  _id: \"$type\",\n  number_of_accounts: {\n    $sum: 1\n  }\n}}, { $match: {\n  number_of_accounts: { $gt: 1 }\n}}]</pre><p><br></p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>The <code>$group</code> stage separates documents into groups according to a \"group key\". The output is one document for each unique group key. A group key is often a field, or group of fields. The group key can also be the result of an expression. Use the <code>_id</code> field in the <code>$group</code> pipeline stage to set the group key. The <code>$group</code> stage has the following prototype form:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  $group:\n    {\n      _id: &lt;expression&gt;, // Group key\n      &lt;field1&gt;: { &lt;accumulator1&gt; : &lt;expression1&gt; },\n      ...\n    }\n }</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/aggregation/group/</p>",
                "answers": [
                    "<p>2</p>",
                    "<p>0</p>",
                    "<p>1</p>",
                    "<p>3</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Suppose you have an accounts collection in your database. Only the following documents are stored in this collection:{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063714\"),\n&nbsp;&nbsp;account_id:&nbsp;1010,\n&nbsp;&nbsp;type:&nbsp;'investment',\n&nbsp;&nbsp;limit:&nbsp;2000000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063715\"),\n&nbsp;&nbsp;account_id:&nbsp;4336,\n&nbsp;&nbsp;type:&nbsp;'derivatives',\n&nbsp;&nbsp;limit:&nbsp;100000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063716\"),\n&nbsp;&nbsp;account_id:&nbsp;4336,\n&nbsp;&nbsp;type:&nbsp;'commodity',\n&nbsp;&nbsp;limit:&nbsp;1000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d067825\"),\n&nbsp;&nbsp;account_id:&nbsp;7355,\n&nbsp;&nbsp;type:&nbsp;'commodity',\n&nbsp;&nbsp;limit:&nbsp;500000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61b1bde1ceb6f770f56b0cd9\"),\n&nbsp;&nbsp;account_id:&nbsp;4915,\n&nbsp;&nbsp;type:&nbsp;'investment',\n&nbsp;&nbsp;limit:&nbsp;2000000\n}How many documents will be returned in response to the following aggregation pipeline?[{ $group: {\n  _id: \"$type\",\n  number_of_accounts: {\n    $sum: 1\n  }\n}}, { $match: {\n  number_of_accounts: { $gt: 1 }\n}}]",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168704,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Suppose you have a <code>companies</code><em> </em>collection in your database. Only the following documents are stored in this collection:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da4\"),\n  name: 'Powerset',\n  category_code: 'search',\n  founded_year: 2006\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da5\"),\n  name: 'Technorati',\n  category_code: 'advertising',\n  founded_year: 2002\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da7\"),\n  name: 'AddThis',\n  category_code: 'advertising',\n  founded_year: 2004\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da8\"),\n  name: 'OpenX',\n  category_code: 'advertising',\n  founded_year: 2008\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297daa\"),\n  name: 'Sparter',\n  category_code: 'games_video',\n  founded_year: 2007\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297dac\"),\n  name: 'Veoh',\n  category_code: 'games_video',\n  founded_year: 2004\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297dae\"),\n  name: 'Thoof',\n  category_code: 'web',\n  founded_year: 2006\n}</pre><p><br></p><p>How many documents will be returned in response to the following aggregation pipeline?</p><p><br></p><pre class=\"prettyprint linenums\">[{ $group: {\n  _id: '$category_code',\n  number_of_companies: {\n    $sum: 1\n  }\n}}, { $sort: {\n  number_of_companies: -1\n}}, { $limit: 3 }]</pre><p><br></p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>The <code>$group</code> stage separates documents into groups according to a \"group key\". The output is one document for each unique group key. A group key is often a field, or group of fields. The group key can also be the result of an expression. Use the <code>_id</code> field in the <code>$group</code> pipeline stage to set the group key. The <code>$group</code> stage has the following prototype form:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  $group:\n    {\n      _id: &lt;expression&gt;, // Group key\n      &lt;field1&gt;: { &lt;accumulator1&gt; : &lt;expression1&gt; },\n      ...\n    }\n }</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/aggregation/group/</p>",
                "answers": [
                    "<p>3</p>",
                    "<p>4</p>",
                    "<p>0</p>",
                    "<p>2</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Suppose you have a companies collection in your database. Only the following documents are stored in this collection:{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da4\"),\n  name: 'Powerset',\n  category_code: 'search',\n  founded_year: 2006\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da5\"),\n  name: 'Technorati',\n  category_code: 'advertising',\n  founded_year: 2002\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da7\"),\n  name: 'AddThis',\n  category_code: 'advertising',\n  founded_year: 2004\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da8\"),\n  name: 'OpenX',\n  category_code: 'advertising',\n  founded_year: 2008\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297daa\"),\n  name: 'Sparter',\n  category_code: 'games_video',\n  founded_year: 2007\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297dac\"),\n  name: 'Veoh',\n  category_code: 'games_video',\n  founded_year: 2004\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297dae\"),\n  name: 'Thoof',\n  category_code: 'web',\n  founded_year: 2006\n}How many documents will be returned in response to the following aggregation pipeline?[{ $group: {\n  _id: '$category_code',\n  number_of_companies: {\n    $sum: 1\n  }\n}}, { $sort: {\n  number_of_companies: -1\n}}, { $limit: 3 }]",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168706,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Suppose you have a <code>companies</code><em> </em>collection in your database. Only the following documents are stored in this collection:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da4\"),\n  name: 'Powerset',\n  category_code: 'search',\n  founded_year: 2006\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da5\"),\n  name: 'Technorati',\n  category_code: 'advertising',\n  founded_year: 2002\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da7\"),\n  name: 'AddThis',\n  category_code: 'advertising',\n  founded_year: 2004\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da8\"),\n  name: 'OpenX',\n  category_code: 'advertising',\n  founded_year: 2008\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297daa\"),\n  name: 'Sparter',\n  category_code: 'games_video',\n  founded_year: 2007\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297dac\"),\n  name: 'Veoh',\n  category_code: 'games_video',\n  founded_year: 2004\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297dae\"),\n  name: 'Thoof',\n  category_code: 'web',\n  founded_year: 2006\n}</pre><p><br></p><p>What is the default sort order in the result set returned in response to the following query?</p><p><br></p><pre class=\"prettyprint linenums\">db.companies.aggregate( [ { \"$sortByCount\": \"$category_code\" } ] )</pre><p><br></p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    ""
                ],
                "explanation": "<p><code>$sortByCount</code> groups incoming documents based on the value of a specified expression, then computes the count of documents in each distinct group. Each output document contains two fields: an <code>_id</code> field containing the distinct grouping value, and a <code>count</code> field containing the number of documents belonging to that grouping or category. The documents are sorted by <code>count</code> in <strong>descending </strong>order. The <code>$sortByCount</code> stage has the following prototype form:</p><p><br></p><pre class=\"prettyprint linenums\">{ $sortByCount:  &lt;expression&gt; }</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/</p>",
                "answers": [
                    "<p>descending</p>",
                    "<p>ascending</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Suppose you have a companies collection in your database. Only the following documents are stored in this collection:{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da4\"),\n  name: 'Powerset',\n  category_code: 'search',\n  founded_year: 2006\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da5\"),\n  name: 'Technorati',\n  category_code: 'advertising',\n  founded_year: 2002\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da7\"),\n  name: 'AddThis',\n  category_code: 'advertising',\n  founded_year: 2004\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297da8\"),\n  name: 'OpenX',\n  category_code: 'advertising',\n  founded_year: 2008\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297daa\"),\n  name: 'Sparter',\n  category_code: 'games_video',\n  founded_year: 2007\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297dac\"),\n  name: 'Veoh',\n  category_code: 'games_video',\n  founded_year: 2004\n},\n{\n  _id: ObjectId(\"52cdef7c4bab8bd675297dae\"),\n  name: 'Thoof',\n  category_code: 'web',\n  founded_year: 2006\n}What is the default sort order in the result set returned in response to the following query?db.companies.aggregate( [ { \"$sortByCount\": \"$category_code\" } ] )",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168708,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>The <code>$sortByCount</code> stage is equivalent to:</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>$sortByCount</code> groups incoming documents based on the value of a specified expression, then computes the count of documents in each distinct group. Each output document contains two fields: an <code>_id</code> field containing the distinct grouping value, and a <code>count</code> field containing the number of documents belonging to that grouping or category. The documents are sorted by <code>count</code> in <strong>descending </strong>order. The <code>$sortByCount</code> stage has the following prototype form:</p><p><br></p><pre class=\"prettyprint linenums\">{ $sortByCount:  &lt;expression&gt; }</pre><p><br></p><p>The <code>$sortByCount</code> stage is equivalent to the following <code>$group</code> + <code>$sort</code> sequence:</p><p><br></p><pre class=\"prettyprint linenums\">{ $group: { _id: &lt;expression&gt;, count: { $sum: 1 } } },\n{ $sort: { count: -1 } }</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/</p>",
                "answers": [
                    "<p><code>$group</code> + <code>$sort</code></p>",
                    "<p><code>$match</code> + <code>$sort</code></p>",
                    "<p><code>$text</code> + <code>$search</code> + <code>$sort</code></p>",
                    "<p><code>$count</code> + <code>$sort</code></p>",
                    "<p><code>$sort</code> + <code>$count</code></p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "The $sortByCount stage is equivalent to:",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168710,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>In Aggregation Framework each individual pipeline stage has a limit of...</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Each individual pipeline stage has a limit of 100 megabytes of RAM. By default, if a stage exceeds this limit, MongoDB produces an error. For some pipeline stages you can allow pipeline processing to take up more space by using the allowDiskUse option to enable aggregation pipeline stages to write data to temporary files.</p><p><br></p><p>https://www.mongodb.com/docs/manual/core/aggregation-pipeline-limits/</p>",
                "answers": [
                    "<p>...100 megabytes of RAM.</p>",
                    "<p>...1000 megabytes of RAM.</p>",
                    "<p>...500 megabytes of RAM.</p>",
                    "<p>...200 megabytes of RAM.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "In Aggregation Framework each individual pipeline stage has a limit of...",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168712,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>What is MongoDB Compass?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>MongoDB Compass is a powerful GUI for querying, aggregating, and analyzing your MongoDB data in a visual environment. Compass is free to use and source available, and can be run on macOS, Windows, and Linux.</p><p><br></p><p>https://docs.mongodb.com/compass/current/</p>",
                "answers": [
                    "<p>It is a GUI for MongoDB.</p>",
                    "<p>Special data type in MongoDB to store geospatial data.</p>",
                    "<p>A map-based chart type that is available with MongoDB Charts.</p>",
                    "<p>MongoDB product that helps you visualize data stored in an Atlas cluster.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "What is MongoDB Compass?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168714,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Which of the following commands will add a collection that is stored in BSON file to a MongoDB cluster?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>The <code>mongorestore</code> program loads data from either a binary database dump created by <code>mongodump</code> or the standard input into a <code>mongod</code> or <code>mongos</code> instance.</p><p><br></p><p>https://www.mongodb.com/docs/database-tools/mongorestore/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">mongorestore</pre>",
                    "<pre class=\"prettyprint linenums\">mongodump</pre>",
                    "<pre class=\"prettyprint linenums\">mongoimport</pre>",
                    "<pre class=\"prettyprint linenums\">mongoexport</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Which of the following commands will add a collection that is stored in BSON file to a MongoDB cluster?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168716,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>There is a collection named <code>products</code> in MongoDB database. Your coworker wants to know how many products are in this collection (number of documents in the collection). Which query should you use? (select 2)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>db.collection.count(query, options)</code> returns the count of documents that would match a <code>find()</code> query for the collection or view.</p><p><code>db.collection.countDocuments(query, options)</code> returns the count of documents that match the query for a collection or view.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.count/</p><p>https://docs.mongodb.com/manual/reference/method/db.collection.countDocuments/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.products.countDocuments()</pre>",
                    "<pre class=\"prettyprint linenums\">db.products.find().count()</pre>",
                    "<pre class=\"prettyprint linenums\">db.products.total()</pre>",
                    "<pre class=\"prettyprint linenums\">db.products.aggregate()</pre>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "",
            "question_plain": "There is a collection named products in MongoDB database. Your coworker wants to know how many products are in this collection (number of documents in the collection). Which query should you use? (select 2)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168718,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Given the following MongoDB URI:</p><p><br></p><pre class=\"prettyprint linenums\">mongodb+srv://datascientist34:ta33w9rd@xtr-187.srv.net/admin</pre><p><br></p><p>Which of the following statements are true? (select 2)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>The standard URI connection scheme has the form:</p><p><br></p><pre class=\"prettyprint linenums\">mongodb://[username:password@]host1[:port1][,...hostN[:portN]][/[defaultauthdb][?options]]</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/connection-string/</p>",
                "answers": [
                    "<p>The user <em>datascientist34 </em>is trying to authenticate on database admin.</p>",
                    "<p>The password used for authentication is <code>xtr-178</code></p>",
                    "<p>The password used for authentication is <code>ta33w9rd</code> </p>",
                    "<p>There are 178 nodes in the <em>xtr </em>replica set.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "",
            "question_plain": "Given the following MongoDB URI:mongodb+srv://datascientist34:ta33w9rd@xtr-187.srv.net/adminWhich of the following statements are true? (select 2)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168720,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Suppose you have a <code>movies</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  _id: ObjectId(\"573a1390f29313caabcd60e4\"),\n  title: 'The Immigrant',\n  fullplot: \"Charlie is on his way to the USA. He wins in a card game, puts the money in Edna's bag (she and her sick mother have been robbed of everything). When he retrieves a little for himself he is accused of being a thief. Edna clears his name. Later, broke, Charlie finds a coin and goes into a restaurant.\"\n}</pre><p><br></p><p>You want to sort result set by a relevance score computed by MongoDB in text search query and extract only three documents with the highest score. Which query do you need to use?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>The <code>$text</code> operator assigns a score to each document that contains the search term in the indexed fields. The score represents the relevance of a document to a given text search query. The score can be part of a <code>sort()</code> method specification as well as part of the projection expression. The <code>{ $meta: \"textScore\" }</code> expression provides information on the processing of the <code>$text</code> operation.</p><p><br></p><p>https://docs.mongodb.com/manual/text-search/</p><p>https://docs.mongodb.com/manual/core/index-text/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.movies.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{ $text:&nbsp;{ $search:&nbsp;'spaceship' } },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ score:&nbsp;{ $meta:&nbsp;'textScore' } },\n).sort( { score:&nbsp;{ $meta:&nbsp;'textScore' } } ).limit(3)</pre>",
                    "<pre class=\"prettyprint linenums\">db.movies.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{ $text:&nbsp;{ $search:&nbsp;'spaceship' } },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ score:&nbsp;{ $meta:&nbsp;'textScore' } },\n).sort( { score:&nbsp;{ $meta:&nbsp;'textScore' } } )</pre>",
                    "<pre class=\"prettyprint linenums\">db.movies.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{},&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ score:&nbsp;{ $meta:&nbsp;'textScore' } },\n).sort( { score:&nbsp;{ $meta:&nbsp;'textScore' } } ).limit(3)</pre>",
                    "<pre class=\"prettyprint linenums\">db.movies.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{ $text:&nbsp;{ $search:&nbsp;'spaceship' } },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ score:&nbsp;{ $meta:&nbsp;'textScore' } },\n).sort( { score:&nbsp;{ $meta:&nbsp;'score' } } ).limit(3)</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Suppose you have a movies collection with the following document structure:{\n  _id: ObjectId(\"573a1390f29313caabcd60e4\"),\n  title: 'The Immigrant',\n  fullplot: \"Charlie is on his way to the USA. He wins in a card game, puts the money in Edna's bag (she and her sick mother have been robbed of everything). When he retrieves a little for himself he is accused of being a thief. Edna clears his name. Later, broke, Charlie finds a coin and goes into a restaurant.\"\n}You want to sort result set by a relevance score computed by MongoDB in text search query and extract only three documents with the highest score. Which query do you need to use?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168722,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Given a <code>movies</code><em> </em>collection where each document has the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    _id: ObjectId('573a1390f29313caabcd60e4'),\n    genres: [ 'Short', 'Comedy', 'Drama' ],\n    title: 'The Immigrant',\n    year: 1917,\n    imdb: { rating: 7.8, votes: 4680, id: 8133 },\n    countries: [ 'USA' ]\n}</pre><p><br></p><p>Which of the following queries will find all the movies that have more votes than the year in which they were released?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>db.collection.find(query, projection)</code> selects documents in a collection or view and returns a cursor to the selected documents. The <code>projection</code> parameter determines which fields are returned in the matching documents.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.find/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.movies.find({&nbsp;$expr:&nbsp;{&nbsp;$gt:&nbsp;[\"$imdb.votes\",&nbsp;\"$year\"]&nbsp;}&nbsp;} )</pre>",
                    "<pre class=\"prettyprint linenums\">db.movies.find({&nbsp;$expr:&nbsp;{&nbsp;$lt:&nbsp;[\"$imdb.votes\",&nbsp;\"$year\"]&nbsp;}&nbsp;} )</pre>",
                    "<pre class=\"prettyprint linenums\">db.movies.find({&nbsp;$expr:&nbsp;{&nbsp;$gt:&nbsp;[\"imdb.votes\",&nbsp;\"year\"]&nbsp;}&nbsp;} )</pre>",
                    "<pre class=\"prettyprint linenums\">db.movies.find({&nbsp;$gt:&nbsp;[\"$imdb.votes\",&nbsp;\"$year\"]&nbsp;} )</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Given a movies collection where each document has the following structure:{\n    _id: ObjectId('573a1390f29313caabcd60e4'),\n    genres: [ 'Short', 'Comedy', 'Drama' ],\n    title: 'The Immigrant',\n    year: 1917,\n    imdb: { rating: 7.8, votes: 4680, id: 8133 },\n    countries: [ 'USA' ]\n}Which of the following queries will find all the movies that have more votes than the year in which they were released?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168724,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Which collection method do you need to use to drop a specific collection?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>db.collection.drop(&lt;options&gt;)</code> removes a collection or view from the database. The method also removes any indexes associated with the dropped collection. The method provides a wrapper around the <code>drop</code> command.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.drop/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.collection.drop()</pre>",
                    "<pre class=\"prettyprint linenums\">db.collection.dropIndex()</pre>",
                    "<pre class=\"prettyprint linenums\">db.collection.dropCollection()</pre>",
                    "<pre class=\"prettyprint linenums\">db.collection.remove()</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Which collection method do you need to use to drop a specific collection?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168726,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Suppose you have an <code>accounts</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063714\"),\n&nbsp;&nbsp;account_id:&nbsp;1010,\n&nbsp;&nbsp;type:&nbsp;'investment',\n&nbsp;&nbsp;limit:&nbsp;1000000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063715\"),\n&nbsp;&nbsp;account_id:&nbsp;4336,\n&nbsp;&nbsp;type:&nbsp;'derivatives',\n&nbsp;&nbsp;limit:&nbsp;100000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063716\"),\n&nbsp;&nbsp;account_id:&nbsp;4336,\n&nbsp;&nbsp;type:&nbsp;'commodity',\n&nbsp;&nbsp;limit:&nbsp;1000\n}</pre><p><br></p><p>Which of the following documents would be modified by this update?</p><p><br></p><pre class=\"prettyprint linenums\">db.accounts.updateMany( \n   { \"type\": \"investment\" }, \n   { \"$set\": { \"limit\": 2000000 } } \n)</pre><p><br></p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>db.collection.updateMany(filter, update, options)</code> updates all documents that match the specified filter for a collection. The <code>updateMany()</code> method has the following form:</p><p><br></p><pre class=\"prettyprint linenums\">db.collection.updateMany(\n   &lt;filter&gt;,\n   &lt;update&gt;,\n   {\n     upsert: &lt;boolean&gt;,\n     writeConcern: &lt;document&gt;,\n     collation: &lt;document&gt;,\n     arrayFilters: [ &lt;filterdocument1&gt;, ... ],\n     hint:  &lt;document|string&gt;        // Available starting in MongoDB 4.2.1\n   }\n)</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.updateMany/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063714\"),\n&nbsp;&nbsp;account_id:&nbsp;1010,\n&nbsp;&nbsp;type:&nbsp;'investment',\n&nbsp;&nbsp;limit:&nbsp;1000000\n}</pre>",
                    "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61b1bde1ceb6f770f56b0cd9\"),\n&nbsp;&nbsp;account_id:&nbsp;4915,\n&nbsp;&nbsp;type:&nbsp;'investment',\n&nbsp;&nbsp;limit:&nbsp;1000000\n}</pre>",
                    "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d067825\"),\n&nbsp;&nbsp;account_id:&nbsp;7355,\n&nbsp;&nbsp;type:&nbsp;'commodity',\n&nbsp;&nbsp;limit:&nbsp;500000\n}</pre>",
                    "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063715\"),\n&nbsp;&nbsp;account_id:&nbsp;4336,\n&nbsp;&nbsp;type:&nbsp;'derivatives',\n&nbsp;&nbsp;limit:&nbsp;100000\n}</pre>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "",
            "question_plain": "Suppose you have an accounts collection with the following document structure:{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063714\"),\n&nbsp;&nbsp;account_id:&nbsp;1010,\n&nbsp;&nbsp;type:&nbsp;'investment',\n&nbsp;&nbsp;limit:&nbsp;1000000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063715\"),\n&nbsp;&nbsp;account_id:&nbsp;4336,\n&nbsp;&nbsp;type:&nbsp;'derivatives',\n&nbsp;&nbsp;limit:&nbsp;100000\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063716\"),\n&nbsp;&nbsp;account_id:&nbsp;4336,\n&nbsp;&nbsp;type:&nbsp;'commodity',\n&nbsp;&nbsp;limit:&nbsp;1000\n}Which of the following documents would be modified by this update?db.accounts.updateMany( \n   { \"type\": \"investment\" }, \n   { \"$set\": { \"limit\": 2000000 } } \n)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168728,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Select all true statements about the differences between using <code>aggregate()</code> and <code>find()</code> methods. (select 2)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>db.collection.find(query, projection)</code> selects documents in a collection or view and returns a cursor to the selected documents. The <code>projection</code> parameter determines which fields are returned in the matching documents.</p><p><br></p><p><code>db.collection.aggregate(pipeline, options)</code> calculates aggregate values for the data in a collection or a view.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.find/</p><p>https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/</p>",
                "answers": [
                    "<p><code>find()</code> allows us to compute and reshape data in the cursor.</p>",
                    "<p>Any <code>find()</code> query can be translated into an aggregation pipeline.</p>",
                    "<p>Any aggregation pipeline can be translated into a <code>find()</code> query.</p>",
                    "<p><code>aggregate()</code> allows us to compute and reshape data in the cursor (like <code>$group</code>, <code>$min</code> and other stages).</p>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "",
            "question_plain": "Select all true statements about the differences between using aggregate() and find() methods. (select 2)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168730,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Which cursor method should you use to force MongoDB to use a specific index for a query?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>You can call <code>cursor.hint()</code>&nbsp;method on a query to override MongoDB's default index selection and query optimization process.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/cursor.hint/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">cursor.hint()</pre>",
                    "<pre class=\"prettyprint linenums\">cursor.index()</pre>",
                    "<pre class=\"prettyprint linenums\">cursor.use()</pre>",
                    "<pre class=\"prettyprint linenums\">cursor.explain()</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Which cursor method should you use to force MongoDB to use a specific index for a query?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168732,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Select the properly used <code>$out</code> operator.</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code><strong>$out</strong></code><strong> </strong>stage takes the documents returned by the aggregation pipeline and writes them to a specified collection. Starting in MongoDB 4.4, you can specify the output database. The <code>$out</code> stage must be <em>the last stage</em> in the pipeline. The <code>$out</code> operator lets the aggregation framework return result sets of any size.</p><p><br></p><p>Starting in MongoDB 4.4, <code>$out</code> can take a document to specify the output database as well as the output collection:</p><p><br></p><pre class=\"prettyprint linenums\">{ $out: { db: \"&lt;output-db&gt;\", coll: \"&lt;output-collection&gt;\" } }</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/aggregation/out/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.collection.aggregate([\n&nbsp;&nbsp;&nbsp;&nbsp;{ stage1 },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ stage2 },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;...,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ stageN },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ $out:&nbsp;\"new_collection\" }\n])</pre>",
                    "<pre class=\"prettyprint linenums\">db.collection.aggregate([\n&nbsp;&nbsp;&nbsp;&nbsp;{ $out:&nbsp;\"new_collection\" },&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ stage1 },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ stage2 },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;...,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ $stageN }\n])</pre>",
                    "<pre class=\"prettyprint linenums\">db.collection.aggregate([\n&nbsp;&nbsp;&nbsp;&nbsp;{ stage1 },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ $out:&nbsp;\"new_collection\" },\n&nbsp;&nbsp;&nbsp;&nbsp;{ stage2 },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;...,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ stageN }\n])</pre>",
                    "<pre class=\"prettyprint linenums\">db.collection.aggregate([\n&nbsp;&nbsp;&nbsp;&nbsp;{ stage1 },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ $out:&nbsp;\"new_collection\" },\n&nbsp;&nbsp;&nbsp;&nbsp;{ stage2 }\n])</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Select the properly used $out operator.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168734,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Select all true statements about data modeling in MongoDB. (select 2)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>The field set and data type for each field <strong>can</strong> differ across documents within a collection.</p><p>In MongoDB we <strong>can </strong>enforce document validation rules for a collection during update and insert operations.</p><p><br></p><p>https://docs.mongodb.com/manual/core/data-modeling-introduction/</p>",
                "answers": [
                    "<p>MongoDB can easily handle both unstructured and structured data sets.</p>",
                    "<p>Unlike SQL databases, where the table schema must be specified and declared before inserting the data, MongoDB collections don't, by default, require documents to have the same schema.</p>",
                    "<p>The field set and data type for each field cannot differ across documents within a collection.</p>",
                    "<p>In MongoDB we cannot enforce document validation rules for a collection during update and insert operations.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "",
            "question_plain": "Select all true statements about data modeling in MongoDB. (select 2)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168736,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Let's consider a one-to-many relationship observed between an instructor and the courses he is created on an e-learning platform. We assume that a course can only have one instructor, and an instructor can have multiple courses.</p><p><br></p><p>Which of the following are the correct ways to represent this one-to-many relationship with a document model in MongoDB? (select 2)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Embed all the fields for a course as a subdocument in the corresponding instructor document.</p><p>These subdocuments must be put into an array, not stored directly as a subdocument in its parent. This way we can have a variable number of referenced documents and use a multi-key index to search the \"many\" side. This is not the best way to do it.</p><p><br></p><p>https://docs.mongodb.com/manual/tutorial/model-embedded-one-to-many-relationships-between-documents/</p>",
                "answers": [
                    "<p>Embed the entities for the courses as an array of sub-documents in the corresponding instructor document.</p>",
                    "<p>Have a collection for the instructors and a collection for the courses with each course document having a field to reference the document of its instructor.</p>",
                    "<p>Embed all the fields for a course as a subdocument in the corresponding instructor document.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "",
            "question_plain": "Let's consider a one-to-many relationship observed between an instructor and the courses he is created on an e-learning platform. We assume that a course can only have one instructor, and an instructor can have multiple courses.Which of the following are the correct ways to represent this one-to-many relationship with a document model in MongoDB? (select 2)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168738,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Consider a many-to-many relationship observed between <code>courses</code> and the <code>students</code><em> </em>enrolled in these <code>courses</code> on the e-learning platform.</p><p><br></p><p>Which of the following are true about modeling this many-to-many relationship with the document model in MongoDB? (select 3)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>The many-to-many relationship <strong>can </strong>be represented in MongoDB.</p><p><br></p><p>https://docs.mongodb.com/manual/applications/data-models-relationships/</p>",
                "answers": [
                    "<p>Embedding <code>students</code><em> </em>in <code>courses</code><em> </em>duplicates student information.</p>",
                    "<p>Embedding <code>students</code><em> </em>in <code>courses</code><em> </em>still requires a separate collection to store all students (we may have students who are not enrolled in any course).</p>",
                    "<p>When using one collection for <code>students</code><em> </em>and one collection for <code>courses</code><em> </em>there is a need for an array of references in only one collection.</p>",
                    "<p>The many-to-many relationship cannot be represented in MongoDB.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "",
            "question_plain": "Consider a many-to-many relationship observed between courses and the students enrolled in these courses on the e-learning platform.Which of the following are true about modeling this many-to-many relationship with the document model in MongoDB? (select 3)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168740,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Consider a one-to-one relationship observed between <code>users</code> and the <code>users_details</code>. Basic information about application users is separated from detailed information.</p><p><br></p><p>Which of the following are true about modeling this one-to-one relationship with the document model in MongoDB? (select 2)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>We <strong>can</strong> link to a single document with detailed information in another collection.</p><p><br></p><p>https://docs.mongodb.com/manual/tutorial/model-embedded-one-to-one-relationships-between-documents/</p>",
                "answers": [
                    "<p>We can embed fields with detailed information in the <code>users</code><em> </em>collection.</p>",
                    "<p>We can embed fields with detailed information as a subdocument in the <code>users</code><em> </em>collection.</p>",
                    "<p>We cannot link to a single document with detailed information in another collection.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "",
            "question_plain": "Consider a one-to-one relationship observed between users and the users_details. Basic information about application users is separated from detailed information.Which of the following are true about modeling this one-to-one relationship with the document model in MongoDB? (select 2)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168742,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Which of the following scenarios is best suited for applying the Attribute Pattern?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>https://www.mongodb.com/blog/post/building-with-patterns-the-attribute-pattern</p>",
                "answers": [
                    "<p>You need to apply document validation before inserting/modifying.</p>",
                    "<p>Some fields share a similar characteristics, and you want to search across those fields.</p>",
                    "<p>The documents in the collection are quite large.</p>",
                    "<p>Product categories in the online store.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "",
            "question_plain": "Which of the following scenarios is best suited for applying the Attribute Pattern?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168744,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>You have the following index in a <code>movies</code><em> </em>collection:</p><p><br></p><pre class=\"prettyprint linenums\">{&nbsp;\"title\":&nbsp;1,&nbsp;\"imdb.rating\":&nbsp;-1,&nbsp;\"imdb.votes\":&nbsp;-1,&nbsp;\"type\":&nbsp;1&nbsp;}</pre><p><br></p><p>Can the following query use the given index for both filtering and sorting?</p><p><br></p><pre class=\"prettyprint linenums\">db.movies.find( {&nbsp;\"title\":&nbsp;{&nbsp;\"$lt\":&nbsp;\"M\"&nbsp;}&nbsp;} ).sort( {&nbsp;\"imdb.votes\":&nbsp;-1&nbsp;} )</pre><p><br></p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    ""
                ],
                "explanation": "<p>No, this query does not use equality in the index prefix. When you use an index to filter and sort, the query must contain equality conditions on all prefix keys that precede the sort keys. Also, it skipped the next key in the \"imdb.rating\" prefix in the sort predicate.</p><p><br></p><p>https://docs.mongodb.com/manual/indexes/</p>",
                "answers": [
                    "<p>No</p>",
                    "<p>Yes</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "You have the following index in a movies collection:{&nbsp;\"title\":&nbsp;1,&nbsp;\"imdb.rating\":&nbsp;-1,&nbsp;\"imdb.votes\":&nbsp;-1,&nbsp;\"type\":&nbsp;1&nbsp;}Can the following query use the given index for both filtering and sorting?db.movies.find( {&nbsp;\"title\":&nbsp;{&nbsp;\"$lt\":&nbsp;\"M\"&nbsp;}&nbsp;} ).sort( {&nbsp;\"imdb.votes\":&nbsp;-1&nbsp;} )",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168746,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Select all true statements about query plans in MongoDB. (select 3)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>For a query, the MongoDB query optimizer chooses and caches the most efficient query plan given the available indexes. To view the query plan information for a given query, you can use <code>db.collection.explain()</code> or the <code>cursor.explain()</code> .</p><p><br></p><p>https://docs.mongodb.com/manual/core/query-plans/</p>",
                "answers": [
                    "<p>Query plans are cached so that plans don't have to be generated and compared with each other each time a query is executed.</p>",
                    "<p>For a given query, each index in the collection generates at least one query plan.</p>",
                    "<p>If there are no indexes for the query, the main stage in the query plan will be the COLLSCAN stage.</p>",
                    "<p>To view the query plan information for a given query, you can use <code>db.collection.explain()</code> or the <code>cursor.explain()</code> .</p>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "d"
            ],
            "section": "",
            "question_plain": "Select all true statements about query plans in MongoDB. (select 3)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168748,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Select the method that forces MongoDB to use a specific index.</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>cursor.hint(index)</code> Call this method on a query to override MongoDB's default index selection and query optimization process.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/cursor.hint/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">hint()</pre>",
                    "<pre class=\"prettyprint linenums\">index()</pre>",
                    "<pre class=\"prettyprint linenums\">explain()</pre>",
                    "<pre class=\"prettyprint linenums\">force()</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Select the method that forces MongoDB to use a specific index.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168750,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>You have the following query:</p><p><br></p><pre class=\"prettyprint linenums\">db.gamers.find(\n    { \"level\":&nbsp;{&nbsp;\"$gte\"&nbsp;:&nbsp;70&nbsp;},&nbsp;\"map\":&nbsp;\"Inferno\"&nbsp;}&nbsp;\n).sort( {&nbsp;\"points\":&nbsp;1,&nbsp;\"group\":&nbsp;1&nbsp;} )</pre><p><br></p><p>Which of the following indexes best supports this query? Keep in mind the equality, sort, range rule.</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Indexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must perform a <em>collection scan</em>, i.e. scan every document in a collection, to select those documents that match the query statement. If an appropriate index exists for a query, MongoDB can use the index to limit the number of documents it must inspect.</p><p><br></p><p>https://docs.mongodb.com/manual/indexes/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">{ map: 1, points: 1, group: 1, level: 1 }</pre>",
                    "<pre class=\"prettyprint linenums\">{ level: 1, map: 1, points: 1, group: 1 }</pre>",
                    "<pre class=\"prettyprint linenums\">{ points: 1, group: 1, level: 1, map: 1 }</pre>",
                    "<pre class=\"prettyprint linenums\">{ points: 1, group: 1, map: 1, level: 1 }</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "You have the following query:db.gamers.find(\n    { \"level\":&nbsp;{&nbsp;\"$gte\"&nbsp;:&nbsp;70&nbsp;},&nbsp;\"map\":&nbsp;\"Inferno\"&nbsp;}&nbsp;\n).sort( {&nbsp;\"points\":&nbsp;1,&nbsp;\"group\":&nbsp;1&nbsp;} )Which of the following indexes best supports this query? Keep in mind the equality, sort, range rule.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168752,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>You want to execute the following query quite often in your application:</p><p><br></p><pre class=\"prettyprint linenums\">db.hotels.aggregate([\n&nbsp;&nbsp;{&nbsp;\"$match\":&nbsp;{&nbsp;\"stars\":&nbsp;{&nbsp;\"$gt\":&nbsp;4.5&nbsp;}&nbsp;}&nbsp;},\n&nbsp;&nbsp;{&nbsp;\"$sort\":&nbsp;{&nbsp;\"stars\":&nbsp;1&nbsp;}&nbsp;}\n])</pre><p><br></p><p>Your collection doesn't have any additional indexes. Which index should you create to support this query?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Indexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must perform a <em>collection scan</em>, i.e. scan every document in a collection, to select those documents that match the query statement. If an appropriate index exists for a query, MongoDB can use the index to limit the number of documents it must inspect.</p><p><br></p><p>https://docs.mongodb.com/manual/indexes/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.hotels.createIndex( {&nbsp;\"stars\":&nbsp;1&nbsp;} )</pre>",
                    "<pre class=\"prettyprint linenums\">db.hotels.createIndex( {&nbsp;\"match\":&nbsp;1&nbsp;} )</pre>",
                    "<p>In this case, the index could not be created.</p>",
                    "<pre class=\"prettyprint linenums\">db.hotels.createIndex( {&nbsp;\"stars\":&nbsp;1, \"stars\": -1&nbsp;} )</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "You want to execute the following query quite often in your application:db.hotels.aggregate([\n&nbsp;&nbsp;{&nbsp;\"$match\":&nbsp;{&nbsp;\"stars\":&nbsp;{&nbsp;\"$gt\":&nbsp;4.5&nbsp;}&nbsp;}&nbsp;},\n&nbsp;&nbsp;{&nbsp;\"$sort\":&nbsp;{&nbsp;\"stars\":&nbsp;1&nbsp;}&nbsp;}\n])Your collection doesn't have any additional indexes. Which index should you create to support this query?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168754,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Select all true statements regarding to multikey indexes. (select 3)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>To index a field that holds an array value, MongoDB creates an index key for each element in the array. These <em>multikey</em> indexes support efficient queries against array fields. Multikey indexes can be constructed over arrays that hold both scalar values (e.g. strings, numbers) <em>and</em> nested documents. To create a multikey index, use the <code>db.collection.createIndex()</code> method.</p><p><br></p><p>https://docs.mongodb.com/manual/core/index-multikey/</p>",
                "answers": [
                    "<p>Multikey indexes allow us to index on array fields.</p>",
                    "<p>Multikey indexes don't support indexes on multiple array fields on single documents.</p>",
                    "<p>An index doesn't become multikey until a document that has an array value is inserted.</p>",
                    "<p>To create a multikey index, use the <code>db.collection.createMultikeyIndex()</code> method.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "",
            "question_plain": "Select all true statements regarding to multikey indexes. (select 3)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168756,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>We have the following indexes:</p><p><br></p><pre class=\"prettyprint linenums\">{&nbsp;name:&nbsp;1,&nbsp;founded_year:&nbsp;1&nbsp;}\n{&nbsp;tag_list:&nbsp;1,&nbsp;is_active:&nbsp;1&nbsp;}</pre><p><br></p><p>And the following documents:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    _id: ObjectId(\"52cdef7c4bab8bd675297daa\"),\n    name: \"Sparter\",\n    founded_year: 2007,\n    tag_list: [\"gaming\", \"game\", \"wow\"],\n    is_active: true\n},\n{\n&nbsp;&nbsp;&nbsp;&nbsp;_id:&nbsp;ObjectId(\"52cdef7c4bab8bd675297da3\"),\n&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;\"Yahoo!\",\n&nbsp;&nbsp;&nbsp;&nbsp;founded_year:&nbsp;1994,\n&nbsp;&nbsp;&nbsp;&nbsp;tag_list:&nbsp;[\"search\",&nbsp;\"webmail\"],\n    is_active: true\n}</pre><p><br></p><p>Select all index keys created across all of these documents and indexes.</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>To index a field that holds an array value, MongoDB creates an index key for each element in the array. These <em>multikey</em> indexes support efficient queries against array fields. Multikey indexes can be constructed over arrays that hold both scalar values (e.g. strings, numbers) <em>and</em> nested documents. To create a multikey index, use the <code>db.collection.createIndex()</code> method.</p><p><br></p><p>https://docs.mongodb.com/manual/core/index-multikey/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">{&nbsp;name:&nbsp;\"Sparter\",&nbsp;founded_year:&nbsp;2007}\n{&nbsp;name:&nbsp;\"Yahoo!\",&nbsp;founded_year:&nbsp;1994}\n{&nbsp;tag_list:&nbsp;\"gaming\",&nbsp;is_active:&nbsp;true&nbsp;}\n{&nbsp;tag_list:&nbsp;\"game\",&nbsp;is_active:&nbsp;true&nbsp;}\n{&nbsp;tag_list:&nbsp;\"wow\",&nbsp;is_active:&nbsp;true&nbsp;}\n{&nbsp;tag_list:&nbsp;\"search\",&nbsp;is_active:&nbsp;true&nbsp;}\n{&nbsp;tag_list:&nbsp;\"webmail\",&nbsp;is_active:&nbsp;true&nbsp;}</pre>",
                    "<pre class=\"prettyprint linenums\">{&nbsp;name:&nbsp;\"Sparter\",&nbsp;founded_year:&nbsp;2007}\n{&nbsp;name:&nbsp;\"Yahoo!\",&nbsp;founded_year:&nbsp;1994}\n{&nbsp;tag_list:&nbsp;[\"gaming\", \"game\", \"wow\"],&nbsp;is_active:&nbsp;true&nbsp;}\n{&nbsp;tag_list:&nbsp;[\"search\",&nbsp;\"webmail\"],&nbsp;is_active:&nbsp;true&nbsp;}</pre>",
                    "<p>The index keys cannot be determined from the given data.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "We have the following indexes:{&nbsp;name:&nbsp;1,&nbsp;founded_year:&nbsp;1&nbsp;}\n{&nbsp;tag_list:&nbsp;1,&nbsp;is_active:&nbsp;1&nbsp;}And the following documents:{\n    _id: ObjectId(\"52cdef7c4bab8bd675297daa\"),\n    name: \"Sparter\",\n    founded_year: 2007,\n    tag_list: [\"gaming\", \"game\", \"wow\"],\n    is_active: true\n},\n{\n&nbsp;&nbsp;&nbsp;&nbsp;_id:&nbsp;ObjectId(\"52cdef7c4bab8bd675297da3\"),\n&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;\"Yahoo!\",\n&nbsp;&nbsp;&nbsp;&nbsp;founded_year:&nbsp;1994,\n&nbsp;&nbsp;&nbsp;&nbsp;tag_list:&nbsp;[\"search\",&nbsp;\"webmail\"],\n    is_active: true\n}Select all index keys created across all of these documents and indexes.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168758,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>You are working in a team on a certain application in the gaming sector. Queries similar to the following are quite often executed by your application.</p><p><br></p><pre class=\"prettyprint linenums\">db.gamers.find( { level: 10, is_active: true } )</pre><p><br></p><p>How can you speed up the execution of similar queries? Select the best option.</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>db.collection.createIndex(keys, options, commitQuorum)</code> creates indexes on collections.</p><p><br></p><p>The following index will be the best option: (covered query):</p><p><br></p><pre class=\"prettyprint linenums\">db.gamers.createIndex( { level: 1, is_active: 1 } )</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/</p>",
                "answers": [
                    "<p>Create the given index:</p><p><br></p><pre class=\"prettyprint linenums\">db.gamers.createIndex( { level: 1, is_active: 1 } )</pre>",
                    "<p>Create the given index:</p><p><br></p><pre class=\"prettyprint linenums\">db.gamers.createIndex( { level: 1 } )</pre>",
                    "<p>Create the given index:</p><p><br></p><pre class=\"prettyprint linenums\">db.gamers.createIndex( { is_active: 1 } )</pre>",
                    "<p>There is no way to speed up this query.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "You are working in a team on a certain application in the gaming sector. Queries similar to the following are quite often executed by your application.db.gamers.find( { level: 10, is_active: true } )How can you speed up the execution of similar queries? Select the best option.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168760,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>You have a configuration file for <code>mongod</code><em> </em>instance called <code>mongod.conf</code> in your working directory. How can you launch <code>mongod</code><em> </em>instance with this configuration file? (select 2)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>To configure <code>mongod</code> using a config file, specify the config file with the <code>--config</code> option or the <code>-f</code> option. For example, the following uses <code>mongod --config &lt;configuration file&gt;</code>:</p><p><br></p><pre class=\"prettyprint linenums\">mongod --config /etc/mongod.conf</pre><p><br></p><p>You can also use the <code>-f</code> alias to specify the configuration file, as in the following:</p><p><br></p><pre class=\"prettyprint linenums\">mongod -f /etc/mongod.conf</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/configuration-options/#use-the-configuration-file</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">mongod&nbsp;--config&nbsp;mongod.conf</pre>",
                    "<pre class=\"prettyprint linenums\">mongod&nbsp;-f&nbsp;mongod.conf</pre>",
                    "<pre class=\"prettyprint linenums\">mongod&nbsp;--conf&nbsp;mongod.conf</pre>",
                    "<pre class=\"prettyprint linenums\">mongod&nbsp;--use mongod.conf</pre>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "",
            "question_plain": "You have a configuration file for mongod instance called mongod.conf in your working directory. How can you launch mongod instance with this configuration file? (select 2)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168762,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>You have the following configuration file:</p><p><br></p><pre class=\"prettyprint linenums\">net:\n&nbsp;&nbsp;bindIp:&nbsp;localhost\n&nbsp;&nbsp;port:&nbsp;27000\nsecurity:\n&nbsp;&nbsp;authorization:&nbsp;enabled</pre><p><br></p><p>You have to edit this file to use new directory as the dbPath: <code>/var/mongodb/db</code>. Select the correct answer.</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>net</code> options:</p><p><br></p><pre class=\"prettyprint linenums\">net:\n&nbsp;&nbsp;&nbsp;port:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;bindIp:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;bindIpAll:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;maxIncomingConnections:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;wireObjectCheck:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;ipv6:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;unixDomainSocket:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enabled:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathPrefix:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filePermissions:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;tls:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;certificateSelector:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clusterCertificateSelector:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;certificateKeyFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;certificateKeyFilePassword:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clusterFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clusterPassword:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CAFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clusterCAFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CRLFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allowConnectionsWithoutCertificates:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allowInvalidCertificates:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allowInvalidHostnames:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disabledProtocols:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FIPSMode:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logVersions:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;compression:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compressors:&nbsp;&lt;string&gt;</pre><p><br></p><p><code>security</code> options:</p><p><br></p><pre class=\"prettyprint linenums\">security:\n&nbsp;&nbsp;&nbsp;keyFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;clusterAuthMode:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;authorization:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;transitionToAuth:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;javascriptEnabled:&nbsp;&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;redactClientLogData:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;clusterIpSourceAllowlist:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;sasl:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hostName:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serviceName:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saslauthdSocketPath:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;enableEncryption:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;encryptionCipherMode:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;encryptionKeyFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;kmip:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyIdentifier:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotateMasterKey:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverName:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientCertificateFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientCertificatePassword:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientCertificateSelector:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverCAFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connectRetries:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connectTimeoutMS:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;ldap:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servers:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bind:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saslMechanisms:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queryUser:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queryPassword:&nbsp;&lt;string&nbsp;|&nbsp;array&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useOSDefaults:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transportSecurity:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeoutMS:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userToDNMapping:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;authz:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queryTemplate:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validateLDAPServerConfig:&nbsp;&lt;boolean&gt;</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/configuration-options/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">storage:\n&nbsp;&nbsp;dbPath:&nbsp;/var/mongodb/db\nnet:\n&nbsp;&nbsp;bindIp:&nbsp;localhost\n&nbsp;&nbsp;port:&nbsp;27000\nsecurity:\n&nbsp;&nbsp;authorization:&nbsp;enabled</pre>",
                    "<pre class=\"prettyprint linenums\">storage:\n&nbsp;&nbsp;dbPath:&nbsp;/data/db\nnet:\n&nbsp;&nbsp;bindIp:&nbsp;localhost\n&nbsp;&nbsp;port:&nbsp;27000\nsecurity:\n&nbsp;&nbsp;authorization:&nbsp;enabled</pre>",
                    "<pre class=\"prettyprint linenums\">dbPath:\n&nbsp;&nbsp;storage:&nbsp;/var/mongodb/db\nnet:\n&nbsp;&nbsp;bindIp:&nbsp;localhost\n&nbsp;&nbsp;port:&nbsp;27000\nsecurity:\n&nbsp;&nbsp;authorization:&nbsp;enabled</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "You have the following configuration file:net:\n&nbsp;&nbsp;bindIp:&nbsp;localhost\n&nbsp;&nbsp;port:&nbsp;27000\nsecurity:\n&nbsp;&nbsp;authorization:&nbsp;enabledYou have to edit this file to use new directory as the dbPath: /var/mongodb/db. Select the correct answer.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168764,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>You have to create a simple configuration file for <code>mongod</code><em> </em>instance. </p><p><br></p><p>Here are the requirements of your <code>mongod</code><em> </em>instance:</p><p>* stores data files in <code>/var/mongo/db</code></p><p>* listens to connection from localhost</p><p>*&nbsp;runs on port 27000</p><p>* uses authentication</p><p><br></p><p>Which of the following configuration file meet these requirements?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>storage</code> options:</p><p><br></p><pre class=\"prettyprint linenums\">storage:\n&nbsp;&nbsp;&nbsp;dbPath:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;journal:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enabled:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commitIntervalMs:&nbsp;&lt;num&gt;\n&nbsp;&nbsp;&nbsp;directoryPerDB:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;syncPeriodSecs:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;engine:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;wiredTiger:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engineConfig:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cacheSizeGB:&nbsp;&lt;number&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;journalCompressor:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;directoryForIndexes:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxCacheOverflowFileSizeGB:&nbsp;&lt;number&gt;&nbsp;//&nbsp;deprecated&nbsp;in&nbsp;MongoDB&nbsp;4.4\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collectionConfig:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockCompressor:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexConfig:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefixCompression:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;inMemory:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engineConfig:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inMemorySizeGB:&nbsp;&lt;number&gt;\n&nbsp;&nbsp;&nbsp;oplogMinRetentionHours:&nbsp;&lt;double&gt;</pre><p><br></p><p><code>net</code> options:</p><p><br></p><pre class=\"prettyprint linenums\">net:\n&nbsp;&nbsp;&nbsp;port:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;bindIp:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;bindIpAll:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;maxIncomingConnections:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;wireObjectCheck:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;ipv6:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;unixDomainSocket:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enabled:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathPrefix:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filePermissions:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;tls:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;certificateSelector:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clusterCertificateSelector:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;certificateKeyFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;certificateKeyFilePassword:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clusterFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clusterPassword:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CAFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clusterCAFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CRLFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allowConnectionsWithoutCertificates:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allowInvalidCertificates:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allowInvalidHostnames:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disabledProtocols:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FIPSMode:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logVersions:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;compression:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compressors:&nbsp;&lt;string&gt;</pre><p><br></p><p><code>security</code> options:</p><p><br></p><pre class=\"prettyprint linenums\">security:\n&nbsp;&nbsp;&nbsp;keyFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;clusterAuthMode:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;authorization:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;transitionToAuth:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;javascriptEnabled:&nbsp;&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;redactClientLogData:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;clusterIpSourceAllowlist:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;sasl:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hostName:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serviceName:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saslauthdSocketPath:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;enableEncryption:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;encryptionCipherMode:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;encryptionKeyFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;kmip:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyIdentifier:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotateMasterKey:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverName:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientCertificateFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientCertificatePassword:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientCertificateSelector:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverCAFile:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connectRetries:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connectTimeoutMS:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;ldap:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servers:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bind:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saslMechanisms:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queryUser:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queryPassword:&nbsp;&lt;string&nbsp;|&nbsp;array&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useOSDefaults:&nbsp;&lt;boolean&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transportSecurity:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeoutMS:&nbsp;&lt;int&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userToDNMapping:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;authz:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queryTemplate:&nbsp;&lt;string&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validateLDAPServerConfig:&nbsp;&lt;boolean&gt;</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/configuration-options/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">storage:\n&nbsp;&nbsp;dbPath:&nbsp;/var/mongodb/db\nnet:\n&nbsp;&nbsp;bindIp:&nbsp;localhost\n&nbsp;&nbsp;port:&nbsp;27000\nsecurity:\n&nbsp;&nbsp;authorization:&nbsp;enabled</pre>",
                    "<pre class=\"prettyprint linenums\">net:\n&nbsp;&nbsp;bindIp:&nbsp;localhost\n&nbsp;&nbsp;port:&nbsp;27000\nsecurity:\n&nbsp;&nbsp;authorization:&nbsp;enabled</pre>",
                    "<pre class=\"prettyprint linenums\">storage:\n&nbsp;&nbsp;dbPath:&nbsp;/var/mongodb/db\nnet:\n&nbsp;&nbsp;bindIp:&nbsp;localhost\n&nbsp;&nbsp;port:&nbsp;27000</pre>",
                    "<pre class=\"prettyprint linenums\">storage:\n&nbsp;&nbsp;dbPath:&nbsp;/var/mongodb/db\nsecurity:\n&nbsp;&nbsp;authorization:&nbsp;enabled</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "You have to create a simple configuration file for mongod instance. Here are the requirements of your mongod instance:* stores data files in /var/mongo/db* listens to connection from localhost*&nbsp;runs on port 27000* uses authenticationWhich of the following configuration file meet these requirements?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168766,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Which of the following roles provides the same read-only privileges as <code>read</code><em> </em>role on all databases except <code>local</code> and <code>config</code>?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>readAnyDatabase</code> provides the same read-only privileges as <code>read</code> on all databases except <code>local</code> and <code>config</code>. The role also provides the <code>listDatabases</code> action on the cluster as a whole.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/built-in-roles/#mongodb-authrole-readAnyDatabase</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">readAnyDatabase</pre>",
                    "<pre class=\"prettyprint linenums\">readWriteAnyDatabase</pre>",
                    "<pre class=\"prettyprint linenums\">userAdminAnyDatabase</pre>",
                    "<pre class=\"prettyprint linenums\">userAdminAnyDatabase</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Which of the following roles provides the same read-only privileges as read role on all databases except local and config?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168768,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>You have the following config file:</p><p><br></p><pre class=\"prettyprint linenums\">storage:\n&nbsp;&nbsp;dbPath:&nbsp;/data/db\nsystemLog:\n&nbsp;&nbsp;destination:&nbsp;file\n&nbsp;&nbsp;path:&nbsp;/var/log/mongod.log\nnet:\n&nbsp;&nbsp;bindIp:&nbsp;localhost,192.168.168.62\nsecurity:\n&nbsp;&nbsp;keyFile:&nbsp;/var/pki/keyfile\nprocessManagement:\n&nbsp;&nbsp;fork:&nbsp;true</pre><p><br></p><p>Select all the directories that MongoDB must have access to.</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>https://docs.mongodb.com/manual/reference/configuration-options/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">/data/db</pre>",
                    "<pre class=\"prettyprint linenums\">/var/pki</pre>",
                    "<pre class=\"prettyprint linenums\">/var/log</pre>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "",
            "question_plain": "You have the following config file:storage:\n&nbsp;&nbsp;dbPath:&nbsp;/data/db\nsystemLog:\n&nbsp;&nbsp;destination:&nbsp;file\n&nbsp;&nbsp;path:&nbsp;/var/log/mongod.log\nnet:\n&nbsp;&nbsp;bindIp:&nbsp;localhost,192.168.168.62\nsecurity:\n&nbsp;&nbsp;keyFile:&nbsp;/var/pki/keyfile\nprocessManagement:\n&nbsp;&nbsp;fork:&nbsp;trueSelect all the directories that MongoDB must have access to.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168770,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Assign typical operational tasks to the Mongo Developer.</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>https://www.mongodb.com/docs/manual/reference/built-in-roles/#built-in-roles</p>",
                "answers": [
                    "<p>write data, read data</p>",
                    "<p>create user, create index</p>",
                    "<p>read data</p>",
                    "<p>grant any privilege to any user</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Assign typical operational tasks to the Mongo Developer.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168772,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>How to shutdown the server? (Mongo shell)</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>db.shutdownServer()</code><strong> </strong>shuts down the current <code>mongod</code> or <code>mongos</code> process cleanly and safely. You must issue the <code>db.shutdownServer()</code> operation against the <code>admin</code> database.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.shutdownServer/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">use&nbsp;admin\ndb.shutdownServer()</pre>",
                    "<pre class=\"prettyprint linenums\">use&nbsp;admin\ndb.shutdown()</pre>",
                    "<pre class=\"prettyprint linenums\">use&nbsp;admin\ndb.disconnect()</pre>",
                    "<pre class=\"prettyprint linenums\">use&nbsp;local\ndb.shutdownServer()</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "How to shutdown the server? (Mongo shell)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168774,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>What numeric type is a valid MongoDB BSON type?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>Int32</code> - If a number can be converted to a 32-bit integer, <code>mongosh</code> will store it as <code>Int32</code>. If not, <code>mongosh</code> defaults to storing the number as a <code>Double</code>. Numerical values that are stored as <code>Int32</code> in <code>mongosh</code> would have been stored by default as <code>Double</code> in the <code>mongo</code> shell.</p><p><br></p><p>https://www.mongodb.com/docs/mongodb-shell/reference/data-types/#int32</p>",
                "answers": [
                    "<p>Float</p>",
                    "<p>Number</p>",
                    "<p>BIGINT</p>",
                    "<p>32-bit integer (<code>Int32</code>)</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "",
            "question_plain": "What numeric type is a valid MongoDB BSON type?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168776,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>A collection has documents like the following:</p><p><br></p><pre class=\"prettyprint linenums\">&nbsp;{&nbsp;_id:&nbsp;1,&nbsp;name:&nbsp;'Oatmeal&nbsp;Fruit&nbsp;Cake&nbsp;with&nbsp;Gummy&nbsp;Bears&nbsp;',&nbsp;price:&nbsp;11)}\n&nbsp;{&nbsp;_id:&nbsp;2,&nbsp;name:&nbsp;'Cheesecake&nbsp;Trifle&nbsp;with&nbsp;Chocolate&nbsp;Sprinkles&nbsp;',&nbsp;price:&nbsp;14)}\n&nbsp;{&nbsp;_id:&nbsp;3,&nbsp;name:&nbsp;'Pistachio&nbsp;Brownie&nbsp;with&nbsp;Walnuts&nbsp;',&nbsp;price:&nbsp;5},\n&nbsp;{&nbsp;_id:&nbsp;4,&nbsp;name:&nbsp;'Strawberry&nbsp;Ice&nbsp;Cream&nbsp;Cake&nbsp;with&nbsp;Butterscotch&nbsp;Syrup&nbsp;',&nbsp;price:&nbsp;3)}</pre><p><br></p><p>How should the autocomplete index be defined to look for matches at the beginning of a word on the <code>name</code> field?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<pre class=\"prettyprint linenums\">{\n   \"mappings\":{\n      \"dynamic\":false,\n      \"fields\":{\n         \"name\":[\n            {\n               \"type\":\"autocomplete\",\n               \"tokenization\":\"regexCaptureGroup\"\n            }\n         ]\n      }\n   }\n}</pre><p><br></p><p>Incorrect. <code>\"regexCaptureGroup\"</code> tokenization does not look only at the beginning of a word.</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"mappings\":{\n      \"dynamic\":false,\n      \"fields\":{\n         \"name\":[\n            {\n               \"type\":\"autocomplete\",\n               \"tokenization\":\"nGram\"\n            }\n         ]\n      }\n   }\n}</pre><p><br></p><p>Incorrect. <code>\"nGram\"</code> tokenization does not look only at the beginning of a word.</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"mappings\":{\n      \"dynamic\":false,\n      \"fields\":{\n         \"name\":[\n            {\n               \"type\":\"autocomplete\",\n               \"tokenization\":\"matchNGram\"\n            }\n         }\n      ]\n   }\n}\n}</pre><p><br></p><p>Incorrect. <code>\"matchNGram\"</code> is not a valid tokenization algorithm.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">{\n   \"mappings\":{\n      \"dynamic\":false,\n      \"fields\":{\n         \"name\":[\n            {\n               \"type\":\"autocomplete\",\n               \"tokenization\":\"regexCaptureGroup\"\n            }\n         ]\n      }\n   }\n}</pre>",
                    "<pre class=\"prettyprint linenums\">{\n   \"mappings\":{\n      \"dynamic\":false,\n      \"fields\":{\n         \"name\":[\n            {\n               \"type\":\"autocomplete\",\n               \"tokenization\":\"edgeGram\"\n            }\n         ]\n      }\n   }\n}</pre>",
                    "<pre class=\"prettyprint linenums\">{\n   \"mappings\":{\n      \"dynamic\":false,\n      \"fields\":{\n         \"name\":[\n            {\n               \"type\":\"autocomplete\",\n               \"tokenization\":\"nGram\"\n            }\n         ]\n      }\n   }\n}</pre>",
                    "<pre class=\"prettyprint linenums\">{\n   \"mappings\":{\n      \"dynamic\":false,\n      \"fields\":{\n         \"name\":[\n            {\n               \"type\":\"autocomplete\",\n               \"tokenization\":\"matchNGram\"\n            }\n         }\n      ]\n   }\n}\n}</pre>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "",
            "question_plain": "A collection has documents like the following:&nbsp;{&nbsp;_id:&nbsp;1,&nbsp;name:&nbsp;'Oatmeal&nbsp;Fruit&nbsp;Cake&nbsp;with&nbsp;Gummy&nbsp;Bears&nbsp;',&nbsp;price:&nbsp;11)}\n&nbsp;{&nbsp;_id:&nbsp;2,&nbsp;name:&nbsp;'Cheesecake&nbsp;Trifle&nbsp;with&nbsp;Chocolate&nbsp;Sprinkles&nbsp;',&nbsp;price:&nbsp;14)}\n&nbsp;{&nbsp;_id:&nbsp;3,&nbsp;name:&nbsp;'Pistachio&nbsp;Brownie&nbsp;with&nbsp;Walnuts&nbsp;',&nbsp;price:&nbsp;5},\n&nbsp;{&nbsp;_id:&nbsp;4,&nbsp;name:&nbsp;'Strawberry&nbsp;Ice&nbsp;Cream&nbsp;Cake&nbsp;with&nbsp;Butterscotch&nbsp;Syrup&nbsp;',&nbsp;price:&nbsp;3)}How should the autocomplete index be defined to look for matches at the beginning of a word on the name field?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168778,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>What <code>mongosh</code> command shows how many indexes are associated with an inventory collection?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p><code>db.collection.getIndexes()</code> -&gt; Returns an array that holds a list of documents that identify and describe the existing indexes on the collection, including hidden indexes.</p><p><br></p><p><code>db.inventory.indexes()</code> -&gt;&nbsp;Incorrect. This command does not exist.</p><p><code>db.inventory.showIndexes()</code> -&gt; Incorrect. This command does not exist.</p><p><code>db.inventory.displayIndexes()</code> -&gt;&nbsp;Incorrect. This command does not exist.</p><p><br></p><p>https://www.mongodb.com/docs/manual/reference/method/db.collection.getIndexes/</p>",
                "answers": [
                    "<p><code>db.inventory.getIndexes()</code> </p>",
                    "<p><code>db.inventory.indexes()</code> </p>",
                    "<p><code>db.inventory.showIndexes()</code> </p>",
                    "<p><code>db.inventory.displayIndexes()</code> </p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "What mongosh command shows how many indexes are associated with an inventory collection?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168780,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>A typical products collection is in an e-commerce database. What schema is the most effective?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Orders for products should be embedded as an array in each product document. -&gt; Incorrect. Since there can be a huge number of orders, they should not be embedded.</p><p><br></p><p>Reviews for products should be embedded as an array in each product document. -&gt; Incorrect. Since there can be a huge number of reviews, they should not be embedded.</p><p><br></p><p>Current and historical prices for product should be embedded in each product document. -&gt;&nbsp;Incorrect. Since there can be a large number of historical prices, they should not be embedded (current price absolutely should be).</p><p><br></p><p>Current inventory/availability for product should be embedded in each product document. -&gt; Correct.</p>",
                "answers": [
                    "<p>Orders for products should be embedded as an array in each product document.</p>",
                    "<p>Reviews for products should be embedded as an array in each product document.</p>",
                    "<p>Current and historical prices for product should be embedded in each product document.</p>",
                    "<p>Current inventory/availability for product should be embedded in each product document. </p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "",
            "question_plain": "A typical products collection is in an e-commerce database. What schema is the most effective?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168782,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Consider a collection named <code>orders</code> with the following documents:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"order_id\" : 101,\n   \"customer_name\" : \"John Doe\",\n   \"order_date\" : ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"items\" : [\n      {\n         \"product_name\" : \"Apple\",\n         \"quantity\" : 2,\n         \"price\" : 0.99\n      },\n      {\n         \"product_name\" : \"Banana\",\n         \"quantity\" : 5,\n         \"price\" : 0.5\n      }\n   ]\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e2\"),\n   \"order_id\" : 102,\n   \"customer_name\" : \"Jane Doe\",\n   \"order_date\" : ISODate(\"2022-01-02T00:00:00.000Z\"),\n   \"items\" : [\n      {\n         \"product_name\" : \"Orange\",\n         \"quantity\" : 3,\n         \"price\" : 0.79\n      },\n      {\n         \"product_name\" : \"Mango\",\n         \"quantity\" : 2,\n         \"price\" : 1.99\n      }\n   ]\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e3\"),\n   \"order_id\" : 103,\n   \"customer_name\" : \"Bob Smith\",\n   \"order_date\" : ISODate(\"2022-01-03T00:00:00.000Z\"),\n   \"items\" : [\n      {\n         \"product_name\" : \"Peach\",\n         \"quantity\" : 4,\n         \"price\" : 1.49\n      },\n      {\n         \"product_name\" : \"Pear\",\n         \"quantity\" : 1,\n         \"price\" : 2.99\n      }\n   ]\n}</pre><p><br></p><p>What is the query to retrieve the total sales for each customer in the <code>orders</code> collection?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $unwind: \"$items\"\n   },\n   {\n      $group: {\n         _id: \"$customer_name\",\n         total_sales: { $sum: { $multiply: [\"$items.quantity\", \"$items.price\"] } }\n      }\n   }\n])</pre><p><br></p><p><code>$unwind</code> - deconstructs an array field from the input documents to output a document for <em>each</em> element. Each output document is the input document with the value of the array field replaced by the element.</p><p><code>$group</code> - the <code>$group</code> stage separates documents into groups according to a \"group key\". The output is one document for each unique group key. The <code>$group</code> stage has the following prototype form:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  $group:\n    {\n      _id: &lt;expression&gt;, // Group key\n      &lt;field1&gt;: { &lt;accumulator1&gt; : &lt;expression1&gt; },\n      ...\n    }\n }</pre><p><br></p><p>https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $unwind: \"$items\"\n   },\n   {\n      $group: {\n         _id: \"$customer_name\",\n         total_sales: { $sum: { $multiply: [\"$items.quantity\", \"$items.price\"] } }\n      }\n   }\n])\n</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $group: {\n         _id: \"$customer_name\",\n         total_sales: { $sum: { $multiply: [\"$items.quantity\", \"$items.price\"] } }\n      }\n   }\n])\n</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $unwind: \"$items\"\n   },\n   {\n      $group: {\n         _id: \"$customer_name\",\n         total_sales: { $sum: { $multiply: [\"quantity\", \"price\"] } }\n      }\n   }\n])\n</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $unwind: \"$items\"\n   },\n   {\n      $group: {\n         total_sales: { $sum: { $multiply: [\"$items.quantity\", \"$items.price\"] } }\n      }\n   }\n])\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Consider a collection named orders with the following documents:{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"order_id\" : 101,\n   \"customer_name\" : \"John Doe\",\n   \"order_date\" : ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"items\" : [\n      {\n         \"product_name\" : \"Apple\",\n         \"quantity\" : 2,\n         \"price\" : 0.99\n      },\n      {\n         \"product_name\" : \"Banana\",\n         \"quantity\" : 5,\n         \"price\" : 0.5\n      }\n   ]\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e2\"),\n   \"order_id\" : 102,\n   \"customer_name\" : \"Jane Doe\",\n   \"order_date\" : ISODate(\"2022-01-02T00:00:00.000Z\"),\n   \"items\" : [\n      {\n         \"product_name\" : \"Orange\",\n         \"quantity\" : 3,\n         \"price\" : 0.79\n      },\n      {\n         \"product_name\" : \"Mango\",\n         \"quantity\" : 2,\n         \"price\" : 1.99\n      }\n   ]\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e3\"),\n   \"order_id\" : 103,\n   \"customer_name\" : \"Bob Smith\",\n   \"order_date\" : ISODate(\"2022-01-03T00:00:00.000Z\"),\n   \"items\" : [\n      {\n         \"product_name\" : \"Peach\",\n         \"quantity\" : 4,\n         \"price\" : 1.49\n      },\n      {\n         \"product_name\" : \"Pear\",\n         \"quantity\" : 1,\n         \"price\" : 2.99\n      }\n   ]\n}What is the query to retrieve the total sales for each customer in the orders collection?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168784,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Consider a collection named <code>students</code><em> </em>with the following document:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"name\" : \"Alice\",\n   \"age\" : 21,\n   \"courses\" : [\n      {\n         \"name\" : \"Math\",\n         \"grade\" : 89\n      },\n      {\n         \"name\" : \"Science\",\n         \"grade\" : 92\n      }\n   ]\n}</pre><p><br></p><p>What is the query to update the grade of the <code>\"Math\"</code> course for the student with <code>\"_id\"</code> equal to <code>ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\")</code> to <code>95</code>?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.students.updateOne(\n   { _id: ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"), \"courses.name\": \"Math\" },\n   { $set: { \"courses.$.grade\": 95 } }\n)</pre><p><br></p><p><code>db.collection.updateOne(filter, update, options)</code> - Udates a single document within the collection based on the filter. The <code>updateOne()</code> method has the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">db.collection.updateOne(\n   &lt;filter&gt;,\n   &lt;update&gt;,\n   {\n     upsert: &lt;boolean&gt;,\n     writeConcern: &lt;document&gt;,\n     collation: &lt;document&gt;,\n     arrayFilters: [ &lt;filterdocument1&gt;, ... ],\n     hint:  &lt;document|string&gt;        // Available starting in MongoDB 4.2.1\n   }\n)</pre><p><br></p><p>https://www.mongodb.com/docs/manual/reference/method/db.collection.updateOne/</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.students.updateOne(\n   { _id: ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"), \"courses.name\": \"Math\" },\n   { $set: { \"courses.$.grade\": 95 } }\n)</pre>",
                    "<pre class=\"prettyprint linenums\">db.students.updateOne(\n   { _id: ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\") },\n   { $set: { \"courses.$.grade\": 95 } }\n)</pre>",
                    "<pre class=\"prettyprint linenums\">db.students.updateOne(\n   { _id: ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"), \"courses.name\": \"Math\" },\n   { $set: { \"grade\": 95 } }\n)</pre>",
                    "<pre class=\"prettyprint linenums\">db.students.updateOne(\n   { \"courses.name\": \"Math\" },\n   { $set: { \"courses.$.grade\": 95 } }\n)</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Consider a collection named students with the following document:{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"name\" : \"Alice\",\n   \"age\" : 21,\n   \"courses\" : [\n      {\n         \"name\" : \"Math\",\n         \"grade\" : 89\n      },\n      {\n         \"name\" : \"Science\",\n         \"grade\" : 92\n      }\n   ]\n}What is the query to update the grade of the \"Math\" course for the student with \"_id\" equal to ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\") to 95?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168786,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Consider the following MongoDB collection <code>orders</code>:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\": 1,\n   \"customer_name\": \"John Doe\",\n   \"order_date\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"total_amount\": 100\n},\n{\n   \"_id\": 2,\n   \"customer_name\": \"Jane Doe\",\n   \"order_date\": ISODate(\"2022-02-01T00:00:00.000Z\"),\n   \"total_amount\": 200\n},\n{\n   \"_id\": 3,\n   \"customer_name\": \"Jim Smith\",\n   \"order_date\": ISODate(\"2022-03-01T00:00:00.000Z\"),\n   \"total_amount\": 300\n}</pre><p><br></p><p>What is the query to find the total amount of orders made in the month of February 2022?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.aggregate([\n  {\n    $match: {\n      order_date: {\n        $gte: ISODate(\"2022-02-01T00:00:00.000Z\"),\n        $lt: ISODate(\"2022-03-01T00:00:00.000Z\")\n      }\n    }\n  },\n  { $group: { _id: null, total_amount: { $sum: \"$total_amount\" } } }\n])</pre>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.orders.find({\n    order_date: {\n      $gte: ISODate(\"2022-02-01T00:00:00.000Z\"),\n      $lt: ISODate(\"2022-03-01T00:00:00.000Z\")\n    }\n  }).sum(\"total_amount\")</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n  {\n    $match: {\n      order_date: {\n        $gte: ISODate(\"2022-02-01T00:00:00.000Z\"),\n        $lt: ISODate(\"2022-03-01T00:00:00.000Z\")\n      }\n    }\n  },\n  { $group: { _id: null, total_amount: { $sum: \"$total_amount\" } } }\n])</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.find({ order_date: { $eq: ISODate(\"2022-02-01T00:00:00.000Z\") } }).sum(\"total_amount\")</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n  { $match: { order_date: { $eq: ISODate(\"2022-02-01T00:00:00.000Z\") } } },\n  { $group: { _id: \"$order_date\", total_amount: { $sum: \"$total_amount\" } } }\n])</pre>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "",
            "question_plain": "Consider the following MongoDB collection orders:{\n   \"_id\": 1,\n   \"customer_name\": \"John Doe\",\n   \"order_date\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"total_amount\": 100\n},\n{\n   \"_id\": 2,\n   \"customer_name\": \"Jane Doe\",\n   \"order_date\": ISODate(\"2022-02-01T00:00:00.000Z\"),\n   \"total_amount\": 200\n},\n{\n   \"_id\": 3,\n   \"customer_name\": \"Jim Smith\",\n   \"order_date\": ISODate(\"2022-03-01T00:00:00.000Z\"),\n   \"total_amount\": 300\n}What is the query to find the total amount of orders made in the month of February 2022?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168788,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Consider a MongoDB database containing a collection of documents representing online orders for an e-commerce website. The documents have the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\": ObjectId(\"5f95a1d11a12b400001b75c0\"),\n   \"order_number\": \"ORD-001\",\n   \"order_date\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"customer\": {\n      \"name\": \"John Doe\",\n      \"email\": \"johndoe@example.com\"\n   },\n   \"items\": [\n      { \"product_name\": \"Smartphone\", \"quantity\": 2, \"price\": 800 },\n      { \"product_name\": \"Laptop\", \"quantity\": 1, \"price\": 1500 }\n   ],\n   \"shipping_address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"New York\",\n      \"state\": \"NY\",\n      \"zipcode\": \"10001\"\n   },\n   \"total_amount\": 3000\n}</pre><p><br></p><p>Select an aggregation pipeline that returns the total sales amount by state and month, for orders placed in the year 2022. The result should have the following format:</p><p><br></p><pre class=\"prettyprint linenums\">{ \"state\": \"NY\", \"month\": 1, \"sales_amount\": 3000 }</pre><p><br></p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Correct pipeline:</p><p><br></p><pre class=\"prettyprint linenums\">[\n   {\n      \"$match\": {\n         \"order_date\": {\n            \"$gte\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n            \"$lt\": ISODate(\"2023-01-01T00:00:00.000Z\")\n         }\n      }\n   },\n   {\n      \"$group\": {\n         \"_id\": { \"state\": \"$shipping_address.state\", \"month\": { \"$month\": \"$order_date\" } },\n         \"sales_amount\": { \"$sum\": \"$total_amount\" }\n      }\n   },\n   {\n      \"$project\": {\n         \"state\": \"$_id.state\",\n         \"month\": \"$_id.month\",\n         \"sales_amount\": \"$sales_amount\",\n         \"_id\": 0\n      }\n   }\n]</pre><p><br></p><ol><li><p>The first stage of the pipeline <code><strong>$match</strong></code>es only the orders placed in the year 2022 by checking if the <code><strong>order_date</strong></code> is greater than or equal to <code><strong>ISODate(\"2022-01-01T00:00:00.000Z\")</strong></code> and less than <code><strong>ISODate(\"2023-01-01T00:00:00.000Z\")</strong></code>.</p></li><li><p>The second stage <code><strong>$group</strong></code>s the documents by state and month using the <code><strong>$group</strong></code> operator on the <code><strong>shipping_address.state</strong></code> field and the <code><strong>$month</strong></code> operator on the <code><strong>order_date</strong></code> field, and calculates the total sales amount using the <code><strong>$sum</strong></code> operator on the <code><strong>total_amount</strong></code> field.</p></li><li><p>The final stage <code><strong>$project</strong></code>s the final output format, including only the <code><strong>state</strong></code>, <code><strong>month</strong></code>, and <code><strong>sales_amount</strong></code> fields, and omitting the <code><strong>_id</strong></code> field.</p></li></ol>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">[\n   {\n      \"$match\": {\n         \"order_date\": {\n            \"$gte\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n            \"$lt\": ISODate(\"2023-01-01T00:00:00.000Z\")\n         }\n      }\n   },\n   {\n      \"$group\": {\n         \"_id\": { \"state\": \"$shipping_address.state\", \"month\": { \"$month\": \"$order_date\" } },\n         \"sales_amount\": { \"$sum\": \"$total_amount\" }\n      }\n   },\n   {\n      \"$project\": {\n         \"state\": \"$_id.state\",\n         \"month\": \"$_id.month\",\n         \"sales_amount\": \"$sales_amount\",\n         \"_id\": 0\n      }\n   }\n]</pre>",
                    "<pre class=\"prettyprint linenums\">[\n   {\n      \"$group\": {\n         \"_id\": { \"state\": \"$shipping_address.state\", \"month\": { \"$month\": \"$order_date\" } },\n         \"sales_amount\": { \"$sum\": \"$total_amount\" }\n      }\n   },\n   {\n      \"$project\": {\n         \"state\": \"$_id.state\",\n         \"month\": \"$_id.month\",\n         \"sales_amount\": \"$sales_amount\",\n         \"_id\": 0\n      }\n   }\n]</pre>",
                    "<pre class=\"prettyprint linenums\">[\n   {\n      \"$match\": {\n         \"order_date\": {\n            \"$gte\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n            \"$lt\": ISODate(\"2023-01-01T00:00:00.000Z\")\n         }\n      }\n   },\n   {\n      \"$project\": {\n         \"state\": \"$_id.state\",\n         \"month\": \"$_id.month\",\n         \"sales_amount\": \"$sales_amount\",\n         \"_id\": 0\n      }\n   }\n]</pre>",
                    "<pre class=\"prettyprint linenums\">[\n   {\n      \"$match\": {\n         \"order_date\": {\n            \"$gte\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n            \"$lt\": ISODate(\"2023-01-01T00:00:00.000Z\")\n         }\n      }\n   },\n   {\n      \"$group\": {\n         \"sales_amount\": { \"$sum\": \"$total_amount\" }\n      }\n   },\n   {\n      \"$project\": {\n         \"state\": \"$_id.state\",\n         \"month\": \"$_id.month\",\n         \"sales_amount\": \"$sales_amount\",\n         \"_id\": 0\n      }\n   }\n]</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Consider a MongoDB database containing a collection of documents representing online orders for an e-commerce website. The documents have the following structure:{\n   \"_id\": ObjectId(\"5f95a1d11a12b400001b75c0\"),\n   \"order_number\": \"ORD-001\",\n   \"order_date\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"customer\": {\n      \"name\": \"John Doe\",\n      \"email\": \"johndoe@example.com\"\n   },\n   \"items\": [\n      { \"product_name\": \"Smartphone\", \"quantity\": 2, \"price\": 800 },\n      { \"product_name\": \"Laptop\", \"quantity\": 1, \"price\": 1500 }\n   ],\n   \"shipping_address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"New York\",\n      \"state\": \"NY\",\n      \"zipcode\": \"10001\"\n   },\n   \"total_amount\": 3000\n}Select an aggregation pipeline that returns the total sales amount by state and month, for orders placed in the year 2022. The result should have the following format:{ \"state\": \"NY\", \"month\": 1, \"sales_amount\": 3000 }",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168790,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Consider a MongoDB database containing a collection of documents representing employee records for a company. The documents have the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\": ObjectId(\"5f95a1d11a12b400001b75c0\"),\n   \"employee_id\": \"EMP-001\",\n   \"name\": {\n      \"first\": \"John\",\n      \"last\": \"Doe\"\n   },\n   \"department\": \"Sales\",\n   \"hire_date\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"salary\": 65000,\n   \"performance_rating\": 4\n}</pre><p><br></p><p>You are frequently running the following query to find all employees with a specific department, performance rating and a salary greater than a certain amount:</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.find({\n   \"department\": \"Sales\",\n   \"performance_rating\": 4,\n   \"salary\": {\n      \"$gt\": 65000\n   }\n})</pre><p><br></p><p>What index would you create to improve the performance of this query?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>You should create a compound index on the <code><strong>department</strong></code>, <code><strong>performance_rating</strong></code>, and <code><strong>salary</strong></code> fields. -&gt; Correct.</p><p><br></p><p>The query you are running performs a query on three fields, <code><strong>department</strong></code>, <code><strong>performance_rating</strong></code>, and <code><strong>salary</strong></code>, and a compound index on these fields will improve the query performance. A compound index is an index that includes multiple fields in the index key, allowing the index to support queries that filter or sort data based on multiple fields.</p><p>In this case, a compound index on the <code><strong>department</strong></code>, <code><strong>performance_rating</strong></code>, and <code><strong>salary</strong></code> fields will allow the MongoDB query planner to use the index to quickly filter the documents based on the department, performance rating, and salary criteria, reducing the amount of data that needs to be scanned and improving the query performance. The index order is also important, as MongoDB will use the left-most prefix of the index in order, so the order of the fields in the compound index should match the order of the fields in the query conditions for optimal performance.</p>",
                "answers": [
                    "<p>You should create a compound index on the <code><strong>department</strong></code>, <code><strong>performance_rating</strong></code>, and <code><strong>salary</strong></code> fields.</p>",
                    "<p>You should create an index on the <code><strong>department</strong></code>&nbsp; field.</p>",
                    "<p>You should create a compound index on the <code><strong>salary</strong></code>, <code><strong>performance_rating</strong></code>, and <code><strong>department</strong></code><strong> </strong>fields.</p>",
                    "<p>This query could not be optimized.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Consider a MongoDB database containing a collection of documents representing employee records for a company. The documents have the following structure:{\n   \"_id\": ObjectId(\"5f95a1d11a12b400001b75c0\"),\n   \"employee_id\": \"EMP-001\",\n   \"name\": {\n      \"first\": \"John\",\n      \"last\": \"Doe\"\n   },\n   \"department\": \"Sales\",\n   \"hire_date\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"salary\": 65000,\n   \"performance_rating\": 4\n}You are frequently running the following query to find all employees with a specific department, performance rating and a salary greater than a certain amount:db.employees.find({\n   \"department\": \"Sales\",\n   \"performance_rating\": 4,\n   \"salary\": {\n      \"$gt\": 65000\n   }\n})What index would you create to improve the performance of this query?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168792,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Consider a MongoDB database containing a collection of documents representing customer orders for an online store. The documents have the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\": ObjectId(\"5f95a1d11a12b400001b75c0\"),\n   \"order_id\": \"ORD-001\",\n   \"customer_id\": \"CUS-001\",\n   \"date\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"total_amount\": 200,\n   \"status\": \"pending\"\n}</pre><p><br></p><p>You are frequently running the following query to find all customer orders with a specific status and total amount greater than a certain amount:</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.find({\n   \"status\": \"pending\",\n   \"total_amount\": {\n      \"$gt\": 150\n   }\n})</pre><p><br></p><p>What index would you create to improve the performance of this query?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>You should create a compound index on the <code><strong>status</strong></code> and <code><strong>total_amount</strong></code> fields. -&gt; Correct.</p><p>The query you are running performs a query on two fields, <code><strong>status</strong></code> and <code><strong>total_amount</strong></code>, and a compound index on these fields will improve the query performance. A compound index is an index that includes multiple fields in the index key, allowing the index to support queries that filter or sort data based on multiple fields.</p><p>In this case, a compound index on the <code><strong>status</strong></code> and <code><strong>total_amount</strong></code> fields will allow the MongoDB query planner to use the index to quickly filter the documents based on the status and total amount criteria, reducing the amount of data that needs to be scanned and improving the query performance. The index order is also important, as MongoDB will use the left-most prefix of the index in order, so the order of the fields in the compound index should match the order of the fields in the query conditions for optimal performance.</p>",
                "answers": [
                    "<p>You should create a compound index on the <code><strong>status</strong></code> and <code><strong>total_amount</strong></code> fields.</p>",
                    "<p>You should create an index on the <code><strong>status</strong></code> field.</p>",
                    "<p>You should create an index on the <code><strong>_id</strong></code><strong> </strong>field.</p>",
                    "<p>You should create a compound index on the <code><strong>total_amount</strong></code> and <code><strong>status</strong></code> fields.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Consider a MongoDB database containing a collection of documents representing customer orders for an online store. The documents have the following structure:{\n   \"_id\": ObjectId(\"5f95a1d11a12b400001b75c0\"),\n   \"order_id\": \"ORD-001\",\n   \"customer_id\": \"CUS-001\",\n   \"date\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"total_amount\": 200,\n   \"status\": \"pending\"\n}You are frequently running the following query to find all customer orders with a specific status and total amount greater than a certain amount:db.orders.find({\n   \"status\": \"pending\",\n   \"total_amount\": {\n      \"$gt\": 150\n   }\n})What index would you create to improve the performance of this query?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168794,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>In MongoDB, what is the difference between sharding and replication?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Sharding is a process of distributing data across multiple machines while replication is the process of maintaining multiple copies of the same data on different machines. -&gt;&nbsp;Correct.</p><p>Sharding and replication are two different techniques in MongoDB used to scale a database. Sharding involves distributing data across multiple machines in a way that balances the load, while replication involves maintaining multiple copies of the same data on different machines, ensuring that if one machine goes down, there will be a backup available to keep the data accessible. This makes sharding useful for improving the performance of read-heavy workloads, while replication is useful for ensuring high availability and durability of data.</p>",
                "answers": [
                    "<p>Sharding is a process of distributing data across multiple machines while replication is the process of maintaining multiple copies of the same data on different machines.</p>",
                    "<p>Sharding is the process of maintaining multiple copies of the same data on different machines while replication is the process of distributing data across multiple machines.</p>",
                    "<p>Sharding is the process of creating multiple backups of a database while replication is the process of dividing a large collection into smaller parts.</p>",
                    "<p>Sharding is a process of merging small collections into larger parts while replication is the process of making multiple database backups.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "In MongoDB, what is the difference between sharding and replication?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168796,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>What is the role of the <code>oplog</code> in MongoDB Replica Sets?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>It is a capped collection that stores all write operations performed on the primary node, allowing secondaries to stay up-to-date with the primary. -&gt; Correct.</p><p>The <code>oplog</code> (operations log) in MongoDB Replica Sets is a capped collection that stores all write operations performed on the primary node. The secondaries in a replica set periodically query the <code>oplog</code> and apply any operations they have not yet applied, allowing them to stay up-to-date with the primary. This enables the secondaries to serve read operations and provide automatic failover in the event of a primary node failure, ensuring high availability and durability of the data in a MongoDB replica set. The <code>oplog</code> is a critical component of MongoDB's replication mechanism, allowing for real-time data synchronization across multiple nodes in a replica set.</p><p><br></p><p>https://www.mongodb.com/docs/manual/core/replica-set-oplog/</p>",
                "answers": [
                    "<p>It is a capped collection that stores all write operations performed on the primary node, allowing secondaries to stay up-to-date with the primary.</p>",
                    "<p>It is a mechanism for automatically promoting a secondary node to be the new primary in the event of a primary node failure.</p>",
                    "<p>It is a process that performs regular backups of the data in a replica set to ensure data durability and protection against data loss.</p>",
                    "<p>It is a calculated value used to ensure data integrity. The md5 algorithm is sometimes used as a <code>oplog</code>.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "What is the role of the oplog in MongoDB Replica Sets?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168798,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Consider two collections in MongoDB, <code>employees</code> and <code>salaries</code>, where <code>employees</code> contains information about employees and <code>salaries</code> contains information about their salaries. The <code>salaries</code> collection contains documents with the following format:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  \"_id\": ObjectId(\"5e86d5f0116cf7c0c1e2b75f\"),\n  \"employee_id\": \"123456\",\n  \"salary\": 50000,\n  \"year\": 2020\n}</pre><p><br></p><p>What would be the correct <code>$lookup</code> pipeline stage to join the <code>employees</code> collection with the <code>salaries</code> collection based on the <code>\"employee_id\"</code> field and sum up the salaries for each employee for the year 2021?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>In this scenario, the correct <code>$lookup</code> pipeline stage would be:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"$lookup\":{\n      \"from\":\"salaries\",\n      \"localField\":\"employee_id\",\n      \"foreignField\":\"employee_id\",\n      \"as\":\"employee_salaries\"\n   }\n},\n{\n   \"$match\":{\n      \"employee_salaries.year\":2021\n   }\n},\n{\n   \"$group\":{\n      \"_id\":\"$employee_id\",\n      \"total_salary\":{\n         \"$sum\":\"$employee_salaries.salary\"\n      }\n   }\n}</pre>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">{\n   \"$lookup\":{\n      \"from\":\"salaries\",\n      \"localField\":\"employee_id\",\n      \"foreignField\":\"employee_id\",\n      \"as\":\"employee_salaries\"\n   }\n},\n{\n   \"$match\":{\n      \"employee_salaries.year\":2021\n   }\n},\n{\n   \"$group\":{\n      \"_id\":\"$employee_id\",\n      \"total_salary\":{\n         \"$sum\":\"$employee_salaries.salary\"\n      }\n   }\n}</pre>",
                    "<pre class=\"prettyprint linenums\">{\n   \"$lookup\":{\n      \"from\":\"employees\",\n      \"localField\":\"employee_id\",\n      \"foreignField\":\"employee_id\",\n      \"as\":\"employee_salaries\"\n   }\n},\n{\n   \"$match\":{\n      \"employee_salaries.year\":2021\n   }\n},\n{\n   \"$group\":{\n      \"_id\":\"$employee_id\",\n      \"total_salary\":{\n         \"$sum\":\"$employee_salaries.salary\"\n      }\n   }\n}</pre>",
                    "<pre class=\"prettyprint linenums\">{\n   \"$lookup\":{\n      \"from\":\"salaries\",\n      \"localField\":\"employee_id\",\n      \"foreignField\":\"employee_id\",\n      \"as\":\"employee_salaries\"\n   }\n},\n{\n   \"$group\":{\n      \"_id\":\"$employee_id\",\n      \"total_salary\":{\n         \"$sum\":\"$employee_salaries.salary\"\n      }\n   }\n}</pre>",
                    "<pre class=\"prettyprint linenums\">{\n   \"$lookup\":{\n      \"from\":\"employees\",\n      \"localField\":\"_id\",\n      \"foreignField\":\"employee_id\",\n      \"as\":\"employee_salaries\"\n   }\n},\n{\n   \"$match\":{\n      \"employee_salaries.year\":2021\n   }\n},\n{\n   \"$group\":{\n      \"_id\":\"$_id\",\n      \"total_salary\":{\n         \"$sum\":\"$employee_salaries.salary\"\n      }\n   }\n}</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Consider two collections in MongoDB, employees and salaries, where employees contains information about employees and salaries contains information about their salaries. The salaries collection contains documents with the following format:{\n  \"_id\": ObjectId(\"5e86d5f0116cf7c0c1e2b75f\"),\n  \"employee_id\": \"123456\",\n  \"salary\": 50000,\n  \"year\": 2020\n}What would be the correct $lookup pipeline stage to join the employees collection with the salaries collection based on the \"employee_id\" field and sum up the salaries for each employee for the year 2021?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168800,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>We have the following indexes in a <code>movies</code><em> </em>collection:</p><p><br></p><pre class=\"prettyprint linenums\">{&nbsp;_id:&nbsp;1&nbsp;}\n{&nbsp;title:&nbsp;1,&nbsp;year:&nbsp;1&nbsp;}</pre><p><br></p><p>Which of the following queries can be covered by one of the given indexes?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>A covered query is a query that can be satisfied entirely using an index and does not have to examine any documents. An index covers a query when all of the following apply:</p><ul><li><p>all the fields in the query are part of an index, <strong>and</strong></p></li><li><p>all the fields returned in the results are in the same index.</p></li><li><p>no fields in the query are equal to <code>null</code> (i.e. {<code>\"field\" : null</code>} or {<code>\"field\" : {$eq : null}}</code> ).</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">db.movies.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;title:&nbsp;{&nbsp;$in:&nbsp;[&nbsp;\"Death&nbsp;Note\",&nbsp;\"The&nbsp;Immigrant\"&nbsp;]&nbsp;}&nbsp;},&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;_id:&nbsp;0,&nbsp;title:&nbsp;1,&nbsp;year:&nbsp;1, genres: 1&nbsp;}\n)</pre><p><br></p><p>No, this query would use the <code>{&nbsp;title:&nbsp;1,&nbsp;year:&nbsp;1&nbsp;}</code> index, but it is projecting the <code>genres</code> field.</p><p><br></p><p>https://docs.mongodb.com/manual/core/query-optimization/#covered-query</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.movies.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;title:&nbsp;{&nbsp;$in:&nbsp;[&nbsp;\"Death&nbsp;Note\",&nbsp;\"The&nbsp;Immigrant\"&nbsp;]&nbsp;}&nbsp;},&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;_id:&nbsp;0,&nbsp;title:&nbsp;1,&nbsp;year:&nbsp;1&nbsp;}\n)</pre>",
                    "<pre class=\"prettyprint linenums\">db.movies.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;title:&nbsp;{&nbsp;$in:&nbsp;[&nbsp;\"Death&nbsp;Note\",&nbsp;\"The&nbsp;Immigrant\"&nbsp;]&nbsp;}&nbsp;},&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;_id:&nbsp;0,&nbsp;title:&nbsp;1,&nbsp;year:&nbsp;1, genres: 1&nbsp;}\n)</pre>",
                    "<pre class=\"prettyprint linenums\">db.movies.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{ genres:&nbsp;\"Crime\" },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;_id:&nbsp;0,&nbsp;title:&nbsp;1,&nbsp;year:&nbsp;1, genres: 1&nbsp;}\n)</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "We have the following indexes in a movies collection:{&nbsp;_id:&nbsp;1&nbsp;}\n{&nbsp;title:&nbsp;1,&nbsp;year:&nbsp;1&nbsp;}Which of the following queries can be covered by one of the given indexes?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168802,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Consider a MongoDB collection named <code>orders</code> with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    \"_id\" : ObjectId(\"5f7f39d8dbdfgbcabcabcabc\"),\n    \"order_id\" : \"O001\",\n    \"customer_id\" : \"C001\",\n    \"order_date\" : ISODate(\"2022-12-01T00:00:00Z\"),\n    \"product_id\" : \"P001\",\n    \"quantity\" : 5,\n    \"price\" : 100\n}</pre><p><br></p><p>You are required to find the total quantity of each product sold between the dates <code><strong>2022-11-01</strong></code> and <code><strong>2022-12-31</strong></code>, and sort the results in descending order based on the total quantity sold. Which of the following queries would perform the most efficient collection scan?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Correct answer:</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.aggregate([\n    { $match: { order_date: { $gte: new Date(\"2022-11-01\"), $lt: new Date(\"2022-12-31\") } } },\n    { $group: { _id: \"$product_id\", total_quantity: { $sum: \"$quantity\" } } },\n    { $sort: { total_quantity: -1 } }\n]);</pre><p><br></p><p>This option performs a collection scan, matches the specified date range, groups the results by product_id, sums the quantity for each product_id, and sorts the results in descending order, which is the most efficient way to perform the calculation.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.orders.find({\n    order_date: { $gte: new Date(\"2022-11-01\"), $lt: new Date(\"2022-12-31\") }\n}).forEach(function(doc) {\n    // process the documents\n});</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n    { $match: { order_date: { $gte: new Date(\"2022-11-01\"), $lt: new Date(\"2022-12-31\") } } },\n    { $group: { _id: \"$product_id\", total_quantity: { $sum: \"$quantity\" } } },\n    { $sort: { total_quantity: -1 } }\n]);</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n    { $group: { _id: \"$product_id\", total_quantity: { $sum: \"$quantity\" } } },\n    { $sort: { total_quantity: -1 } },\n    { $match: { order_date: { $gte: new Date(\"2022-11-01\"), $lt: new Date(\"2022-12-31\") } } }\n]);</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n    { $group: { _id: \"$product_id\", total_quantity: { $sum: \"$quantity\" } } },\n    { $sort: { total_quantity: -1 } },\n    { $project: { _id: 0, product_id: \"$_id\", total_quantity: 1 } },\n    { $match: { order_date: { $gte: new Date(\"2022-11-01\"), $lt: new Date(\"2022-12-31\") } } }\n]);</pre>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "",
            "question_plain": "Consider a MongoDB collection named orders with the following document structure:{\n    \"_id\" : ObjectId(\"5f7f39d8dbdfgbcabcabcabc\"),\n    \"order_id\" : \"O001\",\n    \"customer_id\" : \"C001\",\n    \"order_date\" : ISODate(\"2022-12-01T00:00:00Z\"),\n    \"product_id\" : \"P001\",\n    \"quantity\" : 5,\n    \"price\" : 100\n}You are required to find the total quantity of each product sold between the dates 2022-11-01 and 2022-12-31, and sort the results in descending order based on the total quantity sold. Which of the following queries would perform the most efficient collection scan?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168804,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Consider a collection named <code>sales</code> that contains documents in the following format:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\" : ObjectId(\"5f5f95aae2e85f9e7b33be5a\"),\n   \"product_id\" : \"P001\",\n   \"sale_date\" : ISODate(\"2022-05-01T08:00:00Z\"),\n   \"quantity_sold\" : 10,\n   \"total_revenue\" : 100\n}</pre><p><br></p><p>How can you calculate the total quantity sold and total revenue for each month and return only the months with a total revenue greater than $50,000 using the MongoDB aggregation framework?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Correct answer:</p><p><br></p><pre class=\"prettyprint linenums\">db.sales.aggregate([\n  {\n    $group: {\n      _id: { month: { $month: \"$sale_date\" }, year: { $year: \"$sale_date\" } },\n      totalQty: { $sum: \"$quantity_sold\" },\n      totalRevenue: { $sum: \"$total_revenue\" }\n    }\n  },\n  { $match: { totalRevenue: { $gt: 50000 } } }\n])</pre><p><br></p><p>The correct pipeline first groups the documents by the month and year of the <code>\"sale_date\"</code> field, and calculates the total quantity sold and total revenue for each month. It then filters the result set to only include months with a total revenue greater than $50,000 using the <code>$match</code> stage. </p><p><br></p><pre class=\"prettyprint linenums\">db.sales.aggregate([\n  {\n    $group: {\n      _id: { month: { $month: \"$sale_date\" }, year: { $year: \"$sale_date\" } },\n      totalRevenue: { $sum: \"$total_revenue\" },\n      totalQty: { $sum: \"$quantity_sold\" }\n    }\n  },\n  { $match: { totalRevenue: { $gt: 50000 } } }\n])</pre><p><br></p><p>This option has the order of the calculated fields switched, but it is still a valid solution. </p><p><br></p><pre class=\"prettyprint linenums\">db.sales.aggregate([\n  {\n    $group: {\n      _id: { month: { $month: \"$sale_date\" } },\n      totalQty: { $sum: \"$quantity_sold\" },\n      totalRevenue: { $sum: \"$total_revenue\" }\n    }\n  },\n  { $match: { totalRevenue: { $gt: 50000 } } }\n])</pre><p><br></p><p>This option only groups the documents by the month of the <code>\"sale_date\"</code> field, which would not provide a complete aggregation result. </p><p><br></p><pre class=\"prettyprint linenums\">db.sales.aggregate([\n  {\n    $group: {\n      _id: { year: { $year: \"$sale_date\" } },\n      totalQty: { $sum: \"$quantity_sold\" },\n      totalRevenue: { $sum: \"$total_revenue\" }\n    }\n  },\n  { $match: { totalRevenue: { $gt: 50000 } } }\n])</pre><p><br></p><p>This option only groups the documents by the year of the <code>\"sale_date\"</code> field, which would not provide a granular enough aggregation result.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.sales.aggregate([\n  {\n    $group: {\n      _id: { month: { $month: \"$sale_date\" }, year: { $year: \"$sale_date\" } },\n      totalQty: { $sum: \"$quantity_sold\" },\n      totalRevenue: { $sum: \"$total_revenue\" }\n    }\n  },\n  { $match: { totalRevenue: { $gt: 50000 } } }\n])</pre>",
                    "<pre class=\"prettyprint linenums\">db.sales.aggregate([\n  {\n    $group: {\n      _id: { month: { $month: \"$sale_date\" }, year: { $year: \"$sale_date\" } },\n      totalRevenue: { $sum: \"$total_revenue\" },\n      totalQty: { $sum: \"$quantity_sold\" }\n    }\n  },\n  { $match: { totalRevenue: { $gt: 50000 } } }\n])</pre>",
                    "<pre class=\"prettyprint linenums\">db.sales.aggregate([\n  {\n    $group: {\n      _id: { month: { $month: \"$sale_date\" } },\n      totalQty: { $sum: \"$quantity_sold\" },\n      totalRevenue: { $sum: \"$total_revenue\" }\n    }\n  },\n  { $match: { totalRevenue: { $gt: 50000 } } }\n])</pre>",
                    "<pre class=\"prettyprint linenums\">db.sales.aggregate([\n  {\n    $group: {\n      _id: { year: { $year: \"$sale_date\" } },\n      totalQty: { $sum: \"$quantity_sold\" },\n      totalRevenue: { $sum: \"$total_revenue\" }\n    }\n  },\n  { $match: { totalRevenue: { $gt: 50000 } } }\n])</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "Consider a collection named sales that contains documents in the following format:{\n   \"_id\" : ObjectId(\"5f5f95aae2e85f9e7b33be5a\"),\n   \"product_id\" : \"P001\",\n   \"sale_date\" : ISODate(\"2022-05-01T08:00:00Z\"),\n   \"quantity_sold\" : 10,\n   \"total_revenue\" : 100\n}How can you calculate the total quantity sold and total revenue for each month and return only the months with a total revenue greater than $50,000 using the MongoDB aggregation framework?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168806,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>How does MongoDB handle sorting on fields that contain missing values (i.e., values that are not present in all documents in the collection)?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Missing values are sorted last. -&gt; Correct.</p><p>In MongoDB, missing values are considered to be equivalent to the value <code>\"null\"</code>. When sorting on fields that contain missing values, the documents with missing values are sorted last, regardless of the sort direction (ascending or descending). This is because the value <code>\"null\"</code> is considered to be greater than any other value when sorting in ascending order, and less than any other value when sorting in descending order. To ensure consistent sorting behavior, it's important to either remove documents with missing values or fill in the missing values with a default value.</p>",
                "answers": [
                    "<p>Missing values are sorted first.</p>",
                    "<p>Missing values are sorted last.</p>",
                    "<p>The sort fails and returns an error.</p>",
                    "<p>The behavior of sorting on missing values depends on the version of MongoDB being used.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "",
            "question_plain": "How does MongoDB handle sorting on fields that contain missing values (i.e., values that are not present in all documents in the collection)?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168808,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>What is the correct syntax to insert multiple documents into a MongoDB collection named <code>orders</code> and return the <code>_id</code> values for all inserted documents?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Correct answer:&nbsp;</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.insertMany([\n  { customer: \"John Smith\", product: \"Book\" },\n  { customer: \"Jane Doe\", product: \"Laptop\" }\n]).insertedIds</pre><p><br></p><p>In MongoDB, to return the <code>_id</code> values for all inserted documents, you can chain the <code>insertedIds</code> property to the result of the <code>insertMany()</code> method. The syntax would be <code>db.collection_name.insertMany([{ document1 }, { document2 }, ..., { documentN }]).insertedIds</code> where <code>collection_name</code> is the name of the collection you want to insert into and each <code>{ document }</code> is a document you want to insert represented as a JavaScript object.</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.insertMany(\n  [\n    { customer: \"John Smith\", product: \"Book\" },\n    { customer: \"Jane Doe\", product: \"Laptop\" }\n  ],\n  { returnIds: true }\n)</pre><p><br></p><p><code>returnIds</code> is not a valid option for the <code>insertMany()</code> method.</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.insertMany([\n  { customer: \"John Smith\", product: \"Book\" },\n  { customer: \"Jane Doe\", product: \"Laptop\" }\n]).returnIds</pre><p><br></p><p><code>returnIds</code> is not a property of the result of the <code>insertMany()</code> method.</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.insert(\n  [\n    { customer: \"John Smith\", product: \"Book\" },\n    { customer: \"Jane Doe\", product: \"Laptop\" }\n  ],\n  { returnIds: true }\n)</pre><p><br></p><p><code>insert()</code> is a method for inserting one document, not multiple documents.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.orders.insertMany(\n  [\n    { customer: \"John Smith\", product: \"Book\" },\n    { customer: \"Jane Doe\", product: \"Laptop\" }\n  ],\n  { returnIds: true }\n)</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.insertMany([\n  { customer: \"John Smith\", product: \"Book\" },\n  { customer: \"Jane Doe\", product: \"Laptop\" }\n]).returnIds</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.insertMany([\n  { customer: \"John Smith\", product: \"Book\" },\n  { customer: \"Jane Doe\", product: \"Laptop\" }\n]).insertedIds</pre>",
                    "<pre class=\"prettyprint linenums\">db.orders.insert(\n  [\n    { customer: \"John Smith\", product: \"Book\" },\n    { customer: \"Jane Doe\", product: \"Laptop\" }\n  ],\n  { returnIds: true }\n)</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "",
            "question_plain": "What is the correct syntax to insert multiple documents into a MongoDB collection named orders and return the _id values for all inserted documents?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 56168810,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>What is the correct syntax to update all documents in a MongoDB collection named <code>students</code> that have a <code>class</code> field equal to <code>\"B\"</code> to increase the value of <code>score</code> by 1 using the <code>$set</code> operator?</p>",
                "relatedLectureIds": "",
                "feedbacks": [
                    "",
                    "",
                    "",
                    ""
                ],
                "explanation": "<p>Correct answer:</p><p><br></p><pre class=\"prettyprint linenums\">db.students.updateMany({ class: \"B\" }, { $set: { score: { $inc: 1 } }})</pre><p><br></p><p>In MongoDB, to update a field in a document, you can use the <code>$set</code> operator with the <code>$inc</code> operator to increase its value. The syntax for updating multiple documents that match a certain criteria would be <code>db.collection_name.updateMany({ filter }, { $set: { field: { $inc: value } } })</code>.</p><p><br></p><pre class=\"prettyprint linenums\">db.students.updateMany({ class: \"B\" }, { $inc: { score: 1 }})</pre><p><br></p><p><code>$inc</code> is used to increment a field, not set it.</p><p><br></p><pre class=\"prettyprint linenums\">db.students.update({ class: \"B\" }, { $inc: { score: 1 }})</pre><p><br></p><p><code>update()</code> is a method for updating a single document, not multiple documents.</p><p><br></p><pre class=\"prettyprint linenums\">db.students.updateMany({ class: \"B\" }, { $set: { score: { $plus: 1 } }})</pre><p><br></p><p><code>$plus</code> is not a valid operator in MogoDB.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">db.students.updateMany({ class: \"B\" }, { $inc: { score: 1 }})</pre>",
                    "<pre class=\"prettyprint linenums\">db.students.update({ class: \"B\" }, { $inc: { score: 1 }})</pre>",
                    "<pre class=\"prettyprint linenums\">db.students.updateMany({ class: \"B\" }, { $set: { score: { $inc: 1 } }})</pre>",
                    "<pre class=\"prettyprint linenums\">db.students.updateMany({ class: \"B\" }, { $set: { score: { $plus: 1 } }})</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "",
            "question_plain": "What is the correct syntax to update all documents in a MongoDB collection named students that have a class field equal to \"B\" to increase the value of score by 1 using the $set operator?",
            "related_lectures": []
        }
    ]
}
