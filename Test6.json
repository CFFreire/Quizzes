{
  "count": 60,
  "next": null,
  "previous": null,
  "results": [
    {
      "_class": "assessment",
      "id": 56640932,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Complete the following sentence.</p><p><br></p><p>MongoDB is a <code>_____</code>&nbsp;database that provides high performance, high availability, and high scalability.</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Document databases are considered to be non-relational (or NoSQL) databases. Instead of storing data in fixed rows and columns, document databases use flexible documents. Document databases are the most popular alternative to tabular, relational databases.</p><p><br></p><p>https://www.mongodb.com/document-databases</p>",
        "answers": [
          "<p>document</p>",
          "<p>graph</p>",
          "<p>key-value</p>",
          "<p>relational</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Complete the following sentence.MongoDB is a _____&nbsp;database that provides high performance, high availability, and high scalability.",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640934,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the maximum size of a MongoDB&nbsp;document?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The maximum BSON document size is 16 megabytes.</p><p><br></p><p>https://www.mongodb.com/docs/manual/reference/limits/</p>",
        "answers": [
          "<p>16 MB</p>",
          "<p>32 MB</p>",
          "<p>8 MB</p>",
          "<p>1 MB</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is the maximum size of a MongoDB&nbsp;document?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640936,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Which of the following command skips the first 10 documents in the <code>movies</code><em> </em>collection and returns all remaining documents?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>cursor.skip(&lt;offset&gt;)</code> call the <code>skip()</code> method on a cursor to control where MongoDB begins returning results.</p><p><br></p><p>https://www.mongodb.com/docs/manual/reference/method/cursor.skip/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.movies.find().skip(10)</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find().limit(10)</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find().sort(10)</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find().skip(5)</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Which of the following command skips the first 10 documents in the movies collection and returns all remaining documents?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640938,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>By default, queries in MongoDB return all fields in matching documents. To limit the amount of data that MongoDB sends to applications (specific fields), you can use...</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>By default, queries in MongoDB return all fields in matching documents. To limit the amount of data that MongoDB sends to applications, you can include a projection document to specify or restrict fields to return.</p><p><br></p><p>The <code>limit()</code> method only allows us to specify the maximum number of documents, but not specific fields.</p>",
        "answers": [
          "<p>...projection document to specify or restrict fields to return.</p>",
          "<p>...the <code>limit()</code> method to specify the maximum number of documents you want.</p>",
          "<p>...indexes.</p>",
          "<p>...capped collections.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "By default, queries in MongoDB return all fields in matching documents. To limit the amount of data that MongoDB sends to applications (specific fields), you can use...",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640940,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the built-in database called <code>config</code> in MongoDB for?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>https://docs.mongodb.com/manual/reference/config-database/</p>",
        "answers": [
          "<p>The <code>config</code> database is used to store information about shards in shared MongoDB cluster.</p>",
          "<p>The <code>config</code> database plays an important role in the authentication and authorization process. Certain actions performed by administrators also require access to this database.</p>",
          "<p>The <code>config</code> database stores data describing the MongoDB server. For replica sets, it also stores information about the replication process.</p>",
          "<p>There is no built-in database called <code>config</code> in MongoDB.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is the built-in database called config in MongoDB for?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640942,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the built-in database called <code>local</code> in MongoDB for?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Every <code>mongod</code> instance has its own <code>local</code> database, which stores data used in the replication process, and other instance-specific data. The <code>local</code> database is invisible to replication: collections in the <code>local</code> database are not replicated.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/local-database/</p>",
        "answers": [
          "<p>The <code>local</code> database stores data describing the MongoDB server. For replica sets, it also stores information about the replication process.</p>",
          "<p>The <code>local</code> database plays an important role in the authentication and authorization process. Certain actions performed by administrators also require access to this database.</p>",
          "<p>The <code>local</code> database is used to store information about shards in shared MongoDB cluster.</p>",
          "<p>There is no built-in database called <code>local</code> in MongoDB.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is the built-in database called local in MongoDB for?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640944,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose you have a <code>movies</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  _id: ObjectId(\"573a1390f29313caabcd60e4\"),\n  title: 'The Immigrant',\n  fullplot: \"Charlie is on his way to the USA. He wins in a card game, puts the money in Edna's bag (she and her sick mother have been robbed of everything). When he retrieves a little for himself he is accused of being a thief. Edna clears his name. Later, broke, Charlie finds a coin and goes into a restaurant.\"\n}</pre><p><br></p><p>You want to perform text search queries on <code>fullplot</code><em> </em>field. What do you have to do?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>To run legacy text search queries, you must have a <code>text</code> index on your collection. MongoDB provides text indexes to support text search queries on string content. <code>text</code> indexes can include any field whose value is a string or an array of string elements. A collection can only have <strong>one</strong> text search index, but that index can cover multiple fields.</p><p><br></p><p><code>$text</code> performs a text search on the content of the fields indexed with a text index. A <code>$text</code> expression has the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  $text:\n    {\n      $search: &lt;string&gt;,\n      $language: &lt;string&gt;,\n      $caseSensitive: &lt;boolean&gt;,\n      $diacriticSensitive: &lt;boolean&gt;\n    }\n}</pre><p><br></p><p><br></p><p>https://docs.mongodb.com/manual/text-search/</p><p>https://docs.mongodb.com/manual/core/index-text/</p>",
        "answers": [
          "<p>Just query the database. For example:</p><p><br></p><pre class=\"prettyprint linenums\">db.movies.find( { $text: { $search: 'spaceship'} } ).explain()</pre>",
          "<p>First, create a text index:</p><p><br></p><pre class=\"prettyprint linenums\">db.movies.createIndex( { fullplot: 'text' } )</pre><p><br></p><p>Then query the database:</p><p><br></p><pre class=\"prettyprint linenums\">db.movies.find( { $text: { $search: 'spaceship' } } )</pre>",
          "<p>First, create an index:</p><p><br></p><pre class=\"prettyprint linenums\">db.movies.createIndex( { fullplot: 1 } )</pre><p><br></p><p>Then query the database:</p><p><br></p><pre class=\"prettyprint linenums\">db.movies.find( { $text: { $search: 'spaceship' } } )</pre>",
          "<p>You cannot perform a text search in MongoDB.</p>"
        ]
      },
      "correct_response": [
        "b"
      ],
      "section": "",
      "question_plain": "Suppose you have a movies collection with the following document structure:{\n  _id: ObjectId(\"573a1390f29313caabcd60e4\"),\n  title: 'The Immigrant',\n  fullplot: \"Charlie is on his way to the USA. He wins in a card game, puts the money in Edna's bag (she and her sick mother have been robbed of everything). When he retrieves a little for himself he is accused of being a thief. Edna clears his name. Later, broke, Charlie finds a coin and goes into a restaurant.\"\n}You want to perform text search queries on fullplot field. What do you have to do?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640946,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>We have an <code>accounts</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063714\"),\n&nbsp;&nbsp;account_id:&nbsp;1010,\n&nbsp;&nbsp;type:&nbsp;'investment',\n&nbsp;&nbsp;limit:&nbsp;1000000\n}</pre><p><br></p><p>And the following query:</p><p><br></p><pre class=\"prettyprint linenums\">db.accounts.find({\n  \"$or\": [\n    {\n      \"type\": {\n        \"$in\": [\n          \"investment\",\n          \"derivatives\"\n        ]\n      }\n    },\n    {\n      \"limit\": {\n        \"$gt\": 500000\n      }\n    }\n  ]\n})</pre><p><br></p><p>Which of the documents below will be retrieved by this query?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The <code>$in</code> operator selects the documents where the value of a field equals any value in the specified array. To specify an <code>$in</code> expression, use the following prototype:</p><p><br></p><pre class=\"prettyprint linenums\">{ field: { $in: [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; ] } }</pre><p><br></p><p>The <code>$or</code> operator performs a logical <code>OR</code> operation on an array of <em>two or more</em> <code>&lt;expressions&gt;</code> and selects the documents that satisfy <em>at least</em> one of the <code>&lt;expressions&gt;</code>. The <code>$or</code> has the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">{ $or: [ { &lt;expression1&gt; }, { &lt;expression2&gt; }, ... , { &lt;expressionN&gt; } ] }</pre><p><br></p><p><code>$gt</code> selects those documents where the value of the <code>field</code> is greater than (i.e. <code>&gt;</code>) the specified <code>value</code>. Syntax:</p><p><br></p><pre class=\"prettyprint linenums\">{ field: { $gt: value } }</pre><p><br></p><p><br></p><p>https://www.mongodb.com/docs/manual/reference/operator/query/in/</p><p>https://www.mongodb.com/docs/manual/reference/operator/query/or/</p><p>https://www.mongodb.com/docs/manual/reference/operator/query/gt/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063714\"),\n&nbsp;&nbsp;account_id:&nbsp;1010,\n&nbsp;&nbsp;type:&nbsp;'investment',\n&nbsp;&nbsp;limit:&nbsp;1000000\n}</pre>",
          "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063715\"),\n&nbsp;&nbsp;account_id:&nbsp;4336,\n&nbsp;&nbsp;type:&nbsp;'derivatives',\n&nbsp;&nbsp;limit:&nbsp;100000\n}</pre>",
          "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063357\"),\n&nbsp;&nbsp;account_id:&nbsp;1752,\n&nbsp;&nbsp;type:&nbsp;'commodity',\n&nbsp;&nbsp;limit:&nbsp;1000\n}</pre>",
          "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d067825\"),\n&nbsp;&nbsp;account_id:&nbsp;7355,\n&nbsp;&nbsp;type:&nbsp;'commodity',\n&nbsp;&nbsp;limit:&nbsp;500000\n}</pre>"
        ]
      },
      "correct_response": [
        "a",
        "b"
      ],
      "section": "",
      "question_plain": "We have an accounts collection with the following document structure:{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"61af47c6e29861661d063714\"),\n&nbsp;&nbsp;account_id:&nbsp;1010,\n&nbsp;&nbsp;type:&nbsp;'investment',\n&nbsp;&nbsp;limit:&nbsp;1000000\n}And the following query:db.accounts.find({\n  \"$or\": [\n    {\n      \"type\": {\n        \"$in\": [\n          \"investment\",\n          \"derivatives\"\n        ]\n      }\n    },\n    {\n      \"limit\": {\n        \"$gt\": 500000\n      }\n    }\n  ]\n})Which of the documents below will be retrieved by this query?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640948,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Given a <code>movies</code><em> </em>collection where each document has the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    _id: ObjectId('573a1390f29313caabcd60e4'),\n    genres: [ 'Short', 'Comedy', 'Drama' ],\n    title: 'The Immigrant',\n    year: 1917,\n    imdb: { rating: 7.8, votes: 4680, id: 8133 },\n    countries: [ 'USA' ]\n}</pre><p><br></p><p>Which of the following queries will find all movies that were made in 2000 or 2010?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.collection.find(query, projection)</code> selects documents in a collection or view and returns a cursor to the selected documents.</p><p><br></p><p>The <code>$or</code> operator performs a logical <code>OR</code> operation on an array of <em>two or more</em> <code>&lt;expressions&gt;</code> and selects the documents that satisfy <em>at least</em> one of the <code>&lt;expressions&gt;</code>. The <code>$or</code> has the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">{ $or: [ { &lt;expression1&gt; }, { &lt;expression2&gt; }, ... , { &lt;expressionN&gt; } ] }</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.find/</p><p>https://docs.mongodb.com/manual/reference/operator/query/or/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.movies.find( { $or: [ { year: 2000 }, { year: 2010 } ] } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { $and: [ { year: 2000 }, { year: 2010 } ] } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { $in: [ { year: 2000 }, { year: 2010 } ] } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { year: 2000, year: 2010 } )</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Given a movies collection where each document has the following structure:{\n    _id: ObjectId('573a1390f29313caabcd60e4'),\n    genres: [ 'Short', 'Comedy', 'Drama' ],\n    title: 'The Immigrant',\n    year: 1917,\n    imdb: { rating: 7.8, votes: 4680, id: 8133 },\n    countries: [ 'USA' ]\n}Which of the following queries will find all movies that were made in 2000 or 2010?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640950,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Suppose you insert the following documents into <code>companies</code><em> </em>collection:</p><p><br></p><pre class=\"prettyprint linenums\">db.companies.insertMany([\n    {\"_id\": 1, \"name\": \"Facebook\"}, \n    {\"_id\": 1, \"name\": \"Twitter\"}, \n    {\"_id\": 2, \"name\": \"Tesla\"},\n    {\"_id\": 3, \"name\": \"Amazon\"}\n], {\"ordered\": false})</pre><p><br></p><p>Select all true statements about this operation. (select 3)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The <code>insertMany()</code> method has the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">db.collection.insertMany(\n   [ &lt;document 1&gt; , &lt;document 2&gt;, ... ],\n   {\n      writeConcern: &lt;document&gt;,\n      ordered: &lt;boolean&gt;\n   }\n)</pre><p><br></p><p>Inserts multiple documents into a collection. Given an array of documents, <code>insertMany()</code> inserts each document in the array into the collection. By default documents are inserted in order. If <code>ordered</code> is set to false, documents are inserted in an unordered format and may be reordered by <code>mongod</code> to increase performance.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.insertMany/</p>",
        "answers": [
          "<p>This insert is unordered.</p>",
          "<p>MongoDB will insert each document with a unique <code>_id</code> value into the collection.</p>",
          "<p>Three documents will be inserted into the collection.</p>",
          "<p>Two documents will be inserted into the collection.</p>",
          "<p>One document will be inserted into the collection.</p>"
        ]
      },
      "correct_response": [
        "a",
        "b",
        "c"
      ],
      "section": "",
      "question_plain": "Suppose you insert the following documents into companies collection:db.companies.insertMany([\n    {\"_id\": 1, \"name\": \"Facebook\"}, \n    {\"_id\": 1, \"name\": \"Twitter\"}, \n    {\"_id\": 2, \"name\": \"Tesla\"},\n    {\"_id\": 3, \"name\": \"Amazon\"}\n], {\"ordered\": false})Select all true statements about this operation. (select 3)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640952,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Given a <code>movies</code><em> </em>collection where each document has the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    _id: ObjectId(\"573a1390f29313caabcd60e4\"),\n    genres: [ 'Short', 'Comedy', 'Drama' ],\n    title: 'The Immigrant',\n    year: 1917,\n    imdb: { rating: 7.8, votes: 4680, id: 8133 },\n    countries: [ 'USA' ]\n}</pre><p><br></p><p>Which of the following queries will find all Comedy movies that were made in 2000? (select 2)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.collection.find(query, projection)</code> selects documents in a collection or view and returns a cursor to the selected documents.</p><p><br></p><p><code>$and</code> performs a logical <code>AND</code> operation on an array of <em>one or more</em> expressions (<code>&lt;expression1&gt;</code>, <code>&lt;expression2&gt;</code>, and so on) and selects the documents that satisfy <em>all</em> the expressions. The <code>$and</code> has the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">{ $and: [ { &lt;expression1&gt; }, { &lt;expression2&gt; } , ... , { &lt;expressionN&gt; } ] }</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.find/</p><p>https://docs.mongodb.com/manual/reference/operator/query/and/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.movies.find( { year: 2000, genres: \"Comedy\" } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { $and: [ { year: 2000 }, { genres: \"Comedy\" } ] } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { $or: [ { year: 2000 }, { genres: \"Comedy\" } ] } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { year: 2000 }, { genres: \"Comedy\" } )</pre>"
        ]
      },
      "correct_response": [
        "a",
        "b"
      ],
      "section": "",
      "question_plain": "Given a movies collection where each document has the following structure:{\n    _id: ObjectId(\"573a1390f29313caabcd60e4\"),\n    genres: [ 'Short', 'Comedy', 'Drama' ],\n    title: 'The Immigrant',\n    year: 1917,\n    imdb: { rating: 7.8, votes: 4680, id: 8133 },\n    countries: [ 'USA' ]\n}Which of the following queries will find all Comedy movies that were made in 2000? (select 2)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640954,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Given a <code>companies</code><em> </em>collection where each document has the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    _id: ObjectId(\"52cdef7c4bab8bd675297efd\"),\n    name: 'ZoomInfo',\n    homepage_url: 'http://www.zoominfo.com',\n    blog_url: 'http://zoominfoblogger.wordpress.com/',\n    twitter_username: 'ZoomInfo',\n    founded_year: 2000,\n    email_address: ''\n}</pre><p><br></p><p>Extract all companies from this collection that have the same Twitter username as the company name. Which query should you use?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><br></p><pre class=\"prettyprint linenums\">db.companies.find( { $expr: { $eq: ['$name', 'twitter_username'] } } )</pre><p><br></p><p>You have to use <code>$</code> sign to evaluate <em>twitter_username </em>field.</p><p><br></p><pre class=\"prettyprint linenums\">db.companies.find( { $expr: { $eq: ['name', 'twitter_username'] } } )</pre><p><br></p><p>You have to use <code>$</code> sign to evaluate <em>name </em>and <em>twitter_username </em>fields.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/query/expr/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.companies.find( { $expr: { $eq: ['$name', '$twitter_username'] } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.companies.find( { $expr: { $ne: ['$name', '$twitter_username'] } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.companies.find( { $expr: { $eq: ['$name', 'twitter_username'] } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.companies.find( { $expr: { $eq: ['name', 'twitter_username'] } } )</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Given a companies collection where each document has the following structure:{\n    _id: ObjectId(\"52cdef7c4bab8bd675297efd\"),\n    name: 'ZoomInfo',\n    homepage_url: 'http://www.zoominfo.com',\n    blog_url: 'http://zoominfoblogger.wordpress.com/',\n    twitter_username: 'ZoomInfo',\n    founded_year: 2000,\n    email_address: ''\n}Extract all companies from this collection that have the same Twitter username as the company name. Which query should you use?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640956,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>In your database there is a collection named <code>sales</code><em> </em>with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  _id: ObjectId(\"5bd761dcae323e45a93ccfe8\"),\n  saleDate: ISODate(\"2015-03-23T21:06:49.506Z\"),\n  items: [\n    {\n      name: 'printer paper',\n      tags: [ 'office', 'stationary' ],\n      price: Decimal128(\"40.01\"),\n      quantity: 2\n    },\n    {\n      name: 'notepad',\n      tags: [ 'office', 'writing', 'school' ],\n      price: Decimal128(\"35.29\"),\n      quantity: 2\n    },\n    {\n      name: 'pens',\n      tags: [ 'writing', 'school', 'stationary' ],\n      price: Decimal128(\"56.12\"),\n      quantity: 5\n    }\n  ],\n  storeLocation: 'Denver',\n  customer: { gender: 'M', age: 42, email: 'cauho@witwuta.sv', satisfaction: 4 },\n  purchaseMethod: 'Online'\n}</pre><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"5bd761dcae323e45a93ccfe9\"),\n&nbsp;&nbsp;saleDate:&nbsp;ISODate(\"2015-08-25T10:01:02.918Z\"),\n&nbsp;&nbsp;items:&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'binder',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags:&nbsp;[&nbsp;'school',&nbsp;'general',&nbsp;'organization'&nbsp;],\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;price:&nbsp;Decimal128(\"28.31\"),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantity:&nbsp;9\n&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'backpack',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags:&nbsp;[&nbsp;'school',&nbsp;'travel',&nbsp;'kids'&nbsp;],\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;price:&nbsp;Decimal128(\"83.28\"),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantity:&nbsp;2\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;],\n&nbsp;&nbsp;storeLocation:&nbsp;'Seattle',\n&nbsp;&nbsp;customer:&nbsp;{&nbsp;gender:&nbsp;'M',&nbsp;age:&nbsp;50,&nbsp;email:&nbsp;'keecade@hem.uy',&nbsp;satisfaction:&nbsp;5&nbsp;},\n&nbsp;&nbsp;couponUsed:&nbsp;false,\n&nbsp;&nbsp;purchaseMethod:&nbsp;'Phone'\n}</pre><p><br></p><p>How can you extract all documents from this collection where the first tag in the <code>tags</code><em> </em>field (Array) is <code>'office'</code> in at least one item?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Using dot notation, you can specify query conditions for field in a document at a particular index or position of the array. The array uses zero-based indexing.</p><p><br></p><p>https://www.mongodb.com/docs/manual/tutorial/query-array-of-documents/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.sales.find( { 'items.tags.0': 'office' } )</pre>",
          "<pre class=\"prettyprint linenums\">db.sales.find( { 'items.tags$0': 'office' } )</pre>",
          "<pre class=\"prettyprint linenums\">db.sales.find( { 'items.tags.[0]': 'office' } )</pre>",
          "<pre class=\"prettyprint linenums\">db.sales.find( { 'items.tags': 'office' } )</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "In your database there is a collection named sales with the following document structure:{\n  _id: ObjectId(\"5bd761dcae323e45a93ccfe8\"),\n  saleDate: ISODate(\"2015-03-23T21:06:49.506Z\"),\n  items: [\n    {\n      name: 'printer paper',\n      tags: [ 'office', 'stationary' ],\n      price: Decimal128(\"40.01\"),\n      quantity: 2\n    },\n    {\n      name: 'notepad',\n      tags: [ 'office', 'writing', 'school' ],\n      price: Decimal128(\"35.29\"),\n      quantity: 2\n    },\n    {\n      name: 'pens',\n      tags: [ 'writing', 'school', 'stationary' ],\n      price: Decimal128(\"56.12\"),\n      quantity: 5\n    }\n  ],\n  storeLocation: 'Denver',\n  customer: { gender: 'M', age: 42, email: 'cauho@witwuta.sv', satisfaction: 4 },\n  purchaseMethod: 'Online'\n}{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"5bd761dcae323e45a93ccfe9\"),\n&nbsp;&nbsp;saleDate:&nbsp;ISODate(\"2015-08-25T10:01:02.918Z\"),\n&nbsp;&nbsp;items:&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'binder',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags:&nbsp;[&nbsp;'school',&nbsp;'general',&nbsp;'organization'&nbsp;],\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;price:&nbsp;Decimal128(\"28.31\"),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantity:&nbsp;9\n&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'backpack',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags:&nbsp;[&nbsp;'school',&nbsp;'travel',&nbsp;'kids'&nbsp;],\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;price:&nbsp;Decimal128(\"83.28\"),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantity:&nbsp;2\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;],\n&nbsp;&nbsp;storeLocation:&nbsp;'Seattle',\n&nbsp;&nbsp;customer:&nbsp;{&nbsp;gender:&nbsp;'M',&nbsp;age:&nbsp;50,&nbsp;email:&nbsp;'keecade@hem.uy',&nbsp;satisfaction:&nbsp;5&nbsp;},\n&nbsp;&nbsp;couponUsed:&nbsp;false,\n&nbsp;&nbsp;purchaseMethod:&nbsp;'Phone'\n}How can you extract all documents from this collection where the first tag in the tags field (Array) is 'office' in at least one item?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640958,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Select all true statements about auto bucketing feature in Aggregation Framework (<code>$bucketAuto</code> stage). (select 3)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>$bucketAuto</code> categorizes incoming documents into a specific number of groups, called buckets, based on a specified expression. Bucket boundaries are automatically determined in an attempt to evenly distribute the documents into the specified number of buckets.</p><p><br></p><p>The <code>$bucketAuto</code> stage has the following form:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  $bucketAuto: {\n      groupBy: &lt;expression&gt;,\n      buckets: &lt;number&gt;,\n      output: {\n         &lt;output1&gt;: { &lt;$accumulator expression&gt; },\n         ...\n      }\n      granularity: &lt;string&gt;\n  }\n}</pre><p><br></p><p>The <code>$bucketAuto</code> stage has a limit of 100 megabytes of RAM. By default, if the stage exceeds this limit, <code>$bucketAuto</code> returns an error. To allow more space for stage processing, use the allowDiskUse option to enable aggregation pipeline stages to write data to temporary files.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/aggregation/bucketAuto/</p>",
        "answers": [
          "<p>This stage distributes documents evenly across predefined number of buckets.</p>",
          "<p>The <code>granularity</code> option allows us to specify preferred bucket boundaries.</p>",
          "<p>The syntax for this stage is as follows:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    $bucketAuto: {\n        groupBy: &lt;expression&gt;,\n        buckets: &lt;number&gt;,\n        output: {\n            &lt;output1&gt;: { &lt;$accumulator expression&gt; },\n            ...\n        }\n        granularity: &lt;string&gt;\n    }\n}</pre>",
          "<p>The <code>$bucketAuto</code> stage has a limit of 500 megabytes of RAM.</p>"
        ]
      },
      "correct_response": [
        "a",
        "b",
        "c"
      ],
      "section": "",
      "question_plain": "Select all true statements about auto bucketing feature in Aggregation Framework ($bucketAuto stage). (select 3)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640960,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>A collection called <code>players</code><em> </em>contains the following documents:</p><p><br></p><pre class=\"prettyprint linenums\">[\n  { _id: 1, user: 'Tom', scores: [ 23, 56, 3, 52, 62 ], bonus: 5 },\n  { _id: 2, user: 'Jane', scores: [ 42, 50, 10 ], bonus: 3 }\n]</pre><p><br></p><p>You want to add additional fields to each document:</p><p>-&gt; <code>total_score</code><em> </em>(sum of the <em>scores </em>Array)</p><p>-&gt; <code>avg_score</code><em> </em>(average score in <em>scores </em>Array)</p><p><br></p><p><strong>Expected output:</strong></p><p><br></p><pre class=\"prettyprint linenums\">[\n  {\n    _id: 1,\n    user: 'Tom',\n    scores: [ 23, 56, 3, 52, 62 ],\n    bonus: 5,\n    total_score: 196,\n    avg_score: 39.2\n  },\n  {\n    _id: 2,\n    user: 'Jane',\n    scores: [ 42, 50, 10 ],\n    bonus: 3,\n    total_score: 102,\n    avg_score: 34\n  }\n]</pre><p><br></p><p>Which query do you need to use?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.collection.aggregate(pipeline, options)</code><strong> </strong>calculates aggregate values for the data in a collection or a view. </p><p><br></p><p><code>$addField</code> adds new fields to documents. <code>$addFields</code> outputs documents that contain all existing fields from the input documents and newly added fields.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/</p><p>https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.players.aggregate([{\n&nbsp;&nbsp;&nbsp;&nbsp;$addFields:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$avg:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}])</pre>",
          "<pre class=\"prettyprint linenums\">db.players.aggregate([{\n&nbsp;&nbsp;&nbsp;&nbsp;$add:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$avg:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}])</pre>",
          "<pre class=\"prettyprint linenums\">db.players.aggregate([{\n&nbsp;&nbsp;&nbsp;&nbsp;$addFields:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum:&nbsp;'scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$avg:&nbsp;'scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}])</pre>",
          "<pre class=\"prettyprint linenums\">db.players.aggregate([{\n&nbsp;&nbsp;&nbsp;&nbsp;$add:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_score:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$avg:&nbsp;'$scores'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}])</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "A collection called players contains the following documents:[\n  { _id: 1, user: 'Tom', scores: [ 23, 56, 3, 52, 62 ], bonus: 5 },\n  { _id: 2, user: 'Jane', scores: [ 42, 50, 10 ], bonus: 3 }\n]You want to add additional fields to each document:-&gt; total_score (sum of the scores Array)-&gt; avg_score (average score in scores Array)Expected output:[\n  {\n    _id: 1,\n    user: 'Tom',\n    scores: [ 23, 56, 3, 52, 62 ],\n    bonus: 5,\n    total_score: 196,\n    avg_score: 39.2\n  },\n  {\n    _id: 2,\n    user: 'Jane',\n    scores: [ 42, 50, 10 ],\n    bonus: 3,\n    total_score: 102,\n    avg_score: 34\n  }\n]Which query do you need to use?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640962,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Use case: e-learning platform </p><p><br></p><p>Which of the following scenarios is <strong>the best candidate</strong> to use the Extended Reference Pattern to avoid additional reads by joins/lookups?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>https://www.mongodb.com/blog/post/building-with-patterns-the-extended-reference-pattern</p>",
        "answers": [
          "<p>Our app needs to retrieve a course and information about its instructor.</p>",
          "<p>Our app needs to retrieve a course and its ten most recent reviews.</p>",
          "<p>A course model needs to store a counter representing the number of times it was purchased.</p>",
          "<p>A course model needs to store references to image of the course that are kept in an external location outside the database.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Use case: e-learning platform Which of the following scenarios is the best candidate to use the Extended Reference Pattern to avoid additional reads by joins/lookups?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640964,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Use case: e-learning platform </p><p><br></p><p>Which of the following scenarios is <strong>the best candidate</strong> to use the Subset Pattern?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>https://www.mongodb.com/blog/post/building-with-patterns-the-subset-pattern</p>",
        "answers": [
          "<p>Our app needs to retrieve a course and its ten most recent reviews.</p>",
          "<p>Our app needs to retrieve a course and information about its instructor.</p>",
          "<p>A course model needs to store a counter representing the number of times it was purchased.</p>",
          "<p>A course model needs to store references to image of the course that are kept in an external location outside the database.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Use case: e-learning platform Which of the following scenarios is the best candidate to use the Subset Pattern?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640966,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>We can use this pattern to work with different schema versions. It mainly involves adding a new field to the document structure, such as <code>schema_version</code>. This field will allow our application to know how to handle particular document.</p><p><br></p><p>Which pattern does this description apply to?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>https://www.mongodb.com/blog/post/building-with-patterns-the-schema-versioning-pattern</p>",
        "answers": [
          "<p>The Schema Versioning Pattern.</p>",
          "<p>The Outlier Pattern.</p>",
          "<p>The Subset Pattern.</p>",
          "<p>The Attribute Pattern.</p>",
          "<p>The Polymorphic Pattern.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "We can use this pattern to work with different schema versions. It mainly involves adding a new field to the document structure, such as schema_version. This field will allow our application to know how to handle particular document.Which pattern does this description apply to?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640968,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Select true statements about data modeling in MongoDB. (select 2)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          ""
        ],
        "explanation": "<p>https://docs.mongodb.com/manual/core/data-modeling-introduction/</p>",
        "answers": [
          "<p>It's good data modeling practice to directly map each table from the relational model (normalized data) to the collection.</p>",
          "<p>If one of your application's main queries is to retrieve related information from different collections, it is usually better to group that information into a single document.</p>",
          "<p>To avoid having to join data in the application layer from different collections you can denormalize your data.</p>"
        ]
      },
      "correct_response": [
        "b",
        "c"
      ],
      "section": "",
      "question_plain": "Select true statements about data modeling in MongoDB. (select 2)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640970,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Select all true statements about the schema validation in MongoDB. (select 2)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Validation rules are on a per-collection basis. To specify validation rules when creating a new collection, use <code>db.createCollection()</code> with the <code>validator</code> option. Users can bypass document validation using the <code>bypassDocumentValidation</code> option.</p><p><br></p><p>https://docs.mongodb.com/manual/core/schema-validation/</p>",
        "answers": [
          "<p>MongoDB doesn't provide the capability to perform schema validation during updates and insertions.</p>",
          "<p>Validation rules are on a per-collection basis.</p>",
          "<p>We need to use <code>db.createCollection()</code> with the <code>validator</code> option to specify validation rules for a new collection.</p>",
          "<p>Users cannot bypass document validation using any additional option.</p>"
        ]
      },
      "correct_response": [
        "b",
        "c"
      ],
      "section": "",
      "question_plain": "Select all true statements about the schema validation in MongoDB. (select 2)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640972,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose you have a <code>products</code><em> </em>collection with an index:</p><p><br></p><pre class=\"prettyprint linenums\">{ product_category:&nbsp;1 }</pre><p><br></p><p>For which of the following queries can MongoDB look at only a subset of the index entries, rather than all of the index entries? </p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          ""
        ],
        "explanation": "<p><code>$regex</code> provides regular expression capabilities for pattern matching <em>strings</em> in queries.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/query/regex/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.products.find( { product_category: /^A./ } )</pre>",
          "<pre class=\"prettyprint linenums\">db.products.find( { product_category: /A./ } )</pre>",
          "<pre class=\"prettyprint linenums\">db.products.find( { product_category: /S./ } )</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Suppose you have a products collection with an index:{ product_category:&nbsp;1 }For which of the following queries can MongoDB look at only a subset of the index entries, rather than all of the index entries?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640974,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>You have the following index in a <code>products</code> collection:</p><p><br></p><pre class=\"prettyprint linenums\">{ product_category:&nbsp;1,&nbsp;product_name:&nbsp;1,&nbsp;origin_country:&nbsp;-1 }</pre><p><br></p><p>Which of the following queries can use this index? (select 3)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Indexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must perform a collection scan, i.e. scan every document in a collection, to select those documents that match the query statement. If an appropriate index exists for a query, MongoDB can use the index to limit the number of documents it must inspect.</p><p><br></p><p>https://docs.mongodb.com/manual/indexes/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.products.find({\n&nbsp;&nbsp;&nbsp;&nbsp;product_category:&nbsp;'shoes',&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;product_name:&nbsp;'AIR&nbsp;MAX&nbsp;90',&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;origin_country:&nbsp;'Bangladesh'\n})</pre>",
          "<pre class=\"prettyprint linenums\">db.products.find({\n&nbsp;&nbsp;&nbsp;&nbsp;product_name:&nbsp;'AIR&nbsp;MAX&nbsp;90',&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;product_category:&nbsp;'shoes',&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;origin_country:&nbsp;'Bangladesh'\n})</pre>",
          "<pre class=\"prettyprint linenums\">db.products.find({\n&nbsp;&nbsp;&nbsp;&nbsp;origin_country:&nbsp;'Bangladesh',&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;product_name:&nbsp;'AIR&nbsp;MAX&nbsp;90',&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;product_category:&nbsp;'shoes'\n})</pre>",
          "<pre class=\"prettyprint linenums\">db.products.find({\n&nbsp;&nbsp;&nbsp;&nbsp;product_name:&nbsp;'AIR&nbsp;MAX&nbsp;90',&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;origin_country:&nbsp;'Bangladesh'\n})</pre>"
        ]
      },
      "correct_response": [
        "a",
        "b",
        "c"
      ],
      "section": "",
      "question_plain": "You have the following index in a products collection:{ product_category:&nbsp;1,&nbsp;product_name:&nbsp;1,&nbsp;origin_country:&nbsp;-1 }Which of the following queries can use this index? (select 3)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640976,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Select all true statements regarding to unique indexes in MongoDB. (select 3)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>A unique index ensures that the indexed fields do not store duplicate values; i.e. enforces uniqueness for the indexed fields. By default, MongoDB creates a unique index on the _id field during the creation of a collection.</p><p><br></p><p>https://docs.mongodb.com/manual/core/index-unique/</p>",
        "answers": [
          "<p>A unique index ensures that the indexed fields don't store duplicate values.</p>",
          "<p>By default, MongoDB creates a unique index on the <code>_id</code> field.</p>",
          "<p>When creating a unique index, we need to pass an additional <em>unique </em>option set to <em>true</em>. For example:</p><p><br></p><pre class=\"prettyprint linenums\">db.products.createIndex( { manufacturer_id:&nbsp;1 }, { unique: true } )</pre>",
          "<p>By default, MongoDB creates a unique index for each field.</p>"
        ]
      },
      "correct_response": [
        "a",
        "b",
        "c"
      ],
      "section": "",
      "question_plain": "Select all true statements regarding to unique indexes in MongoDB. (select 3)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640978,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose we have a <code>products</code><em> </em>collection with the following fields and values:</p><p>-&gt; <code>_id</code> (automatically created ObjectId)</p><p>-&gt; <code>product_code</code> (unique values for each product)</p><p>-&gt; <code>color</code> (as String values)</p><p>-&gt; <code>size</code>&nbsp;(this field is missing for some products)</p><p>-&gt; <code>origin_country</code></p><p><br></p><p>Which of these fields would be the best shard key?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>With <code>color</code>, <code>size</code>, and <code>origin_country</code> we run the risk of low cardinality. The <code>_id</code> wouldn't make a good shard key because it isn't something meaningful we could query the database.</p><p><br></p><p>https://docs.mongodb.com/manual/core/sharding-shard-key/</p>",
        "answers": [
          "<p><code>product_code</code></p>",
          "<p><code>_id</code></p>",
          "<p><code>color</code></p>",
          "<p><code>size</code></p>",
          "<p><code>origin_country</code></p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Suppose we have a products collection with the following fields and values:-&gt; _id (automatically created ObjectId)-&gt; product_code (unique values for each product)-&gt; color (as String values)-&gt; size&nbsp;(this field is missing for some products)-&gt; origin_countryWhich of these fields would be the best shard key?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640980,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>In which situations can we consider sharding? (select 3)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Sharding is a method for distributing data across multiple machines. MongoDB uses sharding to support deployments with very large data sets and high throughput operations.</p><p><br></p><p>https://docs.mongodb.com/manual/sharding/</p>",
        "answers": [
          "<p>We want to improve read performance for our application.</p>",
          "<p>Our dataset is too big to fit in one MongoDB instance.</p>",
          "<p>It takes too long to backup and restore the data set.</p>",
          "<p>A new developer will join your development team soon.</p>"
        ]
      },
      "correct_response": [
        "a",
        "b",
        "c"
      ],
      "section": "",
      "question_plain": "In which situations can we consider sharding? (select 3)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640982,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose you have a <code>restaurants</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  _id: ObjectId(\"5eb3d668b31de5d588f42931\"),\n  address: {\n    building: '6409',\n    coord: [ -74.00528899999999, 40.628886 ],\n    street: '11 Avenue',\n    zipcode: '11219'\n  },\n  borough: 'Brooklyn',\n  cuisine: 'American',\n  grades: [\n    {\n      date: ISODate(\"2014-07-18T00:00:00.000Z\"),\n      grade: 'A',\n      score: 12\n    },\n    {\n      date: ISODate(\"2013-07-30T00:00:00.000Z\"),\n      grade: 'A',\n      score: 12\n    },\n    {\n      date: ISODate(\"2013-02-13T00:00:00.000Z\"),\n      grade: 'A',\n      score: 11\n    },\n    { date: ISODate(\"2012-08-16T00:00:00.000Z\"), \n      grade: 'A', \n      score: 2 },\n    {\n      date: ISODate(\"2011-08-17T00:00:00.000Z\"),\n      grade: 'A',\n      score: 11\n    }\n  ],\n  name: 'Regina Caterers',\n  restaurant_id: '40356649'\n}</pre><p><br></p><p>You don't have any indexes so far. What will the query plan look like for the following query?</p><p><br></p><pre class=\"prettyprint linenums\">db.restaurants.find( { \"cuisine\": \"American\" } )</pre><p><br></p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Indexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must perform a collection scan, i.e. scan every document in a collection, to select those documents that match the query statement. If an appropriate index exists for a query, MongoDB can use the index to limit the number of documents it must inspect.</p><p><br></p><p>https://docs.mongodb.com/manual/indexes/</p>",
        "answers": [
          "<p>COLLSCAN</p>",
          "<p>IXSCAN</p>",
          "<p>FETCH</p>",
          "<p>SORT</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Suppose you have a restaurants collection with the following document structure:{\n  _id: ObjectId(\"5eb3d668b31de5d588f42931\"),\n  address: {\n    building: '6409',\n    coord: [ -74.00528899999999, 40.628886 ],\n    street: '11 Avenue',\n    zipcode: '11219'\n  },\n  borough: 'Brooklyn',\n  cuisine: 'American',\n  grades: [\n    {\n      date: ISODate(\"2014-07-18T00:00:00.000Z\"),\n      grade: 'A',\n      score: 12\n    },\n    {\n      date: ISODate(\"2013-07-30T00:00:00.000Z\"),\n      grade: 'A',\n      score: 12\n    },\n    {\n      date: ISODate(\"2013-02-13T00:00:00.000Z\"),\n      grade: 'A',\n      score: 11\n    },\n    { date: ISODate(\"2012-08-16T00:00:00.000Z\"), \n      grade: 'A', \n      score: 2 },\n    {\n      date: ISODate(\"2011-08-17T00:00:00.000Z\"),\n      grade: 'A',\n      score: 11\n    }\n  ],\n  name: 'Regina Caterers',\n  restaurant_id: '40356649'\n}You don't have any indexes so far. What will the query plan look like for the following query?db.restaurants.find( { \"cuisine\": \"American\" } )",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640984,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose you have a <code>restaurants</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  _id: ObjectId(\"5eb3d668b31de5d588f42931\"),\n  address: {\n    building: '6409',\n    coord: [ -74.00528899999999, 40.628886 ],\n    street: '11 Avenue',\n    zipcode: '11219'\n  },\n  borough: 'Brooklyn',\n  cuisine: 'American',\n  grades: [\n    {\n      date: ISODate(\"2014-07-18T00:00:00.000Z\"),\n      grade: 'A',\n      score: 12\n    },\n    {\n      date: ISODate(\"2013-07-30T00:00:00.000Z\"),\n      grade: 'A',\n      score: 12\n    },\n    {\n      date: ISODate(\"2013-02-13T00:00:00.000Z\"),\n      grade: 'A',\n      score: 11\n    },\n    { date: ISODate(\"2012-08-16T00:00:00.000Z\"), \n      grade: 'A', \n      score: 2 },\n    {\n      date: ISODate(\"2011-08-17T00:00:00.000Z\"),\n      grade: 'A',\n      score: 11\n    }\n  ],\n  name: 'Regina Caterers',\n  restaurant_id: '40356649'\n}</pre><p><br></p><p>You have the following index:</p><p><br></p><pre class=\"prettyprint linenums\">{ \"cuisine\": 1, \"borough\": 1 }</pre><p><br></p><p>What will the query plan look like for the following query?</p><p><br></p><pre class=\"prettyprint linenums\">db.restaurants.find( { \"cuisine\": \"American\", \"borough\": { \"$gt\": \"S\" } } )</pre><p><br></p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Indexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must perform a collection scan, i.e. scan every document in a collection, to select those documents that match the query statement. If an appropriate index exists for a query, MongoDB can use the index to limit the number of documents it must inspect.</p><p><br></p><p>https://docs.mongodb.com/manual/indexes/</p>",
        "answers": [
          "<p>IXSCAN -&gt; FETCH -&gt;&nbsp;SORT</p>",
          "<p>COLLSCAN -&gt;&nbsp;SORT</p>",
          "<p>FETCH -&gt;&nbsp;SORT</p>",
          "<p>SORT -&gt; IXSCAN -&gt; FETCH</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Suppose you have a restaurants collection with the following document structure:{\n  _id: ObjectId(\"5eb3d668b31de5d588f42931\"),\n  address: {\n    building: '6409',\n    coord: [ -74.00528899999999, 40.628886 ],\n    street: '11 Avenue',\n    zipcode: '11219'\n  },\n  borough: 'Brooklyn',\n  cuisine: 'American',\n  grades: [\n    {\n      date: ISODate(\"2014-07-18T00:00:00.000Z\"),\n      grade: 'A',\n      score: 12\n    },\n    {\n      date: ISODate(\"2013-07-30T00:00:00.000Z\"),\n      grade: 'A',\n      score: 12\n    },\n    {\n      date: ISODate(\"2013-02-13T00:00:00.000Z\"),\n      grade: 'A',\n      score: 11\n    },\n    { date: ISODate(\"2012-08-16T00:00:00.000Z\"), \n      grade: 'A', \n      score: 2 },\n    {\n      date: ISODate(\"2011-08-17T00:00:00.000Z\"),\n      grade: 'A',\n      score: 11\n    }\n  ],\n  name: 'Regina Caterers',\n  restaurant_id: '40356649'\n}You have the following index:{ \"cuisine\": 1, \"borough\": 1 }What will the query plan look like for the following query?db.restaurants.find( { \"cuisine\": \"American\", \"borough\": { \"$gt\": \"S\" } } )",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640986,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Select all true statements about indexes on a field with values of varying data types. (select 2)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Indexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must perform a collection scan, i.e. scan every document in a collection, to select those documents that match the query statement. If an appropriate index exists for a query, MongoDB can use the index to limit the number of documents it must inspect.</p><p><br></p><p>https://docs.mongodb.com/manual/indexes/</p>",
        "answers": [
          "<p>Values are ordered by data type, then by value.</p>",
          "<p>In MongoDB index can have different data types.</p>",
          "<p>Values are ordered only by value.</p>",
          "<p>Values are ordered only by data type.</p>"
        ]
      },
      "correct_response": [
        "a",
        "b"
      ],
      "section": "",
      "question_plain": "Select all true statements about indexes on a field with values of varying data types. (select 2)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640988,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Which of the following actions are granted to the built-in <code>read</code><em> </em>role? (select 2)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>read</code> provides the ability to read data on all <em>non</em>-system collections and the <code>system.js</code> collection. </p><p><br></p><p>https://docs.mongodb.com/manual/reference/built-in-roles/#mongodb-authrole-read</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">find</pre>",
          "<pre class=\"prettyprint linenums\">insert</pre>",
          "<pre class=\"prettyprint linenums\">update</pre>",
          "<pre class=\"prettyprint linenums\">remove</pre>",
          "<pre class=\"prettyprint linenums\">listIndexes</pre>"
        ]
      },
      "correct_response": [
        "a",
        "e"
      ],
      "section": "",
      "question_plain": "Which of the following actions are granted to the built-in read role? (select 2)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640990,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Which of the following commands are valid to start a <code>mongod</code>?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><br></p><pre class=\"prettyprint linenums\">mongod&nbsp;--dbpath&nbsp;/data/db&nbsp;--fork</pre><p><br></p><p>This is incorrect because a --logpath must be specified in order to fork the process.</p><p><br></p><pre class=\"prettyprint linenums\">mongod&nbsp;--log&nbsp;/var/log/mongo/mongod.log&nbsp;--db&nbsp;/data/db&nbsp;--fork</pre><p><br></p><p>This is incorrect because both --log and --db are invalid flags.</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">mongod&nbsp;--logpath&nbsp;/var/log/mongo/mongod.log&nbsp;--dbpath&nbsp;/data/db&nbsp;--fork</pre>",
          "<pre class=\"prettyprint linenums\">mongod&nbsp;-f&nbsp;/etc/mongod.conf</pre>",
          "<pre class=\"prettyprint linenums\">mongod&nbsp;--log&nbsp;/var/log/mongo/mongod.log&nbsp;--db&nbsp;/data/db&nbsp;--fork</pre>",
          "<pre class=\"prettyprint linenums\">mongod&nbsp;--dbpath&nbsp;/data/db&nbsp;--fork</pre>"
        ]
      },
      "correct_response": [
        "a",
        "b"
      ],
      "section": "",
      "question_plain": "Which of the following commands are valid to start a mongod?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640992,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>You have the following replica set configuration:</p><p><br></p><pre class=\"prettyprint linenums\">conf&nbsp;=&nbsp;{\n&nbsp;&nbsp;\"_id\":&nbsp;\"replset\",\n&nbsp;&nbsp;\"version\":&nbsp;1,\n&nbsp;&nbsp;\"protocolVersion\":&nbsp;1,\n&nbsp;&nbsp;\"members\":&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"_id\":&nbsp;0,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"host\":&nbsp;\"192.168.120.24:27017\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"priority\":&nbsp;2,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"votes\":&nbsp;1\n&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"_id\":&nbsp;1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"host\":&nbsp;\"192.168.120.24:27018\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"priority\":&nbsp;1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"votes\":&nbsp;1\n&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"_id\":&nbsp;1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"host\":&nbsp;\"192.168.120.24:27019\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"priority\":&nbsp;1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"votes\":&nbsp;1\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;]\n}</pre><p><br></p><p>Select the true statement about this configuration.</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>A <em>replica set</em> in MongoDB is a group of <code>mongod</code> processes that maintain the same data set. Replica sets provide redundancy and high availability, and are the basis for all production deployments.</p><p><br></p><p>https://docs.mongodb.com/manual/replication/#replication</p>",
        "answers": [
          "<p>This configuration is correct.</p>",
          "<p>This configuration is incorrect. Host information must be unique for each member in a replica set.</p>",
          "<p>This configuration is incorrect. You can only specify a priority of 0 or 1.</p>",
          "<p>This configuration is incorrect. <code>_id</code> field must be unique for each member in a replica set.</p>"
        ]
      },
      "correct_response": [
        "d"
      ],
      "section": "",
      "question_plain": "You have the following replica set configuration:conf&nbsp;=&nbsp;{\n&nbsp;&nbsp;\"_id\":&nbsp;\"replset\",\n&nbsp;&nbsp;\"version\":&nbsp;1,\n&nbsp;&nbsp;\"protocolVersion\":&nbsp;1,\n&nbsp;&nbsp;\"members\":&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"_id\":&nbsp;0,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"host\":&nbsp;\"192.168.120.24:27017\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"priority\":&nbsp;2,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"votes\":&nbsp;1\n&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"_id\":&nbsp;1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"host\":&nbsp;\"192.168.120.24:27018\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"priority\":&nbsp;1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"votes\":&nbsp;1\n&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"_id\":&nbsp;1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"host\":&nbsp;\"192.168.120.24:27019\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"priority\":&nbsp;1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"votes\":&nbsp;1\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;]\n}Select the true statement about this configuration.",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640994,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>To ensure high availability in the event of a server failure, which of the following MongoDB features should you use?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Replication provides redundancy and increases data availability. With multiple copies of data on different database servers, replication provides a level of fault tolerance against the loss of a single database server.</p><p><br></p><p>https://docs.mongodb.com/manual/replication/#replication</p>",
        "answers": [
          "<p>Replication.</p>",
          "<p>Sharding.</p>",
          "<p>Proper storage engine.</p>",
          "<p>Properly defined indexes.</p>",
          "<p>Properly defined views.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "To ensure high availability in the event of a server failure, which of the following MongoDB features should you use?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640996,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>How to connect to MongoDB with <code>mongod</code><em> </em>to localhost running on port 27017? (select 2)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>You can run <code>mongo</code> shell without any command-line options to connect to a MongoDB instance running on your <strong>localhost</strong> with <strong>default port</strong> 27017:</p><p><br></p><pre class=\"prettyprint linenums\">mongo</pre><p><br></p><p>To explicitly specify the port, include the <code>--port</code> command-line option. For example, to connect to a MongoDB instance running on localhost with a non-default port 28015:</p><p><br></p><pre class=\"prettyprint linenums\">mongo --port 28015</pre><p><br></p><p>You can use the command-line option <code>--host &lt;host&gt;:&lt;port&gt;</code>. For example, to connect to a MongoDB instance running on a remote host machine:</p><p><br></p><pre class=\"prettyprint linenums\">mongo --host 127.0.0.1:27017</pre><p><br></p><p>https://docs.mongodb.com/v4.4/mongo/#mongodb-instance-on-a-remote-host</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">mongo --host 127.0.0.1:27017</pre>",
          "<pre class=\"prettyprint linenums\">mongo</pre>",
          "<pre class=\"prettyprint linenums\">mongoconnect --host 127.0.0.1:27017</pre>",
          "<pre class=\"prettyprint linenums\">mongo --host 127.0.0.1:27000</pre>"
        ]
      },
      "correct_response": [
        "a",
        "b"
      ],
      "section": "",
      "question_plain": "How to connect to MongoDB with mongod to localhost running on port 27017? (select 2)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641000,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Complete the following sentence.</p><p><br></p><p>The process by which members of a replica set select a primary on startup and in the event of a failure is called...</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Replica sets use elections to determine which set member will become primary. Replica sets can trigger an election in response to a variety of events, such as:</p><ul><li><p>Adding a new node to the replica set,</p></li><li><p><code>initiating a replica set</code>,</p></li><li><p>performing replica set maintenance using methods such as <code>rs.stepDown()</code> or <code>rs.reconfig()</code>, and</p></li><li><p>the secondary members losing connectivity to the primary for more than the configured <code>timeout</code> (10 seconds by default).</p></li></ul><p><br></p><p>https://www.mongodb.com/docs/manual/core/replica-set-elections/#std-label-replica-set-elections</p>",
        "answers": [
          "<p>...election.</p>",
          "<p>...sharding.</p>",
          "<p>...replication.</p>",
          "<p>...aggregation.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Complete the following sentence.The process by which members of a replica set select a primary on startup and in the event of a failure is called...",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641002,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Complete the following sentence.</p><p><br></p><p>A passive member of a replica set is...</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>A passive member is a member of a replica set that cannot become primary because its <code>members[n].priority</code> is <code>0</code>.</p>",
        "answers": [
          "<p>...a member of a replica set that cannot become <em>primary </em>because its <code>members[n].priority</code> is <code>0</code>.</p>",
          "<p>...a member of a replica set that can become <em>primary </em>because its <code>members[n].priority</code> is <code>0</code>.</p>",
          "<p>...a replica set member that replicates the contents of the master database.</p>",
          "<p>...a replica set member that receives all write operations.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Complete the following sentence.A passive member of a replica set is...",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641004,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Which of the following is not a type of data modeling in MongoDB?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Relational data model -&gt;&nbsp;Correct. Relational data model is not a type of data modeling in MongoDB.</p>",
        "answers": [
          "<p>Embedded data model</p>",
          "<p>Document data model</p>",
          "<p>Key-value data model</p>",
          "<p>Relational data model</p>"
        ]
      },
      "correct_response": [
        "d"
      ],
      "section": "",
      "question_plain": "Which of the following is not a type of data modeling in MongoDB?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641006,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a collection named <code>employees</code> with the following documents:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"employee_id\" : 101,\n   \"name\" : \"John Doe\",\n   \"department\" : \"Marketing\",\n   \"start_date\" : ISODate(\"2019-01-01T00:00:00.000Z\"),\n   \"salary\" : 50000\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e2\"),\n   \"employee_id\" : 102,\n   \"name\" : \"Jane Doe\",\n   \"department\" : \"Sales\",\n   \"start_date\" : ISODate(\"2019-01-01T00:00:00.000Z\"),\n   \"salary\" : 55000\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e3\"),\n   \"employee_id\" : 103,\n   \"name\" : \"Bob Smith\",\n   \"department\" : \"Sales\",\n   \"start_date\" : ISODate(\"2020-01-01T00:00:00.000Z\"),\n   \"salary\" : 60000\n}</pre><p><br></p><p>What is the query to retrieve the average salary for each department in the <code>employees</code> collection?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.aggregate([\n   {\n      $group: {\n         _id: \"$department\",\n         average_salary: { $avg: \"$salary\" }\n      }\n   }\n])</pre><p><br></p><p>The <code>$group</code> stage has the following prototype form:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  $group:\n    {\n      _id: &lt;expression&gt;, // Group key\n      &lt;field1&gt;: { &lt;accumulator1&gt; : &lt;expression1&gt; },\n      ...\n    }\n }</pre><p><br></p><p>https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.employees.aggregate([\n   {\n      $group: {\n         _id: \"$department\",\n         average_salary: { $avg: \"$salary\" }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.aggregate([\n   {\n      $group: {\n         _id: \"department\",\n         average_salary: { $avg: \"salary\" }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.aggregate([\n   {\n      $group: {\n         _id: \"$department\"\n      },\n      $avg: {\n         average_salary: { $avg: \"$salary\" }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.aggregate([\n   {\n      $group: {\n         _id: \"$department\"\n      },\n      $avg: {\n         average_salary: $avg: \"$salary\"\n      }\n   }\n])</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider a collection named employees with the following documents:{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"employee_id\" : 101,\n   \"name\" : \"John Doe\",\n   \"department\" : \"Marketing\",\n   \"start_date\" : ISODate(\"2019-01-01T00:00:00.000Z\"),\n   \"salary\" : 50000\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e2\"),\n   \"employee_id\" : 102,\n   \"name\" : \"Jane Doe\",\n   \"department\" : \"Sales\",\n   \"start_date\" : ISODate(\"2019-01-01T00:00:00.000Z\"),\n   \"salary\" : 55000\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e3\"),\n   \"employee_id\" : 103,\n   \"name\" : \"Bob Smith\",\n   \"department\" : \"Sales\",\n   \"start_date\" : ISODate(\"2020-01-01T00:00:00.000Z\"),\n   \"salary\" : 60000\n}What is the query to retrieve the average salary for each department in the employees collection?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641008,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a collection named <code>orders</code><em> </em>with the following documents:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"order_number\" : 1001,\n   \"customer_id\" : \"CUST-001\",\n   \"order_date\" : ISODate(\"2022-01-01T00:00:00Z\"),\n   \"total_amount\" : 199.99\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e2\"),\n   \"order_number\" : 1002,\n   \"customer_id\" : \"CUST-002\",\n   \"order_date\" : ISODate(\"2022-02-01T00:00:00Z\"),\n   \"total_amount\" : 299.99\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e3\"),\n   \"order_number\" : 1003,\n   \"customer_id\" : \"CUST-003\",\n   \"order_date\" : ISODate(\"2022-03-01T00:00:00Z\"),\n   \"total_amount\" : 399.99\n}</pre><p><br></p><p>What is the query to create a compound index on the <code>\"customer_id\"</code> (ascending) and <code>\"order_date\"</code> (descending) fields in the <code>orders</code><em> </em>collection?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.createIndex({ customer_id: 1, order_date: -1 })</pre><p><br></p><p><code>db.collection.createIndex(keys, options, commitQuorum)</code> - Creates indexes on collections.</p><p>To create a compound index use an operation that resembles the following prototype:</p><p><br></p><pre class=\"prettyprint linenums\">db.collection.createIndex( { &lt;field1&gt;: &lt;type&gt;, &lt;field2&gt;: &lt;type2&gt;, ... } )</pre><p><br></p><p>https://www.mongodb.com/docs/manual/reference/method/db.collection.createIndex/</p><p>https://www.mongodb.com/docs/manual/core/index-compound/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.orders.createIndex({ customer_id: 1, order_date: -1 })</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.createIndex({ customer_id: -1, order_date: 1 })</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.createIndex({ customer_id: asc, order_date: desc })</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.createIndex({ order_date: -1, customer_id: 1 })</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider a collection named orders with the following documents:{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"order_number\" : 1001,\n   \"customer_id\" : \"CUST-001\",\n   \"order_date\" : ISODate(\"2022-01-01T00:00:00Z\"),\n   \"total_amount\" : 199.99\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e2\"),\n   \"order_number\" : 1002,\n   \"customer_id\" : \"CUST-002\",\n   \"order_date\" : ISODate(\"2022-02-01T00:00:00Z\"),\n   \"total_amount\" : 299.99\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e3\"),\n   \"order_number\" : 1003,\n   \"customer_id\" : \"CUST-003\",\n   \"order_date\" : ISODate(\"2022-03-01T00:00:00Z\"),\n   \"total_amount\" : 399.99\n}What is the query to create a compound index on the \"customer_id\" (ascending) and \"order_date\" (descending) fields in the orders collection?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641010,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider the following documents in a MongoDB collection <code>orders</code>:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\": 1,\n   \"customer_id\": 101,\n   \"item\": \"apple\",\n   \"price\": 0.5,\n   \"quantity\": 100,\n   \"date\": ISODate(\"2022-01-01T00:00:00Z\")\n},\n{\n   \"_id\": 2,\n   \"customer_id\": 102,\n   \"item\": \"banana\",\n   \"price\": 0.25,\n   \"quantity\": 50,\n   \"date\": ISODate(\"2022-01-02T00:00:00Z\")\n},\n{\n   \"_id\": 3,\n   \"customer_id\": 101,\n   \"item\": \"orange\",\n   \"price\": 0.75,\n   \"quantity\": 75,\n   \"date\": ISODate(\"2022-01-03T00:00:00Z\")\n}</pre><p><br></p><p>What is the aggregation pipeline to group the documents by <code>\"customer_id\"</code> and calculate the sum of the <code>\"quantity\"</code> field for each group, sorted in descending order by the sum of the <code>\"quantity\"</code> field?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.aggregate([\n  { $group: { _id: \"$customer_id\", total_quantity: { $sum: \"$quantity\" } } },\n  { $sort: { total_quantity: -1 } }\n])</pre><p><br></p><p>The <code>$group</code> stage separates documents into groups according to a \"group key\". The output is one document for each unique group key. A group key is often a field, or group of fields. The group key can also be the result of an expression. Use the <code>_id</code> field in the <code>$group</code> pipeline stage to set the group key. In the <code>$group</code> stage output, the <code>_id</code> field is set to the group key for that document.</p><p>The <code>$group</code> stage has the following prototype form:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  $group:\n    {\n      _id: &lt;expression&gt;, // Group key\n      &lt;field1&gt;: { &lt;accumulator1&gt; : &lt;expression1&gt; },\n      ...\n    }\n }</pre><p><br></p><p><code>$sort</code> sorts all input documents and returns them to the pipeline in sorted order. The <code>$sort</code> stage has the following prototype form:</p><p><br></p><pre class=\"prettyprint linenums\">{ $sort: { &lt;field1&gt;: &lt;sort order&gt;, &lt;field2&gt;: &lt;sort order&gt; ... } }</pre><p><br></p><p>https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/</p><p>https://www.mongodb.com/docs/manual/reference/operator/aggregation/sort/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n  { $group: { _id: \"$customer_id\", total_quantity: { $sum: \"$quantity\" } } },\n  { $sort: { total_quantity: -1 } }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n  {\n    $groupBy: { customer_id: \"$customer_id\" },\n    total_quantity: { $sum: \"$quantity\" }\n  },\n  { $sort: { total_quantity: 1 } }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.runCommand({\n  aggregate: \"orders\",\n  group: { _id: \"$customer_id\", total_quantity: { $sum: \"$quantity\" } },\n  sort: { total_quantity: -1 }\n})</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n  { $group: { _id: \"$customer_id\", total_quantity: { $sum: \"$quantity\" } } },\n  { $sort: { total_quantity: 1 } }\n])</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider the following documents in a MongoDB collection orders:{\n   \"_id\": 1,\n   \"customer_id\": 101,\n   \"item\": \"apple\",\n   \"price\": 0.5,\n   \"quantity\": 100,\n   \"date\": ISODate(\"2022-01-01T00:00:00Z\")\n},\n{\n   \"_id\": 2,\n   \"customer_id\": 102,\n   \"item\": \"banana\",\n   \"price\": 0.25,\n   \"quantity\": 50,\n   \"date\": ISODate(\"2022-01-02T00:00:00Z\")\n},\n{\n   \"_id\": 3,\n   \"customer_id\": 101,\n   \"item\": \"orange\",\n   \"price\": 0.75,\n   \"quantity\": 75,\n   \"date\": ISODate(\"2022-01-03T00:00:00Z\")\n}What is the aggregation pipeline to group the documents by \"customer_id\" and calculate the sum of the \"quantity\" field for each group, sorted in descending order by the sum of the \"quantity\" field?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641012,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider the following documents in a MongoDB collection <code>employees</code>:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\": 1,\n   \"name\": \"John Doe\",\n   \"department\": \"Sales\",\n   \"salary\": 50000,\n   \"start_date\": ISODate(\"2020-01-01T00:00:00Z\")\n},\n{\n   \"_id\": 2,\n   \"name\": \"Jane Doe\",\n   \"department\": \"Marketing\",\n   \"salary\": 60000,\n   \"start_date\": ISODate(\"2021-01-01T00:00:00Z\")\n},\n{\n   \"_id\": 3,\n   \"name\": \"Bob Smith\",\n   \"department\": \"Engineering\",\n   \"salary\": 65000,\n   \"start_date\": ISODate(\"2022-01-01T00:00:00Z\")\n}</pre><p><br></p><p>What is the aggregation pipeline to find the average salary of employees hired in the year 2021, rounded to the nearest integer?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.aggregate([\n  {\n    $match: {\n      start_date: {\n        $gte: ISODate(\"2021-01-01T00:00:00Z\"),\n        $lt: ISODate(\"2022-01-01T00:00:00Z\")\n      }\n    }\n  },\n  { $group: { _id: null, average_salary: { $avg: \"$salary\" } } },\n  { $project: { average_salary: { $round: [\"$average_salary\"] } } }\n])</pre><p><br></p><p><code>$match</code> - Filters the documents to pass only the documents that match the specified condition(s) to the next pipeline stage. The <code>$match</code> stage has the following prototype form:</p><p><br></p><pre class=\"prettyprint linenums\">{ $match: { &lt;query&gt; } }</pre><p><br></p><p><code>$project</code> - Passes along the documents with the requested fields to the next stage in the pipeline. The specified fields can be existing fields from the input documents or newly computed fields. The <code>$project</code> stage has the following prototype form:</p><p><br></p><pre class=\"prettyprint linenums\">{ $project: { &lt;specification(s)&gt; } }</pre><p><br></p><p>https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/</p><p>https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.employees.aggregate([\n  {\n    $match: {\n      start_date: {\n        $gte: ISODate(\"2021-01-01T00:00:00Z\"),\n        $lt: ISODate(\"2022-01-01T00:00:00Z\")\n      }\n    }\n  },\n  { $group: { _id: null, average_salary: { $avg: \"$salary\" } } },\n  { $project: { average_salary: { $round: [\"$average_salary\"] } } }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.aggregate([\n  {\n    $match: {\n      start_date: {\n        $gt: ISODate(\"2020-12-31T00:00:00Z\"),\n        $lt: ISODate(\"2022-01-01T00:00:00Z\")\n      }\n    }\n  },\n  { $group: { _id: null, average_salary: { $avg: \"$salary\" } } },\n  { $round: { average_salary: 0 } }\n])\n</pre>",
          "<pre class=\"prettyprint linenums\">db.runCommand({\n  aggregate: \"employees\",\n  match: {\n    start_date: { $gte: \"2021-01-01T00:00:00Z\", $lt: \"2022-01-01T00:00:00Z\" }\n  },\n  group: { _id: null, average_salary: { $avg: \"$salary\" } },\n  project: { average_salary: { $round: [\"$average_salary\"] } }\n})</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.aggregate([\n  {\n    $match: {\n      start_date: {\n        $gte: ISODate(\"2021-01-01T00:00:00Z\"),\n        $lt: ISODate(\"2022-01-01T00:00:00Z\")\n      }\n    }\n  },\n  { $group: { _id: null, average_salary: { $avg: \"$salary\" } } },\n  { $project: { average_salary: \"$average_salary\" } }\n])</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider the following documents in a MongoDB collection employees:{\n   \"_id\": 1,\n   \"name\": \"John Doe\",\n   \"department\": \"Sales\",\n   \"salary\": 50000,\n   \"start_date\": ISODate(\"2020-01-01T00:00:00Z\")\n},\n{\n   \"_id\": 2,\n   \"name\": \"Jane Doe\",\n   \"department\": \"Marketing\",\n   \"salary\": 60000,\n   \"start_date\": ISODate(\"2021-01-01T00:00:00Z\")\n},\n{\n   \"_id\": 3,\n   \"name\": \"Bob Smith\",\n   \"department\": \"Engineering\",\n   \"salary\": 65000,\n   \"start_date\": ISODate(\"2022-01-01T00:00:00Z\")\n}What is the aggregation pipeline to find the average salary of employees hired in the year 2021, rounded to the nearest integer?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641014,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider the following MongoDB collection <code>students</code>:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\": 1,\n   \"name\": \"John Doe\",\n   \"age\": 25,\n   \"class\": \"A\"\n},\n{\n   \"_id\": 2,\n   \"name\": \"Jane Doe\",\n   \"age\": 22,\n   \"class\": \"B\"\n},\n{\n   \"_id\": 3,\n   \"name\": \"Jim Smith\",\n   \"age\": 24,\n   \"class\": \"A\"\n}</pre><p><br></p><p>What is the query to find the average age of all students in class <code>\"A\"</code>?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.students.aggregate([\n  { $match: { class: \"A\" } },\n  { $group: { _id: null, avg_age: { $avg: \"$age\" } } }\n])</pre>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.students.find({class: \"A\"}).avg(\"age\") </pre>",
          "<pre class=\"prettyprint linenums\">db.students.aggregate([\n  { $match: { class: \"A\" } },\n  { $group: { _id: null, avg_age: { $avg: \"$age\" } } }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.students.find({class: \"A\"}).mean(\"age\")</pre>",
          "<pre class=\"prettyprint linenums\">db.students.aggregate([\n  { $match: { class: \"A\" } },\n  { $group: { _id: \"$class\", avg_age: { $avg: \"$age\" } } }\n])</pre>"
        ]
      },
      "correct_response": [
        "b"
      ],
      "section": "",
      "question_plain": "Consider the following MongoDB collection students:{\n   \"_id\": 1,\n   \"name\": \"John Doe\",\n   \"age\": 25,\n   \"class\": \"A\"\n},\n{\n   \"_id\": 2,\n   \"name\": \"Jane Doe\",\n   \"age\": 22,\n   \"class\": \"B\"\n},\n{\n   \"_id\": 3,\n   \"name\": \"Jim Smith\",\n   \"age\": 24,\n   \"class\": \"A\"\n}What is the query to find the average age of all students in class \"A\"?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641016,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a MongoDB database containing a collection of documents representing product information for an e-commerce website. The documents have the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\": ObjectId(\"5f95a1d11a12b400001b75c0\"),\n   \"product_name\": \"Smartphone\",\n   \"brand\": \"Apple\",\n   \"price\": 800,\n   \"categories\": [ \"Electronics\", \"Smartphones\" ],\n   \"reviews\": [\n      { \"username\": \"user1\", \"rating\": 4, \"comment\": \"Great product!\" },\n      { \"username\": \"user2\", \"rating\": 5, \"comment\": \"Excellent!\" },\n      { \"username\": \"user3\", \"rating\": 3, \"comment\": \"Good but overpriced.\" }\n   ]\n}</pre><p><br></p><p>Write a MongoDB aggregation pipeline that returns the average rating of all products grouped by brand, as well as the number of reviews for each brand. The result should include only brands with an average rating greater than or equal to 4 and at least 2 reviews. The output should have the following format:</p><p><br></p><pre class=\"prettyprint linenums\">{ \"brand\": \"Apple\", \"avg_rating\": 4.33, \"review_count\": 3 }</pre><p><br></p><p>Select the pipeline in the correct JSON format.</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct pipeline:</p><p><br></p><pre class=\"prettyprint linenums\">[\n   {\n      \"$unwind\": \"$reviews\"\n   },\n   {\n      \"$group\": {\n         \"_id\": \"$brand\",\n         \"avg_rating\": { \"$avg\": \"$reviews.rating\" },\n         \"review_count\": { \"$sum\": 1 }\n      }\n   },\n   {\n      \"$match\": {\n         \"avg_rating\": { \"$gte\": 4 },\n         \"review_count\": { \"$gte\": 2 }\n      }\n   },\n   {\n      \"$project\": {\n         \"brand\": \"$_id\",\n         \"avg_rating\": \"$avg_rating\",\n         \"review_count\": \"$review_count\",\n         \"_id\": 0\n      }\n   }\n]</pre><p><br></p><ol><li><p>The first stage of the pipeline <code><strong>$unwind</strong></code>s the <code><strong>reviews</strong></code> array, which means each document will be split into multiple documents, one for each review.</p></li><li><p>The second stage <code><strong>$group</strong></code>s the documents by brand using the <code><strong>_id</strong></code> field, and calculates the average rating using the <code><strong>$avg</strong></code> operator on the <code><strong>reviews.rating</strong></code> field, as well as the number of reviews for each brand using the <code><strong>$sum</strong></code> operator with a value of 1.</p></li><li><p>The third stage <code><strong>$match</strong></code>es only the brands with an average rating greater than or equal to 4 and at least 2 reviews.</p></li><li><p>The final stage <code><strong>$project</strong></code>s the final output format, including only the <code><strong>brand</strong></code>, <code><strong>avg_rating</strong></code>, and <code><strong>review_count</strong></code> fields, and omitting the <code><strong>_id</strong></code> field.</p></li></ol>",
        "answers": [
          "<pre class=\"prettyprint linenums\">[\n   {\n      \"$unwind\": \"$reviews\"\n   },\n   {\n      \"$group\": {\n         \"_id\": \"$brand\",\n         \"avg_rating\": { \"$avg\": \"$reviews.rating\" },\n         \"review_count\": { \"$sum\": 1 }\n      }\n   },\n   {\n      \"$match\": {\n         \"avg_rating\": { \"$gte\": 4 },\n         \"review_count\": { \"$gte\": 2 }\n      }\n   },\n   {\n      \"$project\": {\n         \"brand\": \"$_id\",\n         \"avg_rating\": \"$avg_rating\",\n         \"review_count\": \"$review_count\",\n         \"_id\": 0\n      }\n   }\n]</pre>",
          "<pre class=\"prettyprint linenums\">[\n   {\n      \"$group\": {\n         \"_id\": \"$brand\",\n         \"avg_rating\": { \"$avg\": \"$reviews.rating\" },\n         \"review_count\": { \"$sum\": 1 }\n      }\n   },\n   {\n      \"$match\": {\n         \"avg_rating\": { \"$gte\": 4 },\n         \"review_count\": { \"$gte\": 2 }\n      }\n   },\n   {\n      \"$project\": {\n         \"brand\": \"$_id\",\n         \"avg_rating\": \"$avg_rating\",\n         \"review_count\": \"$review_count\",\n         \"_id\": 0\n      }\n   }\n]</pre>",
          "<pre class=\"prettyprint linenums\">[\n   {\n      \"$unwind\": \"$reviews\"\n   },\n   {\n      \"$group\": {\n         \"_id\": \"$brand\",\n         \"avg_rating\": { \"$avg\": \"$reviews.rating\" },\n         \"review_count\": { \"$sum\": 1 }\n      }\n   },\n   {\n      \"$project\": {\n         \"brand\": \"$_id\",\n         \"avg_rating\": \"$avg_rating\",\n         \"review_count\": \"$review_count\",\n         \"_id\": 0\n      }\n   }\n]</pre>",
          "<pre class=\"prettyprint linenums\">[\n   {\n      \"$unwind\": \"$reviews\"\n   },\n   {\n      \"$match\": {\n         \"avg_rating\": { \"$gte\": 4 },\n         \"review_count\": { \"$gte\": 2 }\n      }\n   },\n   {\n      \"$project\": {\n         \"brand\": \"$_id\",\n         \"avg_rating\": \"$avg_rating\",\n         \"review_count\": \"$review_count\",\n         \"_id\": 0\n      }\n   }\n]</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider a MongoDB database containing a collection of documents representing product information for an e-commerce website. The documents have the following structure:{\n   \"_id\": ObjectId(\"5f95a1d11a12b400001b75c0\"),\n   \"product_name\": \"Smartphone\",\n   \"brand\": \"Apple\",\n   \"price\": 800,\n   \"categories\": [ \"Electronics\", \"Smartphones\" ],\n   \"reviews\": [\n      { \"username\": \"user1\", \"rating\": 4, \"comment\": \"Great product!\" },\n      { \"username\": \"user2\", \"rating\": 5, \"comment\": \"Excellent!\" },\n      { \"username\": \"user3\", \"rating\": 3, \"comment\": \"Good but overpriced.\" }\n   ]\n}Write a MongoDB aggregation pipeline that returns the average rating of all products grouped by brand, as well as the number of reviews for each brand. The result should include only brands with an average rating greater than or equal to 4 and at least 2 reviews. The output should have the following format:{ \"brand\": \"Apple\", \"avg_rating\": 4.33, \"review_count\": 3 }Select the pipeline in the correct JSON format.",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641018,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the role of the oplog in MongoDB replication?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>To act as a log of all operations performed on the primary node -&gt; Correct. The oplog (operations log) in MongoDB replication acts as a log of all operations performed on the primary node. This log is used by secondary nodes to keep their data in sync with the primary node. The secondary nodes continually monitor the oplog and apply any operations from the log to their own copy of the database to maintain consistency across all nodes in the replica set.</p>",
        "answers": [
          "<p>To store a copy of the entire database</p>",
          "<p>To store a copy of the database schema</p>",
          "<p>To act as a buffer for writes to the primary node</p>",
          "<p>To act as a log of all operations performed on the primary node</p>"
        ]
      },
      "correct_response": [
        "d"
      ],
      "section": "",
      "question_plain": "What is the role of the oplog in MongoDB replication?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641020,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a MongoDB collection named <code>students</code> with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    \"_id\" : ObjectId(\"5f7f39d8dbdfgbcabcabcabc\"),\n    \"student_id\" : \"S001\",\n    \"student_name\" : \"John Doe\",\n    \"courses\" : [\n        {\n            \"course_id\" : \"C001\",\n            \"course_name\" : \"Introduction to MongoDB\",\n            \"score\" : 80\n        },\n        {\n            \"course_id\" : \"C002\",\n            \"course_name\" : \"Advanced MongoDB\",\n            \"score\" : 90\n        }\n    ]\n}</pre><p><br></p><p>You are required to find all students who scored more than 85 in the course \"Introduction to MongoDB\". Which of the following queries would perform the most efficient search?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct answer:</p><p><br></p><pre class=\"prettyprint linenums\">db.students.find({\n    \"courses\": {\n        $elemMatch: {\n            \"course_id\": \"C001\",\n            \"score\": { $gt: 85 }\n        }\n    }\n});</pre><p><br></p><p>This option performs a collection scan and uses the $elemMatch operator to match the course_id and score fields in the embedded documents, which is the most efficient way to perform the search for this requirement.</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.students.find({\n    \"courses.course_id\": \"C001\",\n    \"courses.score\": { $gt: 85 }\n});</pre>",
          "<pre class=\"prettyprint linenums\">db.students.find({\n    \"courses\": {\n        $elemMatch: {\n            \"course_id\": \"C001\",\n            \"score\": { $gt: 85 }\n        }\n    }\n});</pre>",
          "<pre class=\"prettyprint linenums\">db.students.aggregate([\n    { $unwind: \"$courses\" },\n    { $match: { \"courses.course_id\": \"C001\", \"courses.score\": { $gt: 85 } } },\n    { $group: { _id: \"$student_id\", student_name: { $first: \"$student_name\" }, courses: { $push: \"$courses\" } } },\n    { $project: { _id: 0, student_id: \"$_id\", student_name: 1, courses: 1 } }\n]);</pre>",
          "<pre class=\"prettyprint linenums\">db.students.aggregate([\n    { $match: { \"courses.course_id\": \"C001\", \"courses.score\": { $gt: 85 } } },\n    { $unwind: \"$courses\" },\n    { $match: { \"courses.course_id\": \"C001\", \"courses.score\": { $gt: 85 } } },\n    { $group: { _id: \"$student_id\", student_name: { $first: \"$student_name\" }, courses: { $push: \"$courses\" } } },\n    { $project: { _id: 0, student_id: \"$_id\", student_name: 1, courses: 1 } }\n]);</pre>"
        ]
      },
      "correct_response": [
        "b"
      ],
      "section": "",
      "question_plain": "Consider a MongoDB collection named students with the following document structure:{\n    \"_id\" : ObjectId(\"5f7f39d8dbdfgbcabcabcabc\"),\n    \"student_id\" : \"S001\",\n    \"student_name\" : \"John Doe\",\n    \"courses\" : [\n        {\n            \"course_id\" : \"C001\",\n            \"course_name\" : \"Introduction to MongoDB\",\n            \"score\" : 80\n        },\n        {\n            \"course_id\" : \"C002\",\n            \"course_name\" : \"Advanced MongoDB\",\n            \"score\" : 90\n        }\n    ]\n}You are required to find all students who scored more than 85 in the course \"Introduction to MongoDB\". Which of the following queries would perform the most efficient search?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641022,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>You are designing a MongoDB database for a real estate company. The company needs to store information about properties, their owners, and the agents responsible for selling the properties. Which of the following data models would best fit this requirement?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>One collection for properties, one collection for owners, and one collection for agents, with each property document containing a reference to the owner and the agent responsible for selling the property. -&gt; Correct. This option separates the information about the properties, owners, and agents into separate collections, with each property document containing a reference to the owner and the agent responsible for selling the property. This allows for efficient retrieval of information about a specific property and the entities associated with it, as well as efficient updates to the information about the properties, owners, and agents.</p><p><br></p><p>One collection for properties, with each property document containing an array of references to the owners and the agents responsible for selling the property. -&gt; Incorrect.&nbsp; This option stores the information about the owners and agents responsible for selling the property in an array within the property document, which can lead to performance issues as the arrays grow in size and complexity.</p><p><br></p><p>One collection for properties, with each property document containing embedded documents for the owners and the agents responsible for selling the property. -&gt; Inorrect. This option stores all information about the properties, owners, and agents in a single document, which can lead to performance issues as the documents grow in size and complexity. It also makes it more difficult to update individual entities as the entire document would need to be updated in order to change any single piece of information.</p><p><br></p><p>One collection for properties, one collection for owners, and one collection for agents, with each owner document containing an array of references to the properties they own, and each agent document containing an array of references to the properties they are responsible for selling. -&gt; Incorrect. This option stores the information about the relationships between properties, owners, and agents as arrays of references within each entity's document, which can lead to performance issues when retrieving information about a specific property and the entities associated with it, as multiple queries would be required.</p>",
        "answers": [
          "<p>One collection for properties, with each property document containing an array of references to the owners and the agents responsible for selling the property.</p>",
          "<p>One collection for properties, one collection for owners, and one collection for agents, with each property document containing a reference to the owner and the agent responsible for selling the property.</p>",
          "<p>One collection for properties, with each property document containing embedded documents for the owners and the agents responsible for selling the property.</p>",
          "<p>One collection for properties, one collection for owners, and one collection for agents, with each owner document containing an array of references to the properties they own, and each agent document containing an array of references to the properties they are responsible for selling.</p>"
        ]
      },
      "correct_response": [
        "b"
      ],
      "section": "",
      "question_plain": "You are designing a MongoDB database for a real estate company. The company needs to store information about properties, their owners, and the agents responsible for selling the properties. Which of the following data models would best fit this requirement?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641024,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a collection named <code>employees</code> that contains documents in the following format:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\" : ObjectId(\"5f5f95aae2e85f9e7b33be5a\"),\n   \"employee_id\" : \"E001\",\n   \"name\" : \"John Doe\",\n   \"department\" : \"Sales\",\n   \"salary\" : 50000,\n   \"join_date\" : ISODate(\"2022-01-01T08:00:00Z\")\n}</pre><p><br></p><p>How can you calculate the average salary for each department, and only return departments with an average salary greater than $55,000 using the MongoDB aggregation framework?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct answer:</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.aggregate([\n  { $group: { _id: \"$department\", avgSalary: { $avg: \"$salary\" } } },\n  { $match: { avgSalary: { $gt: 55000 } } }\n])</pre><p><br></p><p>The correct pipeline first groups the documents by the <code>\"department\"</code> field and calculates the average salary for each department using the <code>$avg</code> operator. It then filters the result set to only include departments with an average salary greater than $55,000 using the <code>$match</code> stage. </p><p><br></p><pre class=\"prettyprint linenums\">db.employees.aggregate(\n  [{ $group: { _id: \"$department\", avgSalary: { $avg: \"$salary\" } } }],\n  { $match: { avgSalary: { $gt: 55000 } } }\n)</pre><p><br></p><p>This option has the <code>$match</code> stage placed before the <code>$group</code> stage, which would result in an error. </p><p><br></p><pre class=\"prettyprint linenums\">db.employees.aggregate([\n  { $match: { salary: { $gt: 55000 } } },\n  { $group: { _id: \"$department\", avgSalary: { $avg: \"$salary\" } } }\n])</pre><p><br></p><p>This option filters the documents before grouping them, which would result in an incorrect calculation of the average salary. </p><p><br></p><pre class=\"prettyprint linenums\">db.employees.aggregate([\n  { $match: { salary: { $gt: 55000 } } },\n  { $group: { _id: \"$department\", avgSalary: { $sum: \"$salary\" } } }\n])</pre><p><br></p><p>This option calculates the sum of the <code>\"salary\"</code> field instead of the average, which would also result in an incorrect calculation.</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.employees.aggregate(\n  [{ $group: { _id: \"$department\", avgSalary: { $avg: \"$salary\" } } }],\n  { $match: { avgSalary: { $gt: 55000 } } }\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.aggregate([\n  { $group: { _id: \"$department\", avgSalary: { $avg: \"$salary\" } } },\n  { $match: { avgSalary: { $gt: 55000 } } }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.aggregate([\n  { $match: { salary: { $gt: 55000 } } },\n  { $group: { _id: \"$department\", avgSalary: { $avg: \"$salary\" } } }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.aggregate([\n  { $match: { salary: { $gt: 55000 } } },\n  { $group: { _id: \"$department\", avgSalary: { $sum: \"$salary\" } } }\n])</pre>"
        ]
      },
      "correct_response": [
        "b"
      ],
      "section": "",
      "question_plain": "Consider a collection named employees that contains documents in the following format:{\n   \"_id\" : ObjectId(\"5f5f95aae2e85f9e7b33be5a\"),\n   \"employee_id\" : \"E001\",\n   \"name\" : \"John Doe\",\n   \"department\" : \"Sales\",\n   \"salary\" : 50000,\n   \"join_date\" : ISODate(\"2022-01-01T08:00:00Z\")\n}How can you calculate the average salary for each department, and only return departments with an average salary greater than $55,000 using the MongoDB aggregation framework?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641026,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>How would you insert multiple documents into a MongoDB collection named <code>orders</code>?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.insert([\n  { product: \"Book\", quantity: 3 },\n  { product: \"Pen\", quantity: 5 }\n])</pre><p><br></p><p>In MongoDB, to insert multiple documents into a collection, you can use the <code>insert()</code> method on the collection object and pass an array of documents as the argument. The syntax would be <code>db.collection_name.insert([{ document1 }, { document2 }, ..., { documentN }])</code> where <code>collection_name</code> is the name of the collection you want to insert into and each <code>{ document }</code> is a document you want to insert represented as a JavaScript object.</p><p><br></p><pre class=\"prettyprint linenums\">db.orders({ product: \"Book\", quantity: 3 }, { product: \"Pen\", quantity: 5 })</pre><p><br></p><p>It does not include the <code>insert()</code> method.</p><p><br></p><pre class=\"prettyprint linenums\">orders.insert([\n  { product: \"Book\", quantity: 3 },\n  { product: \"Pen\", quantity: 5 }\n])</pre><p><br></p><p>It does not include the <code>db</code> prefix which is necessary to specify the database.</p><p><br></p><pre class=\"prettyprint linenums\">db.insert(\n  [\n    { product: \"Book\", quantity: 3 },\n    { product: \"Pen\", quantity: 5 }\n  ],\n  \"orders\"\n)</pre><p><br></p><p>It does not include the collection name in the correct place.</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.orders.insert([\n  { product: \"Book\", quantity: 3 },\n  { product: \"Pen\", quantity: 5 }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.orders({ product: \"Book\", quantity: 3 }, { product: \"Pen\", quantity: 5 })</pre>",
          "<pre class=\"prettyprint linenums\">orders.insert([\n  { product: \"Book\", quantity: 3 },\n  { product: \"Pen\", quantity: 5 }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.insert(\n  [\n    { product: \"Book\", quantity: 3 },\n    { product: \"Pen\", quantity: 5 }\n  ],\n  \"orders\"\n)</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "How would you insert multiple documents into a MongoDB collection named orders?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641028,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the correct syntax to insert a new document into a MongoDB collection named <code>employees</code> and return the <code>_id</code> of the inserted document?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct answer:</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.insert({ name: \"Jane Doe\", position: \"Manager\" })._id</pre><p><br></p><p>In MongoDB, to return the <code>_id</code> of the inserted document, you can chain the <code>_id</code> property to the result of the <code>insert()</code> method. The syntax would be <code>db.collection_name.insert({ document })._id</code> where <code>collection_name</code> is the name of the collection you want to insert into and <code>{ document }</code> is the document you want to insert represented as a JavaScript object.</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.insert(\n  { name: \"Jane Doe\", position: \"Manager\" },\n  { returnId: true }\n)</pre><p><br></p><p><code>returnId</code> is not a valid option for the <code>insert()</code> method.</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.insert({ name: \"Jane Doe\", position: \"Manager\" }).returnId</pre><p><br></p><p><code>returnId</code> is not a property of the result of the <code>insert()</code> method.</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.insert(\n   { name: \"Jane Doe\", position: \"Manager\" }, \n   { getId: true }\n)</pre><p><br></p><p><code>getId</code> is not a valid option for the <code>insert()</code> method.</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.employees.insert(\n  { name: \"Jane Doe\", position: \"Manager\" },\n  { returnId: true }\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.insert({ name: \"Jane Doe\", position: \"Manager\" }).returnId</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.insert({ name: \"Jane Doe\", position: \"Manager\" })._id</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.insert(\n   { name: \"Jane Doe\", position: \"Manager\" }, \n   { getId: true }\n)</pre>"
        ]
      },
      "correct_response": [
        "c"
      ],
      "section": "",
      "question_plain": "What is the correct syntax to insert a new document into a MongoDB collection named employees and return the _id of the inserted document?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641030,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the correct syntax to update all documents in a MongoDB collection named <code>employees</code> that have a <code>\"position\"</code> field equal to <code>\"Manager\"</code> to change the value of <code>\"position\"</code> to <code>\"Team Lead\"</code>?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct answer:</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.updateMany(\n  { position: \"Manager\" },\n  { $set: { position: \"Team Lead\" } }\n)</pre><p><br></p><p>In MongoDB, to update all documents that match a certain criteria, you can use the <code>updateMany()</code> method. The syntax would be <code>db.collection_name.updateMany({ filter }, { update })</code> where <code>collection_name</code> is the name of the collection you want to update, <code>{ filter }</code> is the criteria to match the documents you want to update, and <code>{ update }</code> is the update to apply to the matched documents.</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.update(\n  { position: \"Manager\" },\n  { $set: { position: \"Team Lead\" } }\n)</pre><p><br></p><p><code>update()</code> is a method for updating a single document, not multiple documents.</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.updateMany(\n  { position: \"Manager\" }, \n  [ { $set: { position: \"Team Lead\" } } ]\n)</pre><p><br></p><p>The update must be a single JavaScript object, not an array.</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.update(\n  { position: \"Manager\" }, \n  [ { $set: { position: \"Team Lead\" } } ]\n)</pre><p><br></p><p><code>update()</code> is a method for updating a single document, not multiple documents.</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.employees.updateMany(\n  { position: \"Manager\" },\n  { $set: { position: \"Team Lead\" } }\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.update(\n  { position: \"Manager\" },\n  { $set: { position: \"Team Lead\" } }\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.updateMany(\n  { position: \"Manager\" }, \n  [ { $set: { position: \"Team Lead\" } } ]\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.update(\n  { position: \"Manager\" }, \n  [ { $set: { position: \"Team Lead\" } } ]\n)</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is the correct syntax to update all documents in a MongoDB collection named employees that have a \"position\" field equal to \"Manager\" to change the value of \"position\" to \"Team Lead\"?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641032,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a MongoDB collection named <code>customers</code> which has documents in the following format:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    \"_id\" : ObjectId(\"5f5b0d2f3e3dfbcc11c84444\"),\n    \"customerId\" : 101,\n    \"name\" : \"John Smith\",\n    \"age\" : 35,\n    \"city\" : \"New York\",\n    \"purchases\" : [\n        {\n            \"date\" : ISODate(\"2022-01-01T00:00:00.000Z\"),\n            \"amount\" : 500\n        },\n        {\n            \"date\" : ISODate(\"2022-02-01T00:00:00.000Z\"),\n            \"amount\" : 300\n        }\n    ]\n}</pre><p><br></p><p>What is the correct output for the following query in the <code>customers</code> collection?</p><p><br></p><pre class=\"prettyprint linenums\">db.customers\n  .find({ city: \"New York\" })\n  .sort({ \"purchases.amount\": -1 })\n  .limit(3)</pre><p><br></p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The 3 customers from New York who have made the highest total purchases, in descending order of purchase amount. -&gt;&nbsp;Correct. </p><p>The query first filters the <code>customers</code> collection based on the <code>\"city\"</code> field being equal to <code>\"New York\"</code> using the <code>find</code> method. Then it performs a sort operation using the <code>sort</code> method, where the total amount of purchases are sorted in descending order (<code>{'purchases.amount': -1}</code>). Finally, the <code>limit</code> method limits the number of documents returned to 3. Therefore, the query returns the 3 customers from New York who have made the highest total purchases, in descending order of purchase amount.</p>",
        "answers": [
          "<p>The 3 customers from New York who have made the highest total purchases, in descending order of purchase amount.</p>",
          "<p>The 3 customers from New York who have made the lowest total purchases, in ascending order of purchase amount.</p>",
          "<p>The 3 customers from New York who have made the highest total purchases, in ascending order of purchase amount.</p>",
          "<p>The 3 customers from New York who have made the lowest total purchases, in descending order of purchase amount.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider a MongoDB collection named customers which has documents in the following format:{\n    \"_id\" : ObjectId(\"5f5b0d2f3e3dfbcc11c84444\"),\n    \"customerId\" : 101,\n    \"name\" : \"John Smith\",\n    \"age\" : 35,\n    \"city\" : \"New York\",\n    \"purchases\" : [\n        {\n            \"date\" : ISODate(\"2022-01-01T00:00:00.000Z\"),\n            \"amount\" : 500\n        },\n        {\n            \"date\" : ISODate(\"2022-02-01T00:00:00.000Z\"),\n            \"amount\" : 300\n        }\n    ]\n}What is the correct output for the following query in the customers collection?db.customers\n  .find({ city: \"New York\" })\n  .sort({ \"purchases.amount\": -1 })\n  .limit(3)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641034,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Which of the following is considered an anti-pattern in MongoDB data modeling for transactional data?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Denormalizing data to reduce the number of update operations required to update related data. -&gt;&nbsp;Correct. This is considered an anti-pattern in MongoDB data modeling for transactional data because it can lead to inconsistencies in the data and can make it difficult to maintain the integrity of the data. When data is denormalized, updates to related data must be made in multiple places, which can increase the chances of data inconsistency. Additionally, denormalizing data can make it more difficult to maintain the relationships between entities, making it harder to retrieve related data and make updates as needed.</p>",
        "answers": [
          "<p>Using an atomic update operation to ensure consistency of data across multiple updates.</p>",
          "<p>Using a single collection to store all transactional data.</p>",
          "<p>Using references to model relationships between transactional entities.</p>",
          "<p>Denormalizing data to reduce the number of update operations required to update related data.</p>"
        ]
      },
      "correct_response": [
        "d"
      ],
      "section": "",
      "question_plain": "Which of the following is considered an anti-pattern in MongoDB data modeling for transactional data?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641036,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Which of the following is considered an anti-pattern in MongoDB data modeling for geospatial data?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Storing geospatial data as strings instead of as geospatial data types. -&gt;&nbsp;Correct. This is considered an anti-pattern in MongoDB data modeling for geospatial data because it can lead to decreased performance for geospatial queries and reduced functionality for geospatial data operations. When geospatial data is stored as strings, MongoDB must parse the strings into geospatial data types in order to perform geospatial operations, which can lead to slower query performance. Additionally, storing geospatial data as strings can limit the functionality of geospatial data operations, as some geospatial operations may not be supported for string data types.</p>",
        "answers": [
          "<p>Using 2D spherical indexes to support geospatial queries.</p>",
          "<p>Using embedded documents to model relationships between geospatial entities.</p>",
          "<p>Overusing the <code>$geoWithin</code> operator in geospatial queries to retrieve data.</p>",
          "<p>Storing geospatial data as strings instead of as geospatial data types.</p>"
        ]
      },
      "correct_response": [
        "d"
      ],
      "section": "",
      "question_plain": "Which of the following is considered an anti-pattern in MongoDB data modeling for geospatial data?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641038,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Which of the following is considered an anti-pattern in MongoDB data modeling for hierarchical data?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Using a flat collection to store hierarchical data. -&gt; Correct. This is considered an anti-pattern in MongoDB data modeling for hierarchical data because it can lead to increased query complexity and decreased performance for hierarchical data queries. When hierarchical data is stored in a flat collection, it can be difficult to retrieve the data in a hierarchical format, as queries may need to perform multiple joins in order to retrieve related data. Additionally, flat collections can lead to data duplication and data bloat, which can impact storage efficiency and query performance.</p>",
        "answers": [
          "<p>Using embedded documents to model relationships between hierarchical entities.</p>",
          "<p>Using references to model relationships between hierarchical entities.</p>",
          "<p>Overusing the <code>$lookup</code> operator in hierarchical data queries.</p>",
          "<p>Using a flat collection to store hierarchical data.</p>"
        ]
      },
      "correct_response": [
        "d"
      ],
      "section": "",
      "question_plain": "Which of the following is considered an anti-pattern in MongoDB data modeling for hierarchical data?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641040,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the best practice for backing up data in MongoDB in a production environment?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Use a replica set and take a backup of a secondary node. -&gt; Correct. This is considered the best practice for backing up data in a production environment in MongoDB because it provides a reliable and efficient way to ensure that the data can be restored in the event of a failure or data loss. By using a replica set, you can ensure that the data is replicated across multiple nodes, allowing you to take a backup of a secondary node without affecting the performance or availability of the primary node. This can help to minimize downtime and reduce the impact of backup operations on the availability of the database.</p>",
        "answers": [
          "<p>Use <code>mongodump</code> to backup the data on a regular basis.</p>",
          "<p>Take a file system snapshot of the data directory.</p>",
          "<p>Use a replica set and take a backup of a secondary node.</p>",
          "<p>Use a combination of <code>mongodump</code> and file system snapshots.</p>"
        ]
      },
      "correct_response": [
        "c"
      ],
      "section": "",
      "question_plain": "What is the best practice for backing up data in MongoDB in a production environment?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641042,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is a recommended best practice for monitoring a MongoDB Atlas cluster?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Enabling Performance Advisor and Alerts in Atlas. -&gt;&nbsp;Correct. MongoDB Atlas provides a number of built-in monitoring and management tools to help monitor the performance and health of a cluster. One recommended best practice is to enable Performance Advisor and Alerts in Atlas. Performance Advisor provides recommendations for optimizing cluster performance and alerts can be configured to notify administrators of any performance or resource issues. Regularly reviewing log files for errors is also important for monitoring a MongoDB Atlas cluster, but it does not provide the same level of insight as Performance Advisor and Alerts. Not enabling any performance or resource monitoring, or only monitoring the memory usage of the cluster nodes, can result in performance issues going unnoticed, leading to decreased performance and potential data loss.</p>",
        "answers": [
          "<p>Not enabling any performance or resource monitoring.</p>",
          "<p>Only monitoring the memory usage of the cluster nodes.</p>",
          "<p>Regularly reviewing log files for errors.</p>",
          "<p>Enabling Performance Advisor and Alerts in Atlas.</p>"
        ]
      },
      "correct_response": [
        "d"
      ],
      "section": "",
      "question_plain": "What is a recommended best practice for monitoring a MongoDB Atlas cluster?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641044,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is a recommended best practice for optimizing the cost of a MongoDB Atlas cluster?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Using automated scaling policies and reducing the number of nodes during off-peak hours. -&gt;&nbsp;Correct. MongoDB Atlas provides flexible and cost-effective scaling options to help optimize the cost of a cluster. One recommended best practice is to use automated scaling policies to dynamically adjust the number of nodes in the cluster based on workload demands, and to reduce the number of nodes during off-peak hours when fewer resources are needed. This can help reduce the overall cost of a MongoDB Atlas cluster by ensuring that only the resources that are actually needed are being used. Using the largest possible instance sizes for all nodes or not reducing the number of nodes during off-peak hours can result in unnecessary spending on resources that are not being fully utilized.</p>",
        "answers": [
          "<p>Using the largest possible instance sizes for all nodes.</p>",
          "<p>Not reducing the number of nodes during off-peak hours.</p>",
          "<p>Not using automated scaling policies.</p>",
          "<p>Using automated scaling policies and reducing the number of nodes during off-peak hours.</p>"
        ]
      },
      "correct_response": [
        "d"
      ],
      "section": "",
      "question_plain": "What is a recommended best practice for optimizing the cost of a MongoDB Atlas cluster?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641046,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the maximum size for a BSON document in MongoDB?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>BSON (Binary JSON) is the binary representation of JSON data in MongoDB. The maximum size for a BSON document in MongoDB is capped at 16 MB. This limit is designed to ensure that individual documents do not consume an excessive amount of memory and that a single document can be easily processed by a single MongoDB server. If documents consistently exceed the 16 MB limit, it may indicate the need to reconsider the data model or consider using a different database system that is better suited to large document sizes. Choosing a larger maximum size of 32 MB, 64 MB, or 128 MB would result in increased memory usage and decreased performance.</p>",
        "answers": [
          "<p>16 MB</p>",
          "<p>32 MB</p>",
          "<p>64 MB</p>",
          "<p>128 MB</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is the maximum size for a BSON document in MongoDB?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641048,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>In MongoDB, what is the purpose of the <code>\"Array\"</code> data type?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>To store a list of values with inconsistent data types. -&gt; Correct. In MongoDB, the <code>\"Array\"</code> data type is used to store a list of values with inconsistent data types. Unlike relational databases, MongoDB allows documents to have fields with values of different data types, including arrays. This flexible data model allows for greater flexibility in storing complex data structures. For example, an array field in a document could store a mixture of strings, numbers, and other data types. Storing a single, scalar value, a list of values with a consistent data type, or a hierarchical structure of values would not provide the same level of flexibility as the <code>\"Array\"</code> data type.</p>",
        "answers": [
          "<p>To store a single, scalar value.</p>",
          "<p>To store a list of values with a consistent data type.</p>",
          "<p>To store a list of values with inconsistent data types.</p>",
          "<p>To store a hierarchical structure of values.</p>"
        ]
      },
      "correct_response": [
        "c"
      ],
      "section": "",
      "question_plain": "In MongoDB, what is the purpose of the \"Array\" data type?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56641050,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the purpose of the <code>\"ObjectId\"</code> data type in MongoDB?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>To store a unique identifier for documents in a collection. -&gt; Correct. In MongoDB, the <code>\"ObjectId\"</code> data type is used to store a unique identifier for documents in a collection. Every document in a MongoDB collection must have a unique <code>_id</code> field, which is automatically generated if not specified. By default, MongoDB uses the <code>\"ObjectId\"</code> data type for the <code>_id</code> field, which provides a 12-byte value that is unique across all documents in a collection and across all collections in a database.</p>",
        "answers": [
          "<p>To store date and time information.</p>",
          "<p>To store an IP address.</p>",
          "<p>To store a unique identifier for documents in a collection.</p>",
          "<p>To store encrypted data.</p>"
        ]
      },
      "correct_response": [
        "c"
      ],
      "section": "",
      "question_plain": "What is the purpose of the \"ObjectId\" data type in MongoDB?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56640998,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Select all true statements about reconfiguring a replica set with <code>rs.reconfig()</code>. (select 2)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          ""
        ],
        "explanation": "<p><code>rs.reconfig( configuration, { options } )</code> reconfigures an existing replica set, overwriting the existing replica set configuration. To run the method, you must connect to the primary of the replica set.</p><p>The <code>rs.reconfig()</code> method has the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">rs.reconfig(\n  &lt;configuration&gt;,\n  {\n    \"force\" : &lt;boolean&gt;,\n    \"maxTimeMS\" : &lt;int&gt;\n  }\n)</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/method/rs.reconfig/</p>",
        "answers": [
          "<p>When we reconfigure a replica set with <code>rs.reconfig()</code>, we don't need to restart any of the individual nodes.</p>",
          "<p>When we reconfigure a replica set with <code>rs.reconfig()</code>, we need to update all of the nodes' configuration files.</p>",
          "<p>To retrieve the current configuration you can use <code>rs.conf()</code>.</p>"
        ]
      },
      "correct_response": [
        "a",
        "c"
      ],
      "section": "",
      "question_plain": "Select all true statements about reconfiguring a replica set with rs.reconfig(). (select 2)",
      "related_lectures": []
    }
  ]
}
