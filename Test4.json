{
  "count": 60,
  "next": null,
  "previous": null,
  "results": [
    {
      "_class": "assessment",
      "id": 56168932,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What data structure is used to store the newly created index in MongoDB?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>MongoDB indexes use a B-tree data structure.</p><p><br></p><p>https://docs.mongodb.com/manual/indexes/</p>",
        "answers": [
          "<p>B-tree</p>",
          "<p>Graph</p>",
          "<p>Heap</p>",
          "<p>Dictionary</p>",
          "<p>Binary Tree</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What data structure is used to store the newly created index in MongoDB?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168934,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose you have a <code>reviews</code><em> </em>collection in your database and you want to optimize the following query:</p><p><br></p><pre class=\"prettyprint linenums\">db.reviews.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{ \"votes\":&nbsp;{ \"$gt\":&nbsp;100 },&nbsp;\"rating\":&nbsp;4.5 }\n).sort(\n&nbsp;&nbsp;&nbsp;&nbsp;{ \"date\":&nbsp;1 }\n)</pre><p><br></p><p>Which index on this collection will be the most performant for the above query? Keep in mind the equality, sort, range rule.</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The most efficient index for the given query should follow the equality, sort, range rule which is in this case: </p><p><br></p><pre class=\"prettyprint linenums\">{ rating: 1, date: 1, votes: 1 }</pre><p><br></p><p>https://docs.mongodb.com/manual/indexes/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">{ rating: 1, date: 1, votes: 1 }</pre>",
          "<pre class=\"prettyprint linenums\">{ rating: 1, votes: 1, date: 1 }</pre>",
          "<pre class=\"prettyprint linenums\">{ votes: 1, date: 1, rating: 1 }</pre>",
          "<pre class=\"prettyprint linenums\">{ date: 1, votes: 1, rating: 1 }</pre>",
          "<pre class=\"prettyprint linenums\">{ date: 1, rating: 1, votes: 1 }</pre>",
          "<pre class=\"prettyprint linenums\">{ votes: 1, rating: 1, date: 1 }</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Suppose you have a reviews collection in your database and you want to optimize the following query:db.reviews.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{ \"votes\":&nbsp;{ \"$gt\":&nbsp;100 },&nbsp;\"rating\":&nbsp;4.5 }\n).sort(\n&nbsp;&nbsp;&nbsp;&nbsp;{ \"date\":&nbsp;1 }\n)Which index on this collection will be the most performant for the above query? Keep in mind the equality, sort, range rule.",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168938,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>How many indexes will the following command create?</p><p><br></p><pre class=\"prettyprint linenums\">db.products.createIndex(&nbsp;{ product_name:&nbsp;1,&nbsp;product_category:&nbsp;-1 }&nbsp;)</pre><p><br></p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.collection.createIndex(keys, options, commitQuorum)</code> creates indexes on collections.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/</p>",
        "answers": [
          "<p>1</p>",
          "<p>0</p>",
          "<p>2</p>",
          "<p>3</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "How many indexes will the following command create?db.products.createIndex(&nbsp;{ product_name:&nbsp;1,&nbsp;product_category:&nbsp;-1 }&nbsp;)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168940,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>The <code>users</code><em> </em>collection in the database is given. Which field will be the best candidate for an index in terms of cardinality? </p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Indexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must perform a collection scan, i.e. scan every document in a collection, to select those documents that match the query statement. If an appropriate index exists for a query, MongoDB can use the index to limit the number of documents it must inspect.</p><p>Queries on fields with a small number of unique values (low cardinality) can return large result sets. Compound indexes may include fields with low cardinality, but the value of the combined fields should exhibit high cardinality.</p><p><br></p><p>https://docs.mongodb.com/manual/indexes/</p><p>https://www.mongodb.com/blog/post/performance-best-practices-indexing</p>",
        "answers": [
          "<p>gender (low cardinality)</p>",
          "<p>age (medium cardinality)</p>",
          "<p>email (high cardinality)</p>",
          "<p>city (medium cardinality)</p>"
        ]
      },
      "correct_response": [
        "c"
      ],
      "section": "",
      "question_plain": "The users collection in the database is given. Which field will be the best candidate for an index in terms of cardinality?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168942,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose we have a <code>shipwrecks</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"578f6fa2df35c7fbdbaed8ce\"),\n&nbsp;&nbsp;feature_type:&nbsp;'Wrecks&nbsp;-&nbsp;Visible',\n&nbsp;&nbsp;watlev:&nbsp;'always&nbsp;dry',\n&nbsp;&nbsp;coordinates:&nbsp;[&nbsp;-79.9469681,&nbsp;9.3729954&nbsp;]\n}</pre><p><br></p><p>Your application will often query based on the <code>coordinates</code><em> </em>field. How to create a 2dsphere<em> </em>geospatial index for the <code>coordinates</code><em> </em>field?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>A <code>2dsphere</code> index supports queries that calculate geometries on an earth-like sphere. <code>2dsphere</code> index supports all MongoDB geospatial queries: queries for inclusion, intersection and proximity.</p><p><br></p><p>https://docs.mongodb.com/manual/core/2dsphere/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">&nbsp;db.shipwrecks.createIndex({'coordinates':&nbsp;'2dsphere'})</pre>",
          "<pre class=\"prettyprint linenums\">db.shipwrecks.createIndex({'coordinates':&nbsp;'2d'})</pre>",
          "<pre class=\"prettyprint linenums\">db.shipwrecks.createIndex({'coordinates':&nbsp;'text'})</pre>",
          "<pre class=\"prettyprint linenums\">db.shipwrecks.createIndex({'coordinates':&nbsp;'1'})</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Suppose we have a shipwrecks collection with the following document structure:{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"578f6fa2df35c7fbdbaed8ce\"),\n&nbsp;&nbsp;feature_type:&nbsp;'Wrecks&nbsp;-&nbsp;Visible',\n&nbsp;&nbsp;watlev:&nbsp;'always&nbsp;dry',\n&nbsp;&nbsp;coordinates:&nbsp;[&nbsp;-79.9469681,&nbsp;9.3729954&nbsp;]\n}Your application will often query based on the coordinates field. How to create a 2dsphere geospatial index for the coordinates field?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168944,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose we have a <code>shipwrecks</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"578f6fa2df35c7fbdbaed8ce\"),\n&nbsp;&nbsp;feature_type:&nbsp;'Wrecks&nbsp;-&nbsp;Visible',\n&nbsp;&nbsp;watlev:&nbsp;'always&nbsp;dry',\n&nbsp;&nbsp;coordinates:&nbsp;[&nbsp;-79.9469681,&nbsp;9.3729954&nbsp;]\n}</pre><p><br></p><p>You ran the command below:</p><p><br></p><pre class=\"prettyprint linenums\">db.shipwrecks.getIndexes()</pre><p><br></p><p>And you got the following output:</p><p><br></p><pre class=\"prettyprint linenums\">[\n&nbsp;&nbsp;{&nbsp;v:&nbsp;2,&nbsp;key:&nbsp;{&nbsp;_id:&nbsp;1&nbsp;},&nbsp;name:&nbsp;'_id_'&nbsp;},\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;v:&nbsp;2,\n&nbsp;&nbsp;&nbsp;&nbsp;key:&nbsp;{&nbsp;coordinates:&nbsp;'2dsphere'&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'coordinates_2dsphere',\n&nbsp;&nbsp;&nbsp;&nbsp;'2dsphereIndexVersion':&nbsp;3\n&nbsp;&nbsp;}\n]</pre><p><br></p><p>How can you remove the geospatial index on the <code>coordinates</code><em> </em>field?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>A <code>2dsphere</code> index supports queries that calculate geometries on an earth-like sphere. <code>2dsphere</code> index supports all MongoDB geospatial queries: queries for inclusion, intersection and proximity.</p><p><br></p><p>https://docs.mongodb.com/manual/core/2dsphere/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.shipwrecks.dropIndex('coordinates_2dsphere')</pre>",
          "<pre class=\"prettyprint linenums\">db.shipwrecks.dropIndex('_id_')</pre>",
          "<pre class=\"prettyprint linenums\">db.shipwrecks.dropCollection('coordinates_2dsphere')</pre>",
          "<pre class=\"prettyprint linenums\">db.shipwrecks.createIndex('coordinates_2dsphere')</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Suppose we have a shipwrecks collection with the following document structure:{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"578f6fa2df35c7fbdbaed8ce\"),\n&nbsp;&nbsp;feature_type:&nbsp;'Wrecks&nbsp;-&nbsp;Visible',\n&nbsp;&nbsp;watlev:&nbsp;'always&nbsp;dry',\n&nbsp;&nbsp;coordinates:&nbsp;[&nbsp;-79.9469681,&nbsp;9.3729954&nbsp;]\n}You ran the command below:db.shipwrecks.getIndexes()And you got the following output:[\n&nbsp;&nbsp;{&nbsp;v:&nbsp;2,&nbsp;key:&nbsp;{&nbsp;_id:&nbsp;1&nbsp;},&nbsp;name:&nbsp;'_id_'&nbsp;},\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;v:&nbsp;2,\n&nbsp;&nbsp;&nbsp;&nbsp;key:&nbsp;{&nbsp;coordinates:&nbsp;'2dsphere'&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'coordinates_2dsphere',\n&nbsp;&nbsp;&nbsp;&nbsp;'2dsphereIndexVersion':&nbsp;3\n&nbsp;&nbsp;}\n]How can you remove the geospatial index on the coordinates field?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168946,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the built-in database called <code>admin</code> in MongoDB for?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>https://docs.mongodb.com/manual/tutorial/manage-users-and-roles/</p>",
        "answers": [
          "<p>The <code>admin</code> database plays an important role in the authentication and authorization process. Certain actions performed by administrators also require access to this database.</p>",
          "<p>The <code>admin</code> database stores data describing the MongoDB server. For replica sets, it also stores information about the replication process.</p>",
          "<p>The <code>admin</code> database is used to store information about shards in shared MongoDB cluster.</p>",
          "<p>The <code>admin</code> database stores data describing the MongoDB cluster.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is the built-in database called admin in MongoDB for?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168948,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Select true statements about the naming restrictions of collections in MongoDB. (select 2)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Collection names should begin with an underscore or a letter character, and <em>cannot</em>:</p><ul><li><p>contain the <code>$</code>.</p></li><li><p>be an empty string (e.g. <code>\"\"</code>).</p></li><li><p>contain the null character.</p></li><li><p>begin with the <code>system.</code> prefix. (Reserved for internal use.)</p></li></ul><p><br></p><p>https://www.mongodb.com/docs/manual/reference/limits/#mongodb-limit-Restriction-on-Collection-Names</p>",
        "answers": [
          "<p>Empty string <code>\"\"</code> cannot be a collection name.</p>",
          "<p>You should create collections that start with <code>system.</code></p>",
          "<p>Collection names should not contain <code>$</code> sign.</p>",
          "<p>Your collection name cannot contain the underscore character.</p>"
        ]
      },
      "correct_response": [
        "a",
        "c"
      ],
      "section": "",
      "question_plain": "Select true statements about the naming restrictions of collections in MongoDB. (select 2)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168950,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is a document in MongoDB?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>MongoDB stores data records as BSON documents. BSON is a binary representation of JSON documents, though it contains more data types than JSON. MongoDB documents are composed of field-and-value pairs and have the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   field1: value1,\n   field2: value2,\n   field3: value3,\n   ...\n   fieldN: valueN\n}</pre><p><br></p><p>https://www.mongodb.com/docs/manual/core/document/</p>",
        "answers": [
          "<p>It's an ordered collection of keys (fields) with assigned values. The keys in each document are strings of characters. Documents in MongoDB cannot contain duplicate keys.</p>",
          "<p>It's a table that contains information about all collections in the database.</p>",
          "<p>It's a text file containing the configuration of the MongoDB instance.</p>",
          "<p>It's a text file containing the configuration of the MongoDB cluster.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is a document in MongoDB?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168952,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose you have a <code>posts</code><em> </em>collection of documents in your <code>social_app</code><em> </em>database. What namespace are these documents stored in?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>For a collection or a view, the namespace includes the database name, the dot (<code>.</code>) separator, and the collection/view name (e.g. <code>&lt;database&gt;.&lt;collection&gt;</code>).</p><p><br></p><p>https://www.mongodb.com/docs/manual/reference/limits/#namespaces</p><p>https://www.mongodb.com/docs/manual/reference/limits/#std-label-restrictions-on-db-names</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">social_app.posts</pre>",
          "<pre class=\"prettyprint linenums\">db.posts</pre>",
          "<pre class=\"prettyprint linenums\">db.social_app</pre>",
          "<pre class=\"prettyprint linenums\">posts.db</pre>",
          "<pre class=\"prettyprint linenums\">posts.social_app</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Suppose you have a posts collection of documents in your social_app database. What namespace are these documents stored in?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168954,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Given a <code>movies</code><em> </em>collection where each document has the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    _id: ObjectId(\"573a1390f29313caabcd60e4\"),\n    genres: [ 'Short', 'Comedy', 'Drama' ],\n    title: 'The Immigrant',\n    year: 1917,\n    imdb: { rating: 7.8, votes: 4680, id: 8133 },\n    countries: [ 'USA' ]\n}</pre><p><br></p><p>Which of the following queries will find all movies that do not contain the Comedy and Romance genres?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>$nin</code> selects the documents where:</p><ul><li><p>the <code>field</code> value is not in the specified <code>array</code> <strong>or</strong></p></li><li><p>the <code>field</code> does not exist.</p></li></ul><p>If the <code>field</code> holds an array, then the <code>$nin</code> operator selects the documents whose <code>field</code> holds an array with <strong>no</strong> element equal to a value in the specified array (for example, <code>&lt;value1&gt;</code>, <code>&lt;value2&gt;</code>, and so on).</p><p><br></p><p>Syntax: <code>{ field: { $nin: [ &lt;value1&gt;, &lt;value2&gt; ... &lt;valueN&gt; ] } }</code></p><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/query/nin/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.movies.find( { genres: { $nin: [\"Comedy\", \"Romance\"] } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { genres: { $in: [\"Comedy\", \"Romance\"] } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { genres: { $or: [\"Comedy\", \"Romance\"] } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { genres: { $and: [\"Comedy\", \"Romance\"] } } )</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Given a movies collection where each document has the following structure:{\n    _id: ObjectId(\"573a1390f29313caabcd60e4\"),\n    genres: [ 'Short', 'Comedy', 'Drama' ],\n    title: 'The Immigrant',\n    year: 1917,\n    imdb: { rating: 7.8, votes: 4680, id: 8133 },\n    countries: [ 'USA' ]\n}Which of the following queries will find all movies that do not contain the Comedy and Romance genres?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168956,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Given a <code>movies</code><em> </em>collection where each document has the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    _id: ObjectId(\"573a1391f29313caabcd9264\"),\n    genres: [ 'Romance', 'Drama' ],\n    title: 'The Divorcee',\n    languages: [ 'English', 'French' ],\n    year: 1930,\n    imdb: { rating: 6.9, votes: 1740, id: 20827 },\n    countries: [ 'USA' ]\n}</pre><p><br></p><p>Which of the following queries will find all movies that have exactly 5 languages?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The <code>$size</code> operator matches any array with the number of elements specified by the argument.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/query/size/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.movies.find( { languages: { $size: 5 } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { languages: { $gt: 5 } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { languages: { $eq: 5 } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { languages: 5 } )</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Given a movies collection where each document has the following structure:{\n    _id: ObjectId(\"573a1391f29313caabcd9264\"),\n    genres: [ 'Romance', 'Drama' ],\n    title: 'The Divorcee',\n    languages: [ 'English', 'French' ],\n    year: 1930,\n    imdb: { rating: 6.9, votes: 1740, id: 20827 },\n    countries: [ 'USA' ]\n}Which of the following queries will find all movies that have exactly 5 languages?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168958,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>In your database there is a <code>movies</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd42e8\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Western'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Great&nbsp;Train&nbsp;Robbery',\n&nbsp;&nbsp;rated:&nbsp;'TV-G',\n&nbsp;&nbsp;year:&nbsp;1903,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.4,&nbsp;votes:&nbsp;9847,&nbsp;id:&nbsp;439&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd4323\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama',&nbsp;'Fantasy'&nbsp;],\n&nbsp;&nbsp;rated:&nbsp;'UNRATED',\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Land&nbsp;Beyond&nbsp;the&nbsp;Sunset',\n&nbsp;&nbsp;year:&nbsp;1912,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.1,&nbsp;votes:&nbsp;448,&nbsp;id:&nbsp;488&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n}</pre><p><br></p><p>Which of the following queries will return only the title for the five oldest movies in this collection?</p><p><br></p><p><strong>Expected result:</strong></p><p><br></p><pre class=\"prettyprint linenums\">[\n  { title: 'Newark Athlete' },\n  { title: 'Blacksmith Scene' },\n  { title: 'Dickson Experimental Sound Film' },\n  { title: 'The Kiss' },\n  { title: 'The Great Train Robbery' }\n]</pre><p><br></p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>cursor.sort(sort)</code><strong> </strong>specifies the order in which the query returns matching documents.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/cursor.sort/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.movies.find( {}, { title: 1, _id: 0 } ).sort( { year: 1 } ).limit(5)</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( {}, { title: 1, _id: 0 } ).sort( { year: 1 } ).skip(5).limit(5)</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( {}, { title: 1 } ).sort( { year: 1 } ).limit(5)</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( {}, { title: 1, _id: 0 } ).sort( { year: 1 } ).skip(5)</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "In your database there is a movies collection with the following document structure:{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd42e8\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Western'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Great&nbsp;Train&nbsp;Robbery',\n&nbsp;&nbsp;rated:&nbsp;'TV-G',\n&nbsp;&nbsp;year:&nbsp;1903,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.4,&nbsp;votes:&nbsp;9847,&nbsp;id:&nbsp;439&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd4323\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama',&nbsp;'Fantasy'&nbsp;],\n&nbsp;&nbsp;rated:&nbsp;'UNRATED',\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Land&nbsp;Beyond&nbsp;the&nbsp;Sunset',\n&nbsp;&nbsp;year:&nbsp;1912,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.1,&nbsp;votes:&nbsp;448,&nbsp;id:&nbsp;488&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n}Which of the following queries will return only the title for the five oldest movies in this collection?Expected result:[\n  { title: 'Newark Athlete' },\n  { title: 'Blacksmith Scene' },\n  { title: 'Dickson Experimental Sound Film' },\n  { title: 'The Kiss' },\n  { title: 'The Great Train Robbery' }\n]",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168960,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>You have a <code>companies</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;&nbsp;&nbsp;_id:&nbsp;ObjectId('52cdef7c4bab8bd675297dac'),\n&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'Veoh',\n&nbsp;&nbsp;&nbsp;&nbsp;homepage_url:&nbsp;'http://www.veoh.com',\n&nbsp;&nbsp;&nbsp;&nbsp;category_code:&nbsp;'games_video',\n&nbsp;&nbsp;&nbsp;&nbsp;number_of_employees:&nbsp;null,\n&nbsp;&nbsp;&nbsp;&nbsp;founded_year:&nbsp;2004,\n&nbsp;&nbsp;&nbsp;&nbsp;tag_list:&nbsp;'veoh,&nbsp;video,&nbsp;veohtv,&nbsp;socialvideo,&nbsp;videosharing,&nbsp;crunchbase',\n&nbsp;&nbsp;&nbsp;&nbsp;email_address:&nbsp;'pr@veoh.com',\n&nbsp;&nbsp;&nbsp;&nbsp;description:&nbsp;'Internet&nbsp;TV&nbsp;service'\n}</pre><p><br></p><p>How can you use projection to extract all documents with the following fields: <code>name</code><em>, </em><code>homepage_url</code><em>, </em><code>tag_list</code>?</p><p><br></p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'Veoh',\n&nbsp;&nbsp;&nbsp;&nbsp;homepage_url:&nbsp;'http://www.veoh.com',\n&nbsp;&nbsp;&nbsp;&nbsp;tag_list:&nbsp;'veoh,&nbsp;video,&nbsp;veohtv,&nbsp;socialvideo,&nbsp;videosharing,&nbsp;crunchbase'\n}</pre>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.collection.find(query, projection)</code> selects documents in a collection or view and returns a cursor to the selected documents. The <code>projection</code> parameter determines which fields are returned in the matching documents.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.find/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.companies.find( {}, { _id: 0, name: 1, homepage_url: 1, tag_list: 1 } )</pre>",
          "<pre class=\"prettyprint linenums\">db.companies.find( {}, { name: 1, homepage_url: 1, tag_list: 1 } )</pre>",
          "<pre class=\"prettyprint linenums\">db.companies.find( {}, { _id: 1, name: 1, homepage_url: 1, tag_list: 1 } )</pre>",
          "<pre class=\"prettyprint linenums\">db.companies.find( { _id: 0, name: 1, homepage_url: 1, tag_list: 1 } )</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "You have a companies collection with the following document structure:{\n&nbsp;&nbsp;&nbsp;&nbsp;_id:&nbsp;ObjectId('52cdef7c4bab8bd675297dac'),\n&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'Veoh',\n&nbsp;&nbsp;&nbsp;&nbsp;homepage_url:&nbsp;'http://www.veoh.com',\n&nbsp;&nbsp;&nbsp;&nbsp;category_code:&nbsp;'games_video',\n&nbsp;&nbsp;&nbsp;&nbsp;number_of_employees:&nbsp;null,\n&nbsp;&nbsp;&nbsp;&nbsp;founded_year:&nbsp;2004,\n&nbsp;&nbsp;&nbsp;&nbsp;tag_list:&nbsp;'veoh,&nbsp;video,&nbsp;veohtv,&nbsp;socialvideo,&nbsp;videosharing,&nbsp;crunchbase',\n&nbsp;&nbsp;&nbsp;&nbsp;email_address:&nbsp;'pr@veoh.com',\n&nbsp;&nbsp;&nbsp;&nbsp;description:&nbsp;'Internet&nbsp;TV&nbsp;service'\n}How can you use projection to extract all documents with the following fields: name, homepage_url, tag_list?For example:{\n&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'Veoh',\n&nbsp;&nbsp;&nbsp;&nbsp;homepage_url:&nbsp;'http://www.veoh.com',\n&nbsp;&nbsp;&nbsp;&nbsp;tag_list:&nbsp;'veoh,&nbsp;video,&nbsp;veohtv,&nbsp;socialvideo,&nbsp;videosharing,&nbsp;crunchbase'\n}",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168962,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>In your database there is a <code>movies</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd42e8\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Western'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Great&nbsp;Train&nbsp;Robbery',\n&nbsp;&nbsp;rated:&nbsp;'TV-G',\n&nbsp;&nbsp;year:&nbsp;1903,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.4,&nbsp;votes:&nbsp;9847,&nbsp;id:&nbsp;439&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd4323\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama',&nbsp;'Fantasy'&nbsp;],\n&nbsp;&nbsp;rated:&nbsp;'UNRATED',\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Land&nbsp;Beyond&nbsp;the&nbsp;Sunset',\n&nbsp;&nbsp;year:&nbsp;1912,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.1,&nbsp;votes:&nbsp;448,&nbsp;id:&nbsp;488&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n}</pre><p><br></p><p>In some documents, where there is no rating information for movie, the value is set to <code>''</code> (empty string). With that in mind, which of the following queries will return the title and rating (see below) of top 3 rated movies in this collection?</p><p><br></p><p><strong>Expected result:</strong></p><p><br></p><pre class=\"prettyprint linenums\">[\n  { title: 'Band of Brothers', imdb: { rating: 9.6 } },\n  { title: 'Planet Earth', imdb: { rating: 9.5 } },\n  { title: 'The Civil War', imdb: { rating: 9.4 } }\n]</pre><p><br></p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>cursor.sort(sort)</code><strong> </strong>specifies the order in which the query returns matching documents. Specify in the sort parameter the field or fields to sort by and a value of <code>1</code> or <code>-1</code> to specify an ascending or descending sort respectively.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/cursor.sort/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.movies.find(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ 'imdb.rating':&nbsp;{ $ne:&nbsp;'' } },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;_id:&nbsp;0,&nbsp;title:&nbsp;1,&nbsp;'imdb.rating':&nbsp;1&nbsp;}&nbsp;\n).sort(&nbsp;{&nbsp;'imdb.rating':&nbsp;-1&nbsp;}&nbsp;).limit(3)</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{ 'imdb.rating':&nbsp;{ $ne:&nbsp;'' } },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;_id:&nbsp;0,&nbsp;title:&nbsp;1,&nbsp;'imdb.rating':&nbsp;1&nbsp;}&nbsp;\n).sort(&nbsp;{&nbsp;'imdb.rating':&nbsp;1&nbsp;}&nbsp;).limit(3)</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{},&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;_id:&nbsp;0,&nbsp;title:&nbsp;1,&nbsp;'imdb.rating':&nbsp;1&nbsp;}\n).sort(&nbsp;{&nbsp;'imdb.rating':&nbsp;1&nbsp;}&nbsp;).limit(3)</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{ 'imdb.rating':&nbsp;{ $eq:&nbsp;'' } },&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;_id:&nbsp;0,&nbsp;title:&nbsp;1,&nbsp;'imdb.rating':&nbsp;1&nbsp;}&nbsp;\n).sort(&nbsp;{&nbsp;'imdb.rating':&nbsp;-1&nbsp;}&nbsp;).limit(3)</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "In your database there is a movies collection with the following document structure:{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd42e8\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Western'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Great&nbsp;Train&nbsp;Robbery',\n&nbsp;&nbsp;rated:&nbsp;'TV-G',\n&nbsp;&nbsp;year:&nbsp;1903,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.4,&nbsp;votes:&nbsp;9847,&nbsp;id:&nbsp;439&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd4323\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama',&nbsp;'Fantasy'&nbsp;],\n&nbsp;&nbsp;rated:&nbsp;'UNRATED',\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Land&nbsp;Beyond&nbsp;the&nbsp;Sunset',\n&nbsp;&nbsp;year:&nbsp;1912,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.1,&nbsp;votes:&nbsp;448,&nbsp;id:&nbsp;488&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n}In some documents, where there is no rating information for movie, the value is set to '' (empty string). With that in mind, which of the following queries will return the title and rating (see below) of top 3 rated movies in this collection?Expected result:[\n  { title: 'Band of Brothers', imdb: { rating: 9.6 } },\n  { title: 'Planet Earth', imdb: { rating: 9.5 } },\n  { title: 'The Civil War', imdb: { rating: 9.4 } }\n]",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168964,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>In your database a <code>movies</code><em> </em>collection is given where each document has the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    _id: ObjectId(\"573a1391f29313caabcd9264\"),\n    genres: [ 'Romance', 'Drama' ],\n    title: 'The Divorcee',\n    languages: [ 'English', 'French' ],\n    year: 1930,\n    imdb: { rating: 6.9, votes: 1740, id: 20827 },\n    countries: [ 'USA' ]\n}</pre><p><br></p><p>Which of the following queries will return all movies that are in the Fantasy and Drama (both) genre?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The <code>$all</code> operator selects the documents where the value of a field is an array that contains all the specified elements. To specify an <code>$all</code> expression, use the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">{ &lt;field&gt;: { $all: [ &lt;value1&gt; , &lt;value2&gt; ... ] } }</pre><p><br></p><p>https://docs.mongodb.com/manual/reference/operator/query/all/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.movies.find( { genres: { $all: ['Fantasy', 'Drama'] } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { genres: { $in: ['Fantasy', 'Drama'] } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { genres: { $size: ['Fantasy', 'Drama'] } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.find( { genres: { $elemMatch: ['Fantasy', 'Drama'] } } )</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "In your database a movies collection is given where each document has the following structure:{\n    _id: ObjectId(\"573a1391f29313caabcd9264\"),\n    genres: [ 'Romance', 'Drama' ],\n    title: 'The Divorcee',\n    languages: [ 'English', 'French' ],\n    year: 1930,\n    imdb: { rating: 6.9, votes: 1740, id: 20827 },\n    countries: [ 'USA' ]\n}Which of the following queries will return all movies that are in the Fantasy and Drama (both) genre?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168966,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>MongoDB has a flexible data model. Select all <strong>invalid </strong>MongoDB documents from the following. (select 2)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>MongoDB documents are composed of field-and-value pairs and have the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   field1: value1,\n   field2: value2,\n   field3: value3,\n   ...\n   fieldN: valueN\n}</pre><p><br></p><p>The value of a field can be any of the BSON data types, including other documents, arrays, and arrays of documents. Field names are strings. In MongoDB, each document stored in a collection requires a unique _id field that acts as a primary key. If an inserted document omits the <code>_id</code> field, the MongoDB driver automatically generates an ObjectId for the <code>_id</code> field.</p><p><br></p><p>https://www.mongodb.com/docs/manual/core/document/</p><p>https://docs.mongodb.com/manual/core/data-modeling-introduction/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;&nbsp;&nbsp;_id: ObjectId('61a8b90c6d5ce6a7d8fef95e'),\n    airTemperature:&nbsp;{&nbsp;value:&nbsp;999.9,&nbsp;quality:&nbsp;'9'&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;pressure:&nbsp;{&nbsp;value:&nbsp;9999.9,&nbsp;quality:&nbsp;'9'&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;sections:&nbsp;[&nbsp;'AG1',&nbsp;'AY1',&nbsp;'GF1',&nbsp;'MW1'&nbsp;]\n}</pre>",
          "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;&nbsp;&nbsp;_id: ObjectId('61a8b90c6d5ce6a7d8fef95e'),\n    airTemperature:&nbsp;{&nbsp;value:&nbsp;7.1,&nbsp;quality:&nbsp;'1'&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;pressure:&nbsp;{&nbsp;value:&nbsp;1028.2,&nbsp;quality:&nbsp;'1'&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;sections:&nbsp;['AG1',&nbsp;'AY1',&nbsp;'GF1',&nbsp;'MD1','MW1',&nbsp;'OA1']\n}</pre>",
          "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;&nbsp;&nbsp;_id: ObjectId('61a8b90c6d5ce6a7d8fef95e'),\n    airTemperature:&nbsp;[&nbsp;value:&nbsp;7.1,&nbsp;quality:&nbsp;'1'&nbsp;],\n&nbsp;&nbsp;&nbsp;&nbsp;pressure:&nbsp;{&nbsp;value:&nbsp;1028.2,&nbsp;quality:&nbsp;'1'&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;pressure:&nbsp;['AG1',&nbsp;'AY1',&nbsp;'GF1',&nbsp;'MD1','MW1',&nbsp;'OA1']\n}</pre>",
          "<pre class=\"prettyprint linenums\">{ _id: ObjectId('61a8b90c6d5ce6a7d8fef95e') }</pre>",
          "<pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;&nbsp;&nbsp;_id: ObjectId('61a8b90c6d5ce6a7d8fef95e'),\n    null: null,\n    airTemperature:&nbsp;{&nbsp;value:&nbsp;999.9,&nbsp;quality:&nbsp;'9'&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;pressure:&nbsp;{&nbsp;value:&nbsp;9999.9,&nbsp;quality:&nbsp;'9'&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;sections:&nbsp;[&nbsp;'AG1',&nbsp;'AY1',&nbsp;'GF1',&nbsp;'MW1'&nbsp;]\n}</pre>"
        ]
      },
      "correct_response": [
        "c",
        "e"
      ],
      "section": "",
      "question_plain": "MongoDB has a flexible data model. Select all invalid MongoDB documents from the following. (select 2)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168968,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Select all true statements regarding to the <code>_id</code> field in MongoDB documents. (select 4)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The field name <code>_id</code> is reserved for use as a primary key; its value must be unique in the collection, is immutable, and may be of any type other than an array. If the <code>_id</code> contains subfields, the subfield names cannot begin with a (<code>$</code>) symbol.</p><p><br></p><p>https://docs.mongodb.com/manual/core/document/</p><p>https://docs.mongodb.com/manual/reference/method/ObjectId/</p>",
        "answers": [
          "<p>When inserting a document, the <code>_id</code> value is already generated as an ObjectId type, if not directly specified.</p>",
          "<p>We can select a non ObjectId type value for <code>_id</code> field when inserting a new document.</p>",
          "<p>The <code>_id</code> values must be unique for the collection.</p>",
          "<p>The <code>_id</code> can be an array data type.</p>",
          "<p>MongoDB adds an <code>_id</code> field to any inserted document if it doesn't have one.</p>"
        ]
      },
      "correct_response": [
        "a",
        "b",
        "c",
        "e"
      ],
      "section": "",
      "question_plain": "Select all true statements regarding to the _id field in MongoDB documents. (select 4)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168970,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>In your database there is a <code>movies</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd42e8\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Western'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Great&nbsp;Train&nbsp;Robbery',\n&nbsp;&nbsp;rated:&nbsp;'TV-G',\n&nbsp;&nbsp;year:&nbsp;1903,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.4,&nbsp;votes:&nbsp;9847,&nbsp;id:&nbsp;439&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd4323\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama',&nbsp;'Fantasy'&nbsp;],\n&nbsp;&nbsp;rated:&nbsp;'UNRATED',\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Land&nbsp;Beyond&nbsp;the&nbsp;Sunset',\n&nbsp;&nbsp;year:&nbsp;1912,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.1,&nbsp;votes:&nbsp;448,&nbsp;id:&nbsp;488&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd446f\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'A&nbsp;Corner&nbsp;in&nbsp;Wheat',\n&nbsp;&nbsp;rated:&nbsp;'G',\n&nbsp;&nbsp;year:&nbsp;1909,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;6.6,&nbsp;votes:&nbsp;1375,&nbsp;id:&nbsp;832&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n}</pre><p><br></p><p>How can you group these documents to extract all different values for <code>rated</code><em> </em>field?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.collection.aggregate(pipeline, options)</code><strong> </strong>calculates aggregate values for the data in a collection or a view. </p><p>The <code>$group</code> stage separates documents into groups according to a \"group key\". The output is one document for each unique group key. A group key is often a field, or group of fields. The group key can also be the result of an expression. Use the <code>_id</code> field in the <code>$group</code> pipeline stage to set the group key. In the <code>$group</code> stage output, the <code>_id</code> field is set to the group key for that document.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.movies.aggregate(&nbsp;{&nbsp;$group:&nbsp;{&nbsp;_id:&nbsp;'$rated'&nbsp;}&nbsp;} )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.aggregate( { $group: '$rated' } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.aggregate(&nbsp;{&nbsp;$group:&nbsp;{&nbsp;_id:&nbsp;'rated'&nbsp;}&nbsp;} )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.aggregate(&nbsp;{&nbsp;$count:&nbsp;{&nbsp;_id:&nbsp;'$rated'&nbsp;}&nbsp;} )</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "In your database there is a movies collection with the following document structure:{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd42e8\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Western'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Great&nbsp;Train&nbsp;Robbery',\n&nbsp;&nbsp;rated:&nbsp;'TV-G',\n&nbsp;&nbsp;year:&nbsp;1903,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.4,&nbsp;votes:&nbsp;9847,&nbsp;id:&nbsp;439&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd4323\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama',&nbsp;'Fantasy'&nbsp;],\n&nbsp;&nbsp;rated:&nbsp;'UNRATED',\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Land&nbsp;Beyond&nbsp;the&nbsp;Sunset',\n&nbsp;&nbsp;year:&nbsp;1912,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.1,&nbsp;votes:&nbsp;448,&nbsp;id:&nbsp;488&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd446f\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'A&nbsp;Corner&nbsp;in&nbsp;Wheat',\n&nbsp;&nbsp;rated:&nbsp;'G',\n&nbsp;&nbsp;year:&nbsp;1909,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;6.6,&nbsp;votes:&nbsp;1375,&nbsp;id:&nbsp;832&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n}How can you group these documents to extract all different values for rated field?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168972,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>In your database there is a <code>movies</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd42e8\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Western'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Great&nbsp;Train&nbsp;Robbery',\n&nbsp;&nbsp;rated:&nbsp;'TV-G',\n&nbsp;&nbsp;year:&nbsp;1903,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.4,&nbsp;votes:&nbsp;9847,&nbsp;id:&nbsp;439&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd4323\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama',&nbsp;'Fantasy'&nbsp;],\n&nbsp;&nbsp;rated:&nbsp;'UNRATED',\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Land&nbsp;Beyond&nbsp;the&nbsp;Sunset',\n&nbsp;&nbsp;year:&nbsp;1912,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.1,&nbsp;votes:&nbsp;448,&nbsp;id:&nbsp;488&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd446f\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'A&nbsp;Corner&nbsp;in&nbsp;Wheat',\n&nbsp;&nbsp;rated:&nbsp;'G',\n&nbsp;&nbsp;year:&nbsp;1909,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;6.6,&nbsp;votes:&nbsp;1375,&nbsp;id:&nbsp;832&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n}</pre><p><br></p><p>How can you group these documents to extract the distribution of <code>rated</code><em> </em>field?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.collection.aggregate(pipeline, options)</code><strong> </strong>calculates aggregate values for the data in a collection or a view. </p><p><br></p><p>The <code>$group</code> stage separates documents into groups according to a \"group key\". The output is one document for each unique group key. A group key is often a field, or group of fields. The group key can also be the result of an expression. Use the <code>_id</code> field in the <code>$group</code> pipeline stage to set the group key. In the <code>$group</code> stage output, the <code>_id</code> field is set to the group key for that document.</p><p><br></p><p><code>$sum</code> calculates and returns the collective sum of numeric values. <a href=\"https://www.mongodb.com/docs/manual/reference/operator/aggregation/sum/#mongodb-group-grp.-sum\"><code>$sum</code></a> ignores non-numeric values.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.movies.aggregate( { $group: { _id: '$rated', count: { $sum: 1 } } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.aggregate( { $group: { _id: 'rated', count: { $sum: 1 } } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.aggregate( { $group: { _id: '$rated', $count: { $sum: 1 } } } )</pre>",
          "<pre class=\"prettyprint linenums\">db.movies.aggregate( { $group: { _id: '$rated', count: { $avg: 1 } } } )</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "In your database there is a movies collection with the following document structure:{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd42e8\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Western'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Great&nbsp;Train&nbsp;Robbery',\n&nbsp;&nbsp;rated:&nbsp;'TV-G',\n&nbsp;&nbsp;year:&nbsp;1903,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.4,&nbsp;votes:&nbsp;9847,&nbsp;id:&nbsp;439&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd4323\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama',&nbsp;'Fantasy'&nbsp;],\n&nbsp;&nbsp;rated:&nbsp;'UNRATED',\n&nbsp;&nbsp;title:&nbsp;'The&nbsp;Land&nbsp;Beyond&nbsp;the&nbsp;Sunset',\n&nbsp;&nbsp;year:&nbsp;1912,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;7.1,&nbsp;votes:&nbsp;448,&nbsp;id:&nbsp;488&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n},\n{\n&nbsp;&nbsp;_id:&nbsp;ObjectId(\"573a1390f29313caabcd446f\"),\n&nbsp;&nbsp;genres:&nbsp;[&nbsp;'Short',&nbsp;'Drama'&nbsp;],\n&nbsp;&nbsp;title:&nbsp;'A&nbsp;Corner&nbsp;in&nbsp;Wheat',\n&nbsp;&nbsp;rated:&nbsp;'G',\n&nbsp;&nbsp;year:&nbsp;1909,\n&nbsp;&nbsp;imdb:&nbsp;{&nbsp;rating:&nbsp;6.6,&nbsp;votes:&nbsp;1375,&nbsp;id:&nbsp;832&nbsp;},\n&nbsp;&nbsp;countries:&nbsp;[&nbsp;'USA'&nbsp;]\n}How can you group these documents to extract the distribution of rated field?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168974,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>We have a <code>movies</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    _id: ObjectId(\"573a1390f29313caabcd6223\"),\n    genres: [ 'Comedy', 'Drama', 'Family' ],\n    title: 'The Poor Little Rich Girl',\n    released: ISODate(\"1917-03-05T00:00:00.000Z\"),\n    year: 1917,\n    imdb: { rating: 6.9, votes: 884, id: 8443 }\n}</pre><p><br></p><p>We need to use Aggregation Framework to fetch all movies from this collection where <code>'Drama'</code> is in genres list and the minimum <code>'imdb.votes'</code> is at least 100. Additionally, in the projection stage, we want to leave only the following fields:</p><p><em>-&gt;&nbsp;</em><code>title</code></p><p><em>-&gt; </em><code>genres</code></p><p><em>-&gt; </em><code>imdb.votes</code></p><p><br></p><p>We also want to sort the result set by decreasing imdb votes.</p><p><br></p><p><strong>Example output:</strong></p><p><br></p><pre class=\"prettyprint linenums\">[\n    {\n        imdb: { votes: 1521105 },\n        genres: [ 'Crime', 'Drama' ],\n        title: 'The Shawshank Redemption'\n    },\n    {\n        imdb: { votes: 1513145 },\n        genres: [ 'Crime', 'Drama' ],\n        title: 'The Shawshank Redemption'\n    },\n    {\n        imdb: { votes: 1495351 },\n        genres: [ 'Action', 'Crime', 'Drama' ],\n        title: 'The Dark Knight'\n    },\n...</pre><p><br></p><p>Which pipeline should you use?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.collection.aggregate(pipeline, options)</code><strong> </strong>calculates aggregate values for the data in a collection or a view. </p><p><br></p><p>The <code>$group</code> stage separates documents into groups according to a \"group key\". The output is one document for each unique group key. A group key is often a field, or group of fields. The group key can also be the result of an expression. Use the <code>_id</code> field in the <code>$group</code> pipeline stage to set the group key. In the <code>$group</code> stage output, the <code>_id</code> field is set to the group key for that document.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">[{\n    $match: {\n        genres: {\n            $in: ['Drama']\n        },\n        'imdb.votes': {\n            $gte: 100\n        }\n    }\n}, {\n    $project: {\n        _id: 0,\n        title: 1,\n        genres: 1,\n        'imdb.votes': 1\n    }\n}, {\n    $sort: {\n        'imdb.votes': -1\n    }\n}]</pre>",
          "<pre class=\"prettyprint linenums\">[{\n    $match: {\n        genres: {\n            $in: ['Drama']\n        },\n        'imdb.votes': {\n            $gte: 100\n        }\n    }\n}, {\n    $project: {\n        _id: 0,\n        title: 1,\n        genres: 1,\n        'imdb.votes': 1\n    }\n}, {\n    $limit: {\n        'imdb.votes': -1\n    }\n}]</pre>",
          "<pre class=\"prettyprint linenums\">[{\n    $match: {\n        genres: {\n            $in: ['Drama']\n        },\n        'imdb.votes': {\n            $gte: 100\n        }\n    }\n}, {\n    $project: {\n        _id: 0,\n        title: 1,\n        genres: 1,\n        'imdb.votes': 1\n    }\n}, {\n    $sort: {\n        'imdb.votes': 1\n    }\n}]</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "We have a movies collection with the following document structure:{\n    _id: ObjectId(\"573a1390f29313caabcd6223\"),\n    genres: [ 'Comedy', 'Drama', 'Family' ],\n    title: 'The Poor Little Rich Girl',\n    released: ISODate(\"1917-03-05T00:00:00.000Z\"),\n    year: 1917,\n    imdb: { rating: 6.9, votes: 884, id: 8443 }\n}We need to use Aggregation Framework to fetch all movies from this collection where 'Drama' is in genres list and the minimum 'imdb.votes' is at least 100. Additionally, in the projection stage, we want to leave only the following fields:-&gt;&nbsp;title-&gt; genres-&gt; imdb.votesWe also want to sort the result set by decreasing imdb votes.Example output:[\n    {\n        imdb: { votes: 1521105 },\n        genres: [ 'Crime', 'Drama' ],\n        title: 'The Shawshank Redemption'\n    },\n    {\n        imdb: { votes: 1513145 },\n        genres: [ 'Crime', 'Drama' ],\n        title: 'The Shawshank Redemption'\n    },\n    {\n        imdb: { votes: 1495351 },\n        genres: [ 'Action', 'Crime', 'Drama' ],\n        title: 'The Dark Knight'\n    },\n...Which pipeline should you use?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168976,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>We have a <code>movies</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    _id: ObjectId(\"573a1390f29313caabcd6223\"),\n    genres: [ 'Comedy', 'Drama', 'Family' ],\n    title: 'The Poor Little Rich Girl',\n    released: ISODate(\"1917-03-05T00:00:00.000Z\"),\n    year: 1917,\n    imdb: { rating: 6.9, votes: 884, id: 8443 }\n}</pre><p><br></p><p>We need to use Aggregation Framework to fetch all movies from this collection where <code>'Drama'</code> is not in genres list and the minimum <code>'imdb.votes'</code> is at least 100. Additionally, in the projection stage, we want to leave only the following fields:</p><p><em>-&gt;&nbsp;</em><code>title</code></p><p><em>-&gt; </em><code>genres</code></p><p><em>-&gt; </em><code>imdb.votes</code></p><p><br></p><p>We also want to sort the result set by decreasing imdb votes and limit the number of documents retuned to 5.</p><p><br></p><p><strong>Example output:</strong></p><p><br></p><pre class=\"prettyprint linenums\">[\n    {\n        imdb: { votes: 1294646 },\n        genres: [ 'Action', 'Mystery', 'Sci-Fi' ],\n        title: 'Inception'\n    },\n    {\n        imdb: { votes: 1109724 },\n        genres: [ 'Adventure', 'Fantasy' ],\n        title: 'The Lord of the Rings: The Fellowship of the Ring'\n    },\n    {\n        imdb: { votes: 1081144 },\n        genres: [ 'Adventure', 'Fantasy' ],\n        title: 'The Lord of the Rings: The Return of the King'\n    },\n    {\n        imdb: { votes: 1080566 },\n        genres: [ 'Action', 'Sci-Fi' ],\n        title: 'The Matrix'\n    },\n    {\n        imdb: { votes: 1004805 },\n        genres: [ 'Action', 'Thriller' ],\n        title: 'The Dark Knight Rises'\n    }\n]</pre><p><br></p><p>Which pipeline should you use?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.collection.aggregate(pipeline, options)</code><strong> </strong>calculates aggregate values for the data in a collection or a view. </p><p><br></p><p>The <code>$group</code> stage separates documents into groups according to a \"group key\". The output is one document for each unique group key. A group key is often a field, or group of fields. The group key can also be the result of an expression. Use the <code>_id</code> field in the <code>$group</code> pipeline stage to set the group key. In the <code>$group</code> stage output, the <code>_id</code> field is set to the group key for that document.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">[{\n    $match: {\n        genres: {\n            $nin: ['Drama']\n        },\n        'imdb.votes': {\n            $gte: 100\n        }\n    }\n}, {\n    $project: {\n        _id: 0,\n        title: 1,\n        genres: 1,\n        'imdb.votes': 1\n    }\n}, {\n    $sort: {\n        'imdb.votes': -1\n    }\n}, {\n    $limit: 5\n}]</pre>",
          "<pre class=\"prettyprint linenums\">[{\n    $match: {\n        genres: {\n            $in: ['Drama']\n        },\n        'imdb.votes': {\n            $gte: 100\n        }\n    }\n}, {\n    $project: {\n        _id: 0,\n        title: 1,\n        genres: 1,\n        'imdb.votes': 1\n    }\n}, {\n    $sort: {\n        'imdb.votes': -1\n    }\n}, {\n    $limit: 5\n}]</pre>",
          "<pre class=\"prettyprint linenums\">[{\n    $match: {\n        genres: {\n            $nin: ['Drama']\n        },\n        'imdb.votes': {\n            $gte: 100\n        }\n    }\n}, {\n    $project: {\n        _id: 0,\n        title: 1,\n        genres: 1,\n        'imdb.votes': 1\n    }\n}, {\n    $sort: {\n        'imdb.votes': -1\n    }\n}]</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "We have a movies collection with the following document structure:{\n    _id: ObjectId(\"573a1390f29313caabcd6223\"),\n    genres: [ 'Comedy', 'Drama', 'Family' ],\n    title: 'The Poor Little Rich Girl',\n    released: ISODate(\"1917-03-05T00:00:00.000Z\"),\n    year: 1917,\n    imdb: { rating: 6.9, votes: 884, id: 8443 }\n}We need to use Aggregation Framework to fetch all movies from this collection where 'Drama' is not in genres list and the minimum 'imdb.votes' is at least 100. Additionally, in the projection stage, we want to leave only the following fields:-&gt;&nbsp;title-&gt; genres-&gt; imdb.votesWe also want to sort the result set by decreasing imdb votes and limit the number of documents retuned to 5.Example output:[\n    {\n        imdb: { votes: 1294646 },\n        genres: [ 'Action', 'Mystery', 'Sci-Fi' ],\n        title: 'Inception'\n    },\n    {\n        imdb: { votes: 1109724 },\n        genres: [ 'Adventure', 'Fantasy' ],\n        title: 'The Lord of the Rings: The Fellowship of the Ring'\n    },\n    {\n        imdb: { votes: 1081144 },\n        genres: [ 'Adventure', 'Fantasy' ],\n        title: 'The Lord of the Rings: The Return of the King'\n    },\n    {\n        imdb: { votes: 1080566 },\n        genres: [ 'Action', 'Sci-Fi' ],\n        title: 'The Matrix'\n    },\n    {\n        imdb: { votes: 1004805 },\n        genres: [ 'Action', 'Thriller' ],\n        title: 'The Dark Knight Rises'\n    }\n]Which pipeline should you use?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168978,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>We have a <code>movies</code><em> </em>collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  _id: ObjectId(\"573a1390f29313caabcd6223\"),\n  genres: [ 'Comedy', 'Drama', 'Family' ],\n  title: 'The Poor Little Rich Girl',\n  released: ISODate(\"1917-03-05T00:00:00.000Z\"),\n  year: 1917,\n  imdb: { rating: 6.9, votes: 884, id: 8443 }\n},\n{\n  _id: ObjectId(\"573a13e3f29313caabdc08a4\"),\n  genres: [ 'Horror', 'Thriller' ],\n  title: 'Mary Loss of Soul',\n  year: 2014,\n  imdb: { rating: '', votes: '', id: 2904798 }\n}</pre><p><br></p><p>We need to use Aggregation Framework to calculate the following aggregates:</p><p>-&gt;&nbsp;average imdb rating</p><p>-&gt; minimum imdb rating</p><p>-&gt; maximum imdb rating</p><p><br></p><p><strong>Expected output:</strong></p><p><br></p><pre class=\"prettyprint linenums\">[\n    {\n        _id: null,\n        avg_rating: 6.6934040649367255,\n        min_rating: 1.6,\n        max_rating: 9.6\n    }\n]</pre><p><br></p><p>Please note that some documents have <code>\"\"</code> (empty string) for the field <code>\"imdb.rating\"</code>. Exclude these documents before aggregation.</p><p><br></p><p>Which pipeline should you use?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.collection.aggregate(pipeline, options)</code><strong> </strong>calculates aggregate values for the data in a collection or a view. </p><p><br></p><p>The <code>$group</code> stage separates documents into groups according to a \"group key\". The output is one document for each unique group key. A group key is often a field, or group of fields. The group key can also be the result of an expression. Use the <code>_id</code> field in the <code>$group</code> pipeline stage to set the group key. In the <code>$group</code> stage output, the <code>_id</code> field is set to the group key for that document.</p><p><br></p><p>https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">[{\n    $match: {\n        \"imdb.rating\": {\n            $ne: \"\"\n        }\n    }\n}, {\n    $group: {\n        _id: null,\n        avg_rating: {\n            $avg: \"$imdb.rating\"\n        },\n        min_rating: {\n            $min: \"$imdb.rating\"\n        },\n        max_rating: {\n            $max: \"$imdb.rating\"\n        }\n    }\n}]</pre>",
          "<pre class=\"prettyprint linenums\">[{\n    $match: {\n        \"imdb.rating\": {\n            $ne: \"\"\n        }\n    }\n}, {\n    $group: {\n        _id: null,\n        avg_rating: {\n            avg: \"$imdb.rating\"\n        },\n        min_rating: {\n            min: \"$imdb.rating\"\n        },\n        max_rating: {\n            max: \"$imdb.rating\"\n        }\n    }\n}]</pre>",
          "<pre class=\"prettyprint linenums\">[{\n    $match: {\n        \"imdb.rating\": {\n            $ne: \"\"\n        }\n    }\n}, {\n    $group: {\n        _id: null,\n        avg_rating: {\n            $avg: \"imdb.rating\"\n        },\n        min_rating: {\n            $min: \"imdb.rating\"\n        },\n        max_rating: {\n            $max: \"imdb.rating\"\n        }\n    }\n}]</pre>",
          "<pre class=\"prettyprint linenums\">[{\n    $group: {\n        _id: null,\n        avg_rating: {\n            $avg: \"$imdb.rating\"\n        },\n        min_rating: {\n            $min: \"$imdb.rating\"\n        },\n        max_rating: {\n            $max: \"$imdb.rating\"\n        }\n    }\n}]</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "We have a movies collection with the following document structure:{\n  _id: ObjectId(\"573a1390f29313caabcd6223\"),\n  genres: [ 'Comedy', 'Drama', 'Family' ],\n  title: 'The Poor Little Rich Girl',\n  released: ISODate(\"1917-03-05T00:00:00.000Z\"),\n  year: 1917,\n  imdb: { rating: 6.9, votes: 884, id: 8443 }\n},\n{\n  _id: ObjectId(\"573a13e3f29313caabdc08a4\"),\n  genres: [ 'Horror', 'Thriller' ],\n  title: 'Mary Loss of Soul',\n  year: 2014,\n  imdb: { rating: '', votes: '', id: 2904798 }\n}We need to use Aggregation Framework to calculate the following aggregates:-&gt;&nbsp;average imdb rating-&gt; minimum imdb rating-&gt; maximum imdb ratingExpected output:[\n    {\n        _id: null,\n        avg_rating: 6.6934040649367255,\n        min_rating: 1.6,\n        max_rating: 9.6\n    }\n]Please note that some documents have \"\" (empty string) for the field \"imdb.rating\". Exclude these documents before aggregation.Which pipeline should you use?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168980,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose you have a <code>mobile_games</code> collection with the following document structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;&nbsp;&nbsp;game:&nbsp;\"Fishing&nbsp;Clash\",\n&nbsp;&nbsp;&nbsp;&nbsp;company:&nbsp;\"Ten&nbsp;Square&nbsp;Games\",\n&nbsp;&nbsp;&nbsp;&nbsp;platforms:&nbsp;['Android',&nbsp;'IOS'],\n&nbsp;&nbsp;&nbsp;&nbsp;...\n&nbsp;&nbsp;&nbsp;&nbsp;release_USA:&nbsp;ISODate(\"2017-04-09T01:00:00+01:00\"),\n&nbsp;&nbsp;&nbsp;&nbsp;release_France:&nbsp;ISODate(\"2017-04-09T01:00:00+01:00\"),\n&nbsp;&nbsp;&nbsp;&nbsp;release_Italy:&nbsp;ISODate(\"2017-08-17T01:00:00+01:00\"),\n&nbsp;&nbsp;&nbsp;&nbsp;...\n}</pre><p><br></p><p>You want to redesign your document structure as below:</p><p><br></p><pre class=\"prettyprint linenums\">{\n&nbsp;&nbsp;&nbsp;&nbsp;game:&nbsp;\"Fishing&nbsp;Clash\",\n&nbsp;&nbsp;&nbsp;&nbsp;company:&nbsp;\"Ten&nbsp;Square&nbsp;Games\",\n&nbsp;&nbsp;&nbsp;&nbsp;platforms:&nbsp;['Android',&nbsp;'IOS'],\n&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;releases:&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location:&nbsp;\"USA\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;date:&nbsp;ISODate(\"2017-04-09T01:00:00+01:00\")\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location:&nbsp;\"France\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;date:&nbsp;ISODate(\"2017-04-09T01:00:00+01:00\")\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location:&nbsp;\"Italy\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;date:&nbsp;ISODate(\"2017-08-17T01:00:00+01:00\")\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;],\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n}</pre><p><br></p><p>Which pattern solution will you use to solve this problem?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>https://www.mongodb.com/blog/post/building-with-patterns-the-attribute-pattern</p>",
        "answers": [
          "<p>The Attribute Pattern.</p>",
          "<p>The Bucket Pattern.</p>",
          "<p>The Extended Reference Pattern.</p>",
          "<p>The Subset Pattern.</p>",
          "<p>The Schema Versioning Pattern.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Suppose you have a mobile_games collection with the following document structure:{\n&nbsp;&nbsp;&nbsp;&nbsp;game:&nbsp;\"Fishing&nbsp;Clash\",\n&nbsp;&nbsp;&nbsp;&nbsp;company:&nbsp;\"Ten&nbsp;Square&nbsp;Games\",\n&nbsp;&nbsp;&nbsp;&nbsp;platforms:&nbsp;['Android',&nbsp;'IOS'],\n&nbsp;&nbsp;&nbsp;&nbsp;...\n&nbsp;&nbsp;&nbsp;&nbsp;release_USA:&nbsp;ISODate(\"2017-04-09T01:00:00+01:00\"),\n&nbsp;&nbsp;&nbsp;&nbsp;release_France:&nbsp;ISODate(\"2017-04-09T01:00:00+01:00\"),\n&nbsp;&nbsp;&nbsp;&nbsp;release_Italy:&nbsp;ISODate(\"2017-08-17T01:00:00+01:00\"),\n&nbsp;&nbsp;&nbsp;&nbsp;...\n}You want to redesign your document structure as below:{\n&nbsp;&nbsp;&nbsp;&nbsp;game:&nbsp;\"Fishing&nbsp;Clash\",\n&nbsp;&nbsp;&nbsp;&nbsp;company:&nbsp;\"Ten&nbsp;Square&nbsp;Games\",\n&nbsp;&nbsp;&nbsp;&nbsp;platforms:&nbsp;['Android',&nbsp;'IOS'],\n&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;releases:&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location:&nbsp;\"USA\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;date:&nbsp;ISODate(\"2017-04-09T01:00:00+01:00\")\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location:&nbsp;\"France\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;date:&nbsp;ISODate(\"2017-04-09T01:00:00+01:00\")\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location:&nbsp;\"Italy\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;date:&nbsp;ISODate(\"2017-08-17T01:00:00+01:00\")\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;],\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n}Which pattern solution will you use to solve this problem?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168982,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Assign typical operational tasks to the Data Scientist.</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>https://www.mongodb.com/docs/manual/reference/built-in-roles/</p>",
        "answers": [
          "<p>create user, create index</p>",
          "<p>write data, read data</p>",
          "<p>read data</p>",
          "<p>write data</p>"
        ]
      },
      "correct_response": [
        "c"
      ],
      "section": "",
      "question_plain": "Assign typical operational tasks to the Data Scientist.",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168984,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Which of the following actions are granted to the built-in <code>readWrite</code><em> </em>role? Select all that apply.</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>readWrite</code> provides all the privileges of the <code>read</code> role plus ability to modify data on all <em>non</em>-system collections and the <code>system.js</code> collection. </p><p><br></p><p>https://docs.mongodb.com/manual/reference/built-in-roles/#mongodb-authrole-readWrite</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">find</pre>",
          "<pre class=\"prettyprint linenums\">insert</pre>",
          "<pre class=\"prettyprint linenums\">update</pre>",
          "<pre class=\"prettyprint linenums\">remove</pre>"
        ]
      },
      "correct_response": [
        "a",
        "b",
        "c",
        "d"
      ],
      "section": "",
      "question_plain": "Which of the following actions are granted to the built-in readWrite role? Select all that apply.",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168986,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose you are connected to <code>mongod</code><em> </em>instance that is already running on port 27000 as admin user. You have to export <code>reviews</code> collection from the <code>restaurants</code><em> </em>database to JSON file named <code>reviews.json</code>.</p><p><br></p><p>Which command should you use?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>mongoexport</code> is a command-line tool that produces a JSON or CSV export of data stored in a MongoDB instance.</p><p><br></p><p>https://docs.mongodb.com/database-tools/mongoexport/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">mongoexport&nbsp;--db&nbsp;restaurants --collection&nbsp;reviews -o&nbsp;reviews.json</pre>",
          "<pre class=\"prettyprint linenums\">mongodump&nbsp;--db&nbsp;restaurants --collection&nbsp;reviews -o&nbsp;reviews.json</pre>",
          "<pre class=\"prettyprint linenums\">mongoexport&nbsp;--db&nbsp;restaurants --collection&nbsp;reviews -o export.json</pre>",
          "<pre class=\"prettyprint linenums\">mongostore&nbsp;--db&nbsp;restaurants --collection&nbsp;reviews -o&nbsp;reviews.json</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Suppose you are connected to mongod instance that is already running on port 27000 as admin user. You have to export reviews collection from the restaurants database to JSON file named reviews.json.Which command should you use?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168988,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Select all true statements about the differences between <code>mongoexport</code><em> </em>and <code>mongodump</code>. (select 3)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>mongoexport</code> is a command-line tool that produces a JSON or CSV export of data stored in a MongoDB instance.</p><p><code>mongodump</code> is a utility for creating a binary export of the contents of a database. <code>mongodump</code> can export data from either <code>mongod</code> or <code>mongos</code> instances; i.e. can export data from standalone, replica set, and sharded cluster deployments.</p><p><br></p><p>https://docs.mongodb.com/database-tools/mongoexport/</p><p>https://docs.mongodb.com/database-tools/mongodump/</p>",
        "answers": [
          "<p><code>mongoexport</code> outputs BSON file, but <code>mongodump</code> outputs JSON file.</p>",
          "<p><code>mongoexport</code> outputs JSON file, but <code>mongodump</code> outputs BSON file.</p>",
          "<p><code>mongodump</code> can create a data file and a metadata file, but <code>mongoexport</code> just creates a data file.</p>",
          "<p><code>mongodump</code> is typically faster than <code>mongoexport</code></p>",
          "<p>By default, <code>mongodump</code> sends output to stdout, but <code>mongoexport</code> writes to a file.</p>"
        ]
      },
      "correct_response": [
        "b",
        "c",
        "d"
      ],
      "section": "",
      "question_plain": "Select all true statements about the differences between mongoexport and mongodump. (select 3)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168990,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Select all options where you should use sharding. (select 2)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Sharding is a method for distributing data across multiple machines. MongoDB uses sharding to support deployments with very large data sets and high throughput operations.</p><p><br></p><p><em>Every time you start a new project with MongoDB. </em>-&gt;&nbsp;False</p><p><em>Your server disks are full, but you can scale up. </em>-&gt;&nbsp;False</p><p><br></p><p>https://docs.mongodb.com/manual/sharding/</p>",
        "answers": [
          "<p>You have over 6TB per server and operating costs are increasing dramatically.</p>",
          "<p>Your organization outgrows the most powerful servers available, which limits your vertical scaling capabilities.</p>",
          "<p>Every time you start a new project with MongoDB.</p>",
          "<p>Your server disks are full, but you can scale up.</p>"
        ]
      },
      "correct_response": [
        "a",
        "b"
      ],
      "section": "",
      "question_plain": "Select all options where you should use sharding. (select 2)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168992,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Given a <code>flights</code><em> </em>collection that is sharded on the following shard key:</p><p><br></p><pre class=\"prettyprint linenums\">{&nbsp;\"airline_id\"&nbsp;:&nbsp;1,&nbsp;\"departure_airport\"&nbsp;:&nbsp;1&nbsp;}</pre><p><br></p><p>Which of the following queries results in a targeted query? (select 3)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<pre class=\"prettyprint linenums\">db.flights.find( { departure_airport: \"JFK\" } )</pre><p><br></p><p>This query doesn't include the <em>airline_id</em> prefix, and cannot be targeted.</p><p><br></p><p>https://docs.mongodb.com/manual/core/sharding-shard-key/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.flights.find( { airline_id: 2946863, departure_airport: \"JFK\" } )</pre>",
          "<pre class=\"prettyprint linenums\">db.flights.find( { departure_airport: \"JFK\" } )</pre>",
          "<pre class=\"prettyprint linenums\">db.flights.find( { airline_id: 2946863 } )</pre>",
          "<pre class=\"prettyprint linenums\">db.flights.find( { departure_airport: \"JFK\", airline_id: 2946863 } )</pre>"
        ]
      },
      "correct_response": [
        "a",
        "c",
        "d"
      ],
      "section": "",
      "question_plain": "Given a flights collection that is sharded on the following shard key:{&nbsp;\"airline_id\"&nbsp;:&nbsp;1,&nbsp;\"departure_airport\"&nbsp;:&nbsp;1&nbsp;}Which of the following queries results in a targeted query? (select 3)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168994,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the syntax for creating a new collection in MongoDB?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.createCollection(\"collection_name\")</code> -&gt;&nbsp;Correct.</p><p><br></p><p>https://www.mongodb.com/docs/manual/reference/method/db.createCollection/</p>",
        "answers": [
          "<p><code>db.createCollection(\"collection_name\")</code> </p>",
          "<p><code>database.create(\"collection_name\")</code> </p>",
          "<p><code>db.newCollection(\"collection_name\")</code> </p>",
          "<p><code>database.collection.create(\"collection_name\")</code> </p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is the syntax for creating a new collection in MongoDB?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168996,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>How would you perform a text search on a field in MongoDB?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p><code>db.collection.find({$text: {$search: \"search_query\"}})</code> -&gt; Correct. <code>$text</code> performs a text search on the content of the fields indexed with a text index. A <code>$text</code> expression has the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  $text:\n    {\n      $search: &lt;string&gt;,\n      $language: &lt;string&gt;,\n      $caseSensitive: &lt;boolean&gt;,\n      $diacriticSensitive: &lt;boolean&gt;\n    }\n}</pre><p><br></p><p>https://www.mongodb.com/docs/manual/reference/operator/query/text/</p>",
        "answers": [
          "<p><code>db.collection.find({$text: {$search: \"search_query\"}})</code> </p>",
          "<p><code>db.collection.textSearch(\"search_query\")</code> </p>",
          "<p><code>db.collection.search({text: \"search_query\"})</code> </p>",
          "<p><code>db.collection.find({text: {$search: \"search_query\"}})</code> </p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "How would you perform a text search on a field in MongoDB?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56168998,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a collection named <code>orders</code><em> </em>with the following documents:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e7\"),\n   \"customer_id\" : \"A123\",\n   \"items\" : [\n      {\n         \"product_id\" : \"P001\",\n         \"quantity\" : 5\n      },\n      {\n         \"product_id\" : \"P002\",\n         \"quantity\" : 2\n      }\n   ],\n   \"total\" : 35\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e8\"),\n   \"customer_id\" : \"B456\",\n   \"items\" : [\n      {\n         \"product_id\" : \"P001\",\n         \"quantity\" : 3\n      },\n      {\n         \"product_id\" : \"P003\",\n         \"quantity\" : 1\n      }\n   ],\n   \"total\" : 15\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e9\"),\n   \"customer_id\" : \"C789\",\n   \"items\" : [\n      {\n         \"product_id\" : \"P002\",\n         \"quantity\" : 4\n      }\n   ],\n   \"total\" : 20\n}</pre><p><br></p><p>What is the query to find the number of orders placed for each product in the collection <code>orders</code>?</p><p><br></p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $unwind: \"$items\"\n   },\n   {\n      $group: {\n         _id: \"$items.product_id\",\n         total_orders: { $sum: \"$items.quantity\" }\n      }\n   }\n])</pre><p><br></p><p><code>$unwind</code> - deconstructs an array field from the input documents to output a document for each element. Each output document is the input document with the value of the array field replaced by the element.</p><p><code>$group</code> - the <code>$group</code> stage separates documents into groups according to a \"group key\". The output is one document for each unique group key. The <code>$group</code> stage has the following prototype form:</p><p><br></p><pre class=\"prettyprint linenums\">{\n  $group:\n    {\n      _id: &lt;expression&gt;, // Group key\n      &lt;field1&gt;: { &lt;accumulator1&gt; : &lt;expression1&gt; },\n      ...\n    }\n }</pre>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $unwind: \"$items\"\n   },\n   {\n      $group: {\n         _id: \"$items.product_id\",\n         total_orders: { $sum: \"$items.quantity\" }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $group: {\n         _id: \"$items.product_id\",\n         total_orders: { $sum: \"$items.quantity\" }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $unwind: \"$items\"\n   },\n   {\n      $group: {\n         total_orders: { $sum: \"$items.quantity\" }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $out: \"$items\"\n   },\n   {\n      $group: {\n         _id: \"$items.product_id\",\n         total_orders: { $sum: \"$items.quantity\" }\n      }\n   }\n])</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider a collection named orders with the following documents:{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e7\"),\n   \"customer_id\" : \"A123\",\n   \"items\" : [\n      {\n         \"product_id\" : \"P001\",\n         \"quantity\" : 5\n      },\n      {\n         \"product_id\" : \"P002\",\n         \"quantity\" : 2\n      }\n   ],\n   \"total\" : 35\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e8\"),\n   \"customer_id\" : \"B456\",\n   \"items\" : [\n      {\n         \"product_id\" : \"P001\",\n         \"quantity\" : 3\n      },\n      {\n         \"product_id\" : \"P003\",\n         \"quantity\" : 1\n      }\n   ],\n   \"total\" : 15\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e9\"),\n   \"customer_id\" : \"C789\",\n   \"items\" : [\n      {\n         \"product_id\" : \"P002\",\n         \"quantity\" : 4\n      }\n   ],\n   \"total\" : 20\n}What is the query to find the number of orders placed for each product in the collection orders?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169000,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a collection named <code>students</code><em> </em>with the following documents:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e7\"),\n   \"name\" : \"John Doe\",\n   \"age\" : 25,\n   \"gender\" : \"male\",\n   \"scores\" : [\n      {\n         \"subject\" : \"math\",\n         \"score\" : 80\n      },\n      {\n         \"subject\" : \"english\",\n         \"score\" : 90\n      },\n      {\n         \"subject\" : \"history\",\n         \"score\" : 85\n      }\n   ]\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e8\"),\n   \"name\" : \"Jane Doe\",\n   \"age\" : 28,\n   \"gender\" : \"female\",\n   \"scores\" : [\n      {\n         \"subject\" : \"math\",\n         \"score\" : 75\n      },\n      {\n         \"subject\" : \"english\",\n         \"score\" : 92\n      },\n      {\n         \"subject\" : \"history\",\n         \"score\" : 87\n      }\n   ]\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e9\"),\n   \"name\" : \"Jim Brown\",\n   \"age\" : 30,\n   \"gender\" : \"male\",\n   \"scores\" : [\n      {\n         \"subject\" : \"math\",\n         \"score\" : 82\n      },\n      {\n         \"subject\" : \"english\",\n         \"score\" : 88\n      },\n      {\n         \"subject\" : \"history\",\n         \"score\" : 89\n      }\n   ]\n}</pre><p><br></p><p>What is the query to retrieve the average score for each subject across all students in the <code>students</code> collection?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.students.aggregate([\n   {\n      $unwind: \"$scores\"\n   },\n   {\n      $group: {\n         _id: \"$scores.subject\",\n         average_score: { $avg: \"$scores.score\" }\n      }\n   }\n])</pre>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.students.aggregate([\n   {\n      $unwind: \"$scores\"\n   },\n   {\n      $group: {\n         _id: \"$scores.subject\",\n         average_score: { $avg: \"$scores.score\" }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.students.aggregate([\n   {\n      $unwind: \"$scores\"\n   },\n   {\n      $group: {\n         _id: \"$scores\",\n         average_score: { $avg: \"$scores.score\" }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.students.aggregate([\n   {\n      $unwind: \"$scores\"\n   },\n   {\n      $group: {\n         _id: \"$scores\",\n         average_score: { $avg: \"$score\" }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.students.aggregate([\n   {\n      $group: {\n         _id: \"$scores.subject\",\n         average_score: { $avg: \"$scores.score\" }\n      }\n   }\n])</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider a collection named students with the following documents:{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e7\"),\n   \"name\" : \"John Doe\",\n   \"age\" : 25,\n   \"gender\" : \"male\",\n   \"scores\" : [\n      {\n         \"subject\" : \"math\",\n         \"score\" : 80\n      },\n      {\n         \"subject\" : \"english\",\n         \"score\" : 90\n      },\n      {\n         \"subject\" : \"history\",\n         \"score\" : 85\n      }\n   ]\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e8\"),\n   \"name\" : \"Jane Doe\",\n   \"age\" : 28,\n   \"gender\" : \"female\",\n   \"scores\" : [\n      {\n         \"subject\" : \"math\",\n         \"score\" : 75\n      },\n      {\n         \"subject\" : \"english\",\n         \"score\" : 92\n      },\n      {\n         \"subject\" : \"history\",\n         \"score\" : 87\n      }\n   ]\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e9\"),\n   \"name\" : \"Jim Brown\",\n   \"age\" : 30,\n   \"gender\" : \"male\",\n   \"scores\" : [\n      {\n         \"subject\" : \"math\",\n         \"score\" : 82\n      },\n      {\n         \"subject\" : \"english\",\n         \"score\" : 88\n      },\n      {\n         \"subject\" : \"history\",\n         \"score\" : 89\n      }\n   ]\n}What is the query to retrieve the average score for each subject across all students in the students collection?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169002,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a collection named <code>orders</code><em> </em>with the following documents:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e7\"),\n   \"order_id\" : 1001,\n   \"customer_name\" : \"John Doe\",\n   \"order_date\" : ISODate(\"2020-01-01T00:00:00.000Z\"),\n   \"items\" : [\n      {\n         \"product_id\" : 201,\n         \"product_name\" : \"product 1\",\n         \"quantity\" : 2,\n         \"price\" : 10\n      },\n      {\n         \"product_id\" : 202,\n         \"product_name\" : \"product 2\",\n         \"quantity\" : 1,\n         \"price\" : 20\n      }\n   ]\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e8\"),\n   \"order_id\" : 1002,\n   \"customer_name\" : \"Jane Doe\",\n   \"order_date\" : ISODate(\"2020-01-02T00:00:00.000Z\"),\n   \"items\" : [\n      {\n         \"product_id\" : 201,\n         \"product_name\" : \"product 1\",\n         \"quantity\" : 1,\n         \"price\" : 10\n      },\n      {\n         \"product_id\" : 203,\n         \"product_name\" : \"product 3\",\n         \"quantity\" : 2,\n         \"price\" : 15\n      }\n   ]\n}</pre><p><br></p><p>What is the query to retrieve the total sales for each product across all orders in the <code>orders</code><em> </em>collection?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $unwind: \"$items\"\n   },\n   {\n      $group: {\n         _id: \"$items.product_id\",\n         total_sales: { $sum: { $multiply: [ \"$items.quantity\", \"$items.price\" ] } }\n      }\n   }\n])</pre>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $unwind: \"$items\"\n   },\n   {\n      $group: {\n         _id: \"$items.product_id\",\n         total_sales: { $sum: { $multiply: [ \"$items.quantity\", \"$items.price\" ] } }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $group: {\n         _id: \"$items.product_id\",\n         total_sales: { $sum: { $multiply: [ \"$items.quantity\", \"$items.price\" ] } }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $unwind: \"$items\"\n   },\n   {\n      $group: {\n         _id: \"$product_id\",\n         total_sales: { $sum: { $multiply: [ \"$items.quantity\", \"$items.price\" ] } }\n      }\n   }\n])</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.aggregate([\n   {\n      $unwind: \"$items\"\n   },\n   {\n      $group: {\n         _id: \"$items.product_id\",\n         total_sales: { $sum: { $multiply: [ \"$quantity\", \"$price\" ] } }\n      }\n   }\n])</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider a collection named orders with the following documents:{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e7\"),\n   \"order_id\" : 1001,\n   \"customer_name\" : \"John Doe\",\n   \"order_date\" : ISODate(\"2020-01-01T00:00:00.000Z\"),\n   \"items\" : [\n      {\n         \"product_id\" : 201,\n         \"product_name\" : \"product 1\",\n         \"quantity\" : 2,\n         \"price\" : 10\n      },\n      {\n         \"product_id\" : 202,\n         \"product_name\" : \"product 2\",\n         \"quantity\" : 1,\n         \"price\" : 20\n      }\n   ]\n}\n\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e8\"),\n   \"order_id\" : 1002,\n   \"customer_name\" : \"Jane Doe\",\n   \"order_date\" : ISODate(\"2020-01-02T00:00:00.000Z\"),\n   \"items\" : [\n      {\n         \"product_id\" : 201,\n         \"product_name\" : \"product 1\",\n         \"quantity\" : 1,\n         \"price\" : 10\n      },\n      {\n         \"product_id\" : 203,\n         \"product_name\" : \"product 3\",\n         \"quantity\" : 2,\n         \"price\" : 15\n      }\n   ]\n}What is the query to retrieve the total sales for each product across all orders in the orders collection?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169004,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a collection named <code>employees</code> with the following documents:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"name\" : \"John Doe\",\n   \"position\" : \"Developer\",\n   \"department\" : \"IT\",\n   \"hire_date\" : ISODate(\"2021-01-01T00:00:00.000Z\")\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e2\"),\n   \"name\" : \"Jane Doe\",\n   \"position\" : \"Manager\",\n   \"department\" : \"Sales\",\n   \"hire_date\" : ISODate(\"2021-02-01T00:00:00.000Z\")\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e3\"),\n   \"name\" : \"Bob\",\n   \"position\" : \"Salesperson\",\n   \"department\" : \"Sales\",\n   \"hire_date\" : ISODate(\"2021-03-01T00:00:00.000Z\")\n}</pre><p><br></p><p>What is the query to find all employees whose position is either <code>\"Developer\"</code> or <code>\"Manager\"</code>?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.find(\n   { position: { $in: [ \"Developer\", \"Manager\" ] } }\n)</pre><p><br></p><p><code>db.collection.find(query, projection, options)</code> - Selects documents in a collection or view and returns a cursor to the selected documents.</p><p>The <code>$in</code> operator selects the documents where the value of a field equals any value in the specified array. To specify an <code>$in</code> expression, use the following prototype:</p><p><br></p><pre class=\"prettyprint linenums\">{ field: { $in: [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; ] } }</pre><p><br></p><p>https://www.mongodb.com/docs/manual/reference/method/db.collection.find/</p><p>https://www.mongodb.com/docs/manual/reference/operator/query/in/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.employees.find(\n   { position: { $in: [ \"Developer\", \"Manager\" ] } }\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.find(\n   { position: { $nin: [ \"Developer\", \"Manager\" ] } }\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.find(\n   { position: { $and: [ \"Developer\", \"Manager\" ] } }\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.employees.find(\n   { position: { $in: [ \"Developer\" $or \"Manager\" ] } }\n)</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider a collection named employees with the following documents:{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"name\" : \"John Doe\",\n   \"position\" : \"Developer\",\n   \"department\" : \"IT\",\n   \"hire_date\" : ISODate(\"2021-01-01T00:00:00.000Z\")\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e2\"),\n   \"name\" : \"Jane Doe\",\n   \"position\" : \"Manager\",\n   \"department\" : \"Sales\",\n   \"hire_date\" : ISODate(\"2021-02-01T00:00:00.000Z\")\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e3\"),\n   \"name\" : \"Bob\",\n   \"position\" : \"Salesperson\",\n   \"department\" : \"Sales\",\n   \"hire_date\" : ISODate(\"2021-03-01T00:00:00.000Z\")\n}What is the query to find all employees whose position is either \"Developer\" or \"Manager\"?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169006,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a collection named <code>products</code><em> </em>with the following documents:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"name\" : \"iPhone\",\n   \"manufacturer\" : \"Apple\",\n   \"price\" : 999\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e2\"),\n   \"name\" : \"Galaxy S21\",\n   \"manufacturer\" : \"Samsung\",\n   \"price\" : 899\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e3\"),\n   \"name\" : \"Pixel 6\",\n   \"manufacturer\" : \"Google\",\n   \"price\" : 799\n}</pre><p><br></p><p>What is the query to create a descending index on the <code>\"price\"</code> field in the <code>products</code><em> </em>collection?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.products.createIndex({ price: -1 })</pre><p><br></p><p><code>db.collection.createIndex(keys, options, commitQuorum)</code> - Creates indexes on collections.</p><p><br></p><p>https://www.mongodb.com/docs/manual/reference/method/db.collection.createIndex/</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.products.createIndex({ price: -1 })</pre>",
          "<pre class=\"prettyprint linenums\">db.products.createIndex({ price: 1 })</pre>",
          "<pre class=\"prettyprint linenums\">db.products.createIdx({ price: -1 })</pre>",
          "<pre class=\"prettyprint linenums\">db.products.getIndex({ price: -1 })</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider a collection named products with the following documents:{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e1\"),\n   \"name\" : \"iPhone\",\n   \"manufacturer\" : \"Apple\",\n   \"price\" : 999\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e2\"),\n   \"name\" : \"Galaxy S21\",\n   \"manufacturer\" : \"Samsung\",\n   \"price\" : 899\n},\n{\n   \"_id\" : ObjectId(\"5f0a7e80d8c9c7b5a48c49e3\"),\n   \"name\" : \"Pixel 6\",\n   \"manufacturer\" : \"Google\",\n   \"price\" : 799\n}What is the query to create a descending index on the \"price\" field in the products collection?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169008,
      "assessment_type": "multi-select",
      "prompt": {
        "question": "<p>Consider a use case for a blog application where you want to store information about articles and their authors. You have added the following document to the <code>articles</code><em> </em>collection.</p><p><br></p><pre class=\"prettyprint linenums\">db.articles.insertOne({\n  \"title\": \"My First Article\",\n  \"body\": \"This is the body of my first article\",\n  \"author\": {\n    \"name\": \"John Doe\",\n    \"email\": \"johndoe@example.com\"\n  },\n  \"tags\": [ \"mongodb\", \"data modeling\" ],\n  \"published_date\": ISODate(\"2022-01-01T00:00:00Z\")\n})</pre><p><br></p><p>Select all true statements. (select 2)</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The <code>\"author\"</code> field is a nested document that contains the <code>\"name\"</code> and <code>\"email\"</code> of the author. -&gt;&nbsp;Correct.</p><p>The <code>\"tags\"</code> field is an array that stores the tags associated with the article. -&gt; Correct.</p>",
        "answers": [
          "<p>The <code>\"author\"</code> field is a nested document that contains the <code>\"name\"</code> and <code>\"email\"</code> of the author.</p>",
          "<p>The <code>\"tags\"</code> field is an array that stores the tags associated with the article.</p>",
          "<p>The <code>\"tags\"</code> field is invalid.</p>",
          "<p>The <code>\"author\"</code> field is a nested array that contains the <code>\"name\"</code> and <code>\"email\"</code> of the author.</p>"
        ]
      },
      "correct_response": [
        "a",
        "b"
      ],
      "section": "",
      "question_plain": "Consider a use case for a blog application where you want to store information about articles and their authors. You have added the following document to the articles collection.db.articles.insertOne({\n  \"title\": \"My First Article\",\n  \"body\": \"This is the body of my first article\",\n  \"author\": {\n    \"name\": \"John Doe\",\n    \"email\": \"johndoe@example.com\"\n  },\n  \"tags\": [ \"mongodb\", \"data modeling\" ],\n  \"published_date\": ISODate(\"2022-01-01T00:00:00Z\")\n})Select all true statements. (select 2)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169010,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a MongoDB database containing a collection of documents representing online orders for an e-commerce website. The documents have the following structure:</p><p><br></p><pre class=\"prettyprint linenums\">{\n   \"_id\": ObjectId(\"5f95a1d11a12b400001b75c0\"),\n   \"order_number\": \"ORD-001\",\n   \"order_date\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"customer\": {\n      \"name\": \"John Doe\",\n      \"email\": \"johndoe@example.com\"\n   },\n   \"items\": [\n      { \"product_name\": \"Smartphone\", \"quantity\": 2, \"price\": 800 },\n      { \"product_name\": \"Laptop\", \"quantity\": 1, \"price\": 1500 }\n   ],\n   \"shipping_address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"New York\",\n      \"state\": \"NY\",\n      \"zipcode\": \"10001\"\n   },\n   \"total_amount\": 3000\n}</pre><p><br></p><p>You are frequently running the following query to find all orders placed by customers from a specific state, within a certain date range:</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.find({\n   \"shipping_address.state\": \"NY\",\n   \"order_date\": {\n      \"$gte\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n      \"$lt\": ISODate(\"2022-12-31T23:59:59.999Z\")\n   }\n})</pre><p><br></p><p>What index would you create to improve the performance of this query?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>You should create a compound index on the <code><strong>shipping_address.state</strong></code> and <code><strong>order_date</strong></code> fields. -&gt; Correct. </p><p>The query you are running performs a query on two fields, <code><strong>shipping_address.state</strong></code> and <code><strong>order_date</strong></code>, and a compound index on both of these fields will improve the query performance. A compound index is an index that includes multiple fields in the index key, allowing the index to support queries that filter or sort data based on multiple fields.</p><p>In this case, a compound index on the <code><strong>shipping_address.state</strong></code> and <code><strong>order_date</strong></code> fields will allow the MongoDB query planner to use the index to quickly filter the documents based on the state and date range criteria, reducing the amount of data that needs to be scanned and improving the query performance.</p>",
        "answers": [
          "<p>You should create a compound index on the <code><strong>shipping_address.state</strong></code> and <code><strong>order_date</strong></code> fields.</p>",
          "<p>You should create an index on the <code><strong>shipping_address.state</strong></code> field.</p>",
          "<p>You should create an index on the <code><strong>order_date</strong></code> field.</p>",
          "<p>You should create a compound index on the <code><strong>order_date</strong></code>&nbsp; and <code><strong>shipping_address.state</strong></code> fields.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider a MongoDB database containing a collection of documents representing online orders for an e-commerce website. The documents have the following structure:{\n   \"_id\": ObjectId(\"5f95a1d11a12b400001b75c0\"),\n   \"order_number\": \"ORD-001\",\n   \"order_date\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n   \"customer\": {\n      \"name\": \"John Doe\",\n      \"email\": \"johndoe@example.com\"\n   },\n   \"items\": [\n      { \"product_name\": \"Smartphone\", \"quantity\": 2, \"price\": 800 },\n      { \"product_name\": \"Laptop\", \"quantity\": 1, \"price\": 1500 }\n   ],\n   \"shipping_address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"New York\",\n      \"state\": \"NY\",\n      \"zipcode\": \"10001\"\n   },\n   \"total_amount\": 3000\n}You are frequently running the following query to find all orders placed by customers from a specific state, within a certain date range:db.orders.find({\n   \"shipping_address.state\": \"NY\",\n   \"order_date\": {\n      \"$gte\": ISODate(\"2022-01-01T00:00:00.000Z\"),\n      \"$lt\": ISODate(\"2022-12-31T23:59:59.999Z\")\n   }\n})What index would you create to improve the performance of this query?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169012,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the difference between a sparse index and a non-sparse index in MongoDB?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>A sparse index only indexes documents that contain the indexed field, while a non-sparse index indexes all documents in the collection, including those that do not contain the indexed field. -&gt; Correct.</p><p>In MongoDB, sparse indexes are designed to only index documents that contain the indexed field. This can be useful in cases where the field has a large number of missing or undefined values in the collection. By using a sparse index, MongoDB can save storage space and improve performance for queries that match on the indexed field, as it only needs to consider the subset of documents that contain the field. On the other hand, a non-sparse index indexes all documents in the collection, including those that do not contain the indexed field. This can be useful in cases where the field is required and its presence in all documents is important. By using a non-sparse index, MongoDB can ensure that all documents are indexed and available for query and sort operations, even if they do not contain the indexed field. By contrast, non-sparse indexes contain all documents in a collection, storing null values for those documents that do not contain the indexed field.</p><p><br></p><p>https://www.mongodb.com/docs/manual/core/index-sparse/</p>",
        "answers": [
          "<p>A sparse index only indexes documents that contain the indexed field, while a non-sparse index indexes all documents in the collection, including those that do not contain the indexed field.</p>",
          "<p>A sparse index only indexes documents that do not contain the indexed field, while a non-sparse index indexes all documents in the collection, including those that contain the indexed field.</p>",
          "<p>A sparse index indexes all documents in the collection, including those that contain the indexed field, while a non-sparse index only indexes documents that do not contain the indexed field.</p>",
          "<p>A sparse index indexes all documents in the collection, including those that do not contain the indexed field, while a non-sparse index only indexes documents that contain the indexed field.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is the difference between a sparse index and a non-sparse index in MongoDB?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169014,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the difference between a unique index and a non-unique index in MongoDB?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>A unique index enforces a unique constraint on the indexed field, while a non-unique index allows multiple documents to have the same value in the indexed field. -&gt;&nbsp;Correct.</p><p>In MongoDB, unique indexes enforce a unique constraint on the indexed field, ensuring that no two documents in the collection have the same value for the indexed field. This can be useful in cases where you want to enforce a unique constraint on a field, such as ensuring that there are no duplicate email addresses in a user collection. On the other hand, a non-unique index does not enforce a unique constraint and allows multiple documents to have the same value in the indexed field. This can be useful in cases where you want to index a field for improved performance, but do not need to enforce a unique constraint, such as indexing the \"age\" field in a user collection. By using a non-unique index, MongoDB can provide optimized performance for queries and sort operations on the indexed field, even if multiple documents have the same value.</p>",
        "answers": [
          "<p>A unique index enforces a unique constraint on the indexed field, while a non-unique index allows multiple documents to have the same value in the indexed field.</p>",
          "<p>A unique index allows multiple documents to have the same value in the indexed field, while a non-unique index enforces a unique constraint on the indexed field.</p>",
          "<p>A unique index only indexes documents that contain the indexed field, while a non-unique index indexes all documents in the collection, including those that do not contain the indexed field.</p>",
          "<p>A unique index indexes all documents in the collection, including those that do not contain the indexed field, while a non-unique index only indexes documents that contain the indexed field.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is the difference between a unique index and a non-unique index in MongoDB?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169016,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>When sharding a MongoDB collection, what is the main factor that determines the distribution of data across shards?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The value of a shard key -&gt;&nbsp;Correct. Sharding in MongoDB involves dividing a large collection of data into smaller partitions, called shards, and distributing these shards across multiple servers. The key to determining the distribution of data across shards is the shard key, which is a unique index that determines the range of values for each shard. When a query is executed, the shard key value is used to determine which shard will handle the query, allowing for a more balanced distribution of data and improved query performance. The size of each document and the number of documents in the collection may also be considered when deciding on the shard key, but the shard key is the primary factor that determines the distribution of data across shards.</p>",
        "answers": [
          "<p>The size of each document</p>",
          "<p>The number of documents in the collection</p>",
          "<p>The location of the client issuing the query</p>",
          "<p>The value of a shard key</p>"
        ]
      },
      "correct_response": [
        "d"
      ],
      "section": "",
      "question_plain": "When sharding a MongoDB collection, what is the main factor that determines the distribution of data across shards?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169018,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What happens to the index entries associated with a MongoDB document when it is deleted using the <code>db.collection.deleteMany()</code> method?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>They are immediately removed from the index. -&gt; Correct. When a MongoDB document is deleted using the <code>db.collection.deleteMany()</code> method, all index entries associated with the document are immediately removed from the corresponding indexes. This means that the deleted documents will no longer be included in the index or be available for index-based queries. The <code>deleteMany()</code> method deletes all documents that match the specified filter, so multiple index entries may be removed at once.</p><p><br></p><p>https://www.mongodb.com/docs/manual/reference/method/db.collection.deleteMany/</p>",
        "answers": [
          "<p>They are immediately removed from the index.</p>",
          "<p>They are updated with a flag indicating that they have been deleted, but remain in the index.</p>",
          "<p>They are moved to a temporary storage location for possible recovery.</p>",
          "<p>They are marked for deletion but remain in the index until the next index rebuild operation.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What happens to the index entries associated with a MongoDB document when it is deleted using the db.collection.deleteMany() method?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169020,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>In MongoDB, consider the following query:</p><p><br></p><pre class=\"prettyprint linenums\">db.collection.aggregate([\n    { $match: {\n        $and: [\n            { date: { $gte: ISODate(\"2022-01-01T00:00:00.000Z\") } },\n            { $or: [\n                { category: \"electronics\" },\n                { price: { $lt: 50 } }\n            ] }\n        ]\n    } },\n    { $project: {\n        _id: 0,\n        item: \"$name\",\n        discount: { $cond: [\n            { $and: [\n                { $eq: [ \"$category\", \"electronics\" ] },\n                { $gt: [ \"$price\", 100 ] }\n            ] },\n            0.15,\n            0\n        ] }\n    } },\n    { $sort: { discount: -1 } }\n])</pre><p><br></p><p>What does this query do?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Filters documents from the collection where the date is greater than or equal to \"2022-01-01T00:00:00.000Z\" and either the category is \"electronics\" or the price is less than 50, projects a new document with the item name and a discount calculated using the <code><strong>$cond</strong></code> operator, and sorts the results in descending order of discount. -&gt; Correct.</p><p><br></p><p>The query performs the following operations:</p><ol><li><p><code><strong>$match</strong></code> stage: Filters documents from the collection using the logical operator <code><strong>$and</strong></code> to combine two conditions, the first being that the <code><strong>date</strong></code> must be greater than or equal to \"2022-01-01T00:00:00.000Z\" and the second being that either the <code><strong>category</strong></code> must be \"electronics\" or the <code><strong>price</strong></code> must be less than 50. The <code><strong>$or</strong></code> operator is used within the second condition to specify that either the <code><strong>category</strong></code> must be \"electronics\" or the <code><strong>price</strong></code> must be less than 50.</p></li><li><p><code><strong>$project</strong></code> stage: Projects a new document for each filtered document, with the item name as <code><strong>item</strong></code> and a discount calculated using the <code><strong>$cond</strong></code> operator. The <code><strong>$cond</strong></code> operator evaluates a boolean expression consisting of two logical operators <code><strong>$and</strong></code> and <code><strong>$eq</strong></code>, and returns one of two expressions based on the result of the boolean expression.</p></li></ol>",
        "answers": [
          "<p>Filters documents from the collection where the date is less than \"2022-01-01T00:00:00.000Z\" and either the category is not \"electronics\" or the price is not less than 50, projects a new document with the item name and a discount of 0, and sorts the results in ascending order of discount.</p>",
          "<p>Filters documents from the collection where the date is greater than or equal to \"2022-01-01T00:00:00.000Z\" and either the category is \"electronics\" or the price is less than 50, projects a new document with the item name and a discount calculated using the <code><strong>$cond</strong></code> operator, and sorts the results in descending order of discount.</p>",
          "<p>Filters documents from the collection where the date is less than \"2022-01-01T00:00:00.000Z\" and either the category is \"electronics\" or the price is less than 50, projects a new document with the item name and a discount calculated using the <code><strong>$cond</strong></code> operator, and sorts the results in ascending order of discount.</p>",
          "<p>Filters documents from the collection where the date is greater than or equal to \"2022-01-01T00:00:00.000Z\" and either the category is not \"electronics\" or the price is not less than 50, projects a new document with the item name and a discount calculated using the <code><strong>$cond</strong></code> operator, and sorts the results in ascending order of discount.</p>"
        ]
      },
      "correct_response": [
        "b"
      ],
      "section": "",
      "question_plain": "In MongoDB, consider the following query:db.collection.aggregate([\n    { $match: {\n        $and: [\n            { date: { $gte: ISODate(\"2022-01-01T00:00:00.000Z\") } },\n            { $or: [\n                { category: \"electronics\" },\n                { price: { $lt: 50 } }\n            ] }\n        ]\n    } },\n    { $project: {\n        _id: 0,\n        item: \"$name\",\n        discount: { $cond: [\n            { $and: [\n                { $eq: [ \"$category\", \"electronics\" ] },\n                { $gt: [ \"$price\", 100 ] }\n            ] },\n            0.15,\n            0\n        ] }\n    } },\n    { $sort: { discount: -1 } }\n])What does this query do?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169022,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>You are designing a MongoDB database for an e-commerce website. The website should track the customers, their orders, and the products in each order. Which of the following data models would best fit this requirement?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>One collection for customers, one collection for orders, and one collection for products. Each order document would contain a reference to the customer who made the order and an array of references to the products in the order. -&gt;&nbsp;Correct. This option separates the information about the customers, their orders, and the products into different collections, which provides clear relationships between the different entities in the e-commerce website. This approach allows for efficient queries, indexing, and updates to the individual entities. Each order document contains a reference to the customer who made the order and an array of references to the products in the order, which provides a clear relationship between the order and its customer and products.</p><p><br></p><p>One collection for customers, one collection for orders, and one collection for products. Each customer document would contain an array of references to their orders and an array of references to the products in each order. -&gt; Incorrect. This option stores an array of references to orders and products in each customer document, which can lead to performance issues when retrieving information about a specific customer or order due to the size of the order and product arrays.</p><p><br></p><p>One collection for customers and orders, with each document representing an order and containing references to both the customer and the products in the order. -&gt; Incorrect. This option combines information about customers and orders into a single collection, making it difficult to separate and manage the information about each entity.</p><p><br></p><p>One collection for customers, orders, and products, with each document representing an order and containing embedded documents for the customer and an array of embedded documents for the products in the order. -&gt; Incorrect. This option stores all information about customers, orders, and products in a single document, which can lead to performance issues as the documents grow in size and complexity. It also makes it more difficult to update individual entities as the entire document would need to be updated in order to change any single piece of information.</p>",
        "answers": [
          "<p>One collection for customers, one collection for orders, and one collection for products. Each order document would contain a reference to the customer who made the order and an array of references to the products in the order.</p>",
          "<p>One collection for customers, one collection for orders, and one collection for products. Each customer document would contain an array of references to their orders and an array of references to the products in each order.</p>",
          "<p>One collection for customers and orders, with each document representing an order and containing references to both the customer and the products in the order.</p>",
          "<p>One collection for customers, orders, and products, with each document representing an order and containing embedded documents for the customer and an array of embedded documents for the products in the order.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "You are designing a MongoDB database for an e-commerce website. The website should track the customers, their orders, and the products in each order. Which of the following data models would best fit this requirement?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169024,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the default sort order in MongoDB when using the <code>db.collection.find()</code> method without a specified sort order?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>No sort order, the documents are returned in the order they were inserted into the collection. -&gt; Correct.</p><p>When using the <code>db.collection.find()</code> method in MongoDB, the default behavior is to return documents in the order they were inserted into the collection, known as the \"natural order\". If you need to sort the results of a query, you can specify the sort order by including the <code>sort()</code> method in the query and specifying the field(s) to sort on and the sort direction (ascending or descending).</p>",
        "answers": [
          "<p>No sort order, the documents are returned in the order they were inserted into the collection</p>",
          "<p>Random</p>",
          "<p>Ascending</p>",
          "<p>Descending</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is the default sort order in MongoDB when using the db.collection.find() method without a specified sort order?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169026,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What happens when multiple fields are specified in the <code>sort()</code> method when querying a MongoDB collection?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>All fields are used to sort the documents in the order they are specified. -&gt; Correct. </p><p>When multiple fields are specified in the <code>sort()</code> method when querying a MongoDB collection, MongoDB uses all fields to sort the documents. The sort order is determined by the order in which the fields are specified in the <code>sort()</code> method.</p>",
        "answers": [
          "<p>Only the first field specified in the sort method is used for sorting.</p>",
          "<p>All fields are used to sort the documents in the order they are specified.</p>",
          "<p>Only the last field specified in the sort method is used for sorting.</p>",
          "<p>The fields are used to sort the documents in a random order.</p>"
        ]
      },
      "correct_response": [
        "b"
      ],
      "section": "",
      "question_plain": "What happens when multiple fields are specified in the sort() method when querying a MongoDB collection?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169028,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the behavior of MongoDB when using the <code>\"projection\"</code> option in a <code>find()</code> query to exclude a field that has a unique index in the collection?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The unique index is enforced, regardless of whether or not the field is excluded in the projection. -&gt; Correct.</p><p>In MongoDB, a unique index enforces the uniqueness constraint across the entire collection, regardless of whether or not a particular field is included in a query's projection. This means that even if you use the projection option in a <code>find()</code> query to exclude a field with a unique index, the uniqueness constraint will still be enforced for that field. This can be useful for maintaining the integrity of your data, as it ensures that no two documents in the collection can have the same value for the indexed field, even if that field is not included in the query's projection. However, it's important to be aware of this behavior when designing your queries, as it can lead to unexpected errors if the unique constraint is violated.</p>",
        "answers": [
          "<p>The query fails and returns an error.</p>",
          "<p>The unique index is not enforced for documents that exclude the field.</p>",
          "<p>The unique index is enforced, but only for documents that include the field.</p>",
          "<p>The unique index is enforced, regardless of whether or not the field is excluded in the projection.</p>"
        ]
      },
      "correct_response": [
        "d"
      ],
      "section": "",
      "question_plain": "What is the behavior of MongoDB when using the \"projection\" option in a find() query to exclude a field that has a unique index in the collection?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169030,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>How can you insert a new document into a MongoDB collection named <code>customers</code>?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct query:</p><p><br></p><pre class=\"prettyprint linenums\">db.customers.insert({ name: \"John Doe\", age: 32, city: \"New York\" }) </pre><p><br></p><p>In MongoDB, to insert a new document into a collection, you can use the <code>insert()</code> method on the collection object. The syntax would be <code>db.collection_name.insert({ document })</code> where <code>collection_name</code> is the name of the collection you want to insert into and \"{ document }\" is the document you want to insert represented as a JavaScript object. </p><p><br></p><pre class=\"prettyprint linenums\">db.customers({ name: \"John Doe\", age: 32, city: \"New York\" })</pre><p><br></p><p>This option is not correct because it does not include the <code>insert()</code> method. </p><p><br></p><pre class=\"prettyprint linenums\">customers.insert({ name: \"John Doe\", age: 32, city: \"New York\" })</pre><p><br></p><p>This option is not correct because it does not include the <code>db</code> prefix which is necessary to specify the database. </p><p><br></p><pre class=\"prettyprint linenums\">db.insert({ name: \"John Doe\", age: 32, city: \"New York\" }, \"customers\")</pre><p><br></p><p>This option is not correct because it does not include the collection name in the correct place.</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.customers.insert({ name: \"John Doe\", age: 32, city: \"New York\" }) </pre>",
          "<pre class=\"prettyprint linenums\">db.customers({ name: \"John Doe\", age: 32, city: \"New York\" })</pre>",
          "<pre class=\"prettyprint linenums\">customers.insert({ name: \"John Doe\", age: 32, city: \"New York\" })</pre>",
          "<pre class=\"prettyprint linenums\">db.insert({ name: \"John Doe\", age: 32, city: \"New York\" }, \"customers\")</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "How can you insert a new document into a MongoDB collection named customers?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169032,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a MongoDB collection named <code>orders</code> which has documents in the following format:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    \"_id\" : ObjectId(\"5f5b0d2f3e3dfbcc11c84444\"),\n    \"orderId\" : 1001,\n    \"customerId\" : 200,\n    \"items\" : [\n        {\n            \"productId\" : 101,\n            \"quantity\" : 2\n        },\n        {\n            \"productId\" : 102,\n            \"quantity\" : 1\n        }\n    ],\n    \"totalAmount\" : 250,\n    \"status\" : \"Pending\"\n}</pre><p><br></p><p>What is the correct syntax to find and update the first document in the <code>orders</code> collection where <code>\"status\"</code> is <code>\"Pending\"</code>, and change the <code>\"status\"</code> field to <code>\"Completed\"</code> using the <code>findAndModify</code> method?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Correct answer:</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.findAndModify({\n  query: { status: \"Pending\" },\n  update: { $set: { status: \"Completed\" } }\n})</pre><p><br></p><p>The <code>findAndModify</code> method in MongoDB allows you to find and update a single document in a collection. The first argument to this method is the filter criteria for the document you want to modify, and the second argument is the update operation to perform on the matched document. In this case, the filter is <code>{ status: \"Pending\" }</code>, which matches the first document where \"status\" is \"Pending\", and the update operation is <code>{ $set: { status: \"Completed\" } }</code>, which sets the \"status\" field to \"Completed\".</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.findAndModify(\n  { status: \"Pending\" },\n  { $set: { status: \"Completed\" } }\n)</pre><p><br></p><p>It only specifies the filter and update operations, but not the \"query\" field, which is required to specify the filter.</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.findAndModify({ status: \"Pending\" }, { status: \"Completed\" })</pre><p><br></p><p>It specifies the update operation directly, rather than using the <code><strong>$set</strong></code> operator, which is required to update a specific field in a document.</p><p><br></p><pre class=\"prettyprint linenums\">db.orders.findAndModify({ query: { status: \"Pending\" }, status: \"Completed\" })</pre><p><br></p><p>It only specifies the filter, but not the update operation.</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.orders.findAndModify({\n  query: { status: \"Pending\" },\n  update: { $set: { status: \"Completed\" } }\n})</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.findAndModify(\n  { status: \"Pending\" },\n  { $set: { status: \"Completed\" } }\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.findAndModify({ status: \"Pending\" }, { status: \"Completed\" })</pre>",
          "<pre class=\"prettyprint linenums\">db.orders.findAndModify({ query: { status: \"Pending\" }, status: \"Completed\" })</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Consider a MongoDB collection named orders which has documents in the following format:{\n    \"_id\" : ObjectId(\"5f5b0d2f3e3dfbcc11c84444\"),\n    \"orderId\" : 1001,\n    \"customerId\" : 200,\n    \"items\" : [\n        {\n            \"productId\" : 101,\n            \"quantity\" : 2\n        },\n        {\n            \"productId\" : 102,\n            \"quantity\" : 1\n        }\n    ],\n    \"totalAmount\" : 250,\n    \"status\" : \"Pending\"\n}What is the correct syntax to find and update the first document in the orders collection where \"status\" is \"Pending\", and change the \"status\" field to \"Completed\" using the findAndModify method?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169034,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Consider a MongoDB collection named <code>employees</code> which has documents in the following format:</p><p><br></p><pre class=\"prettyprint linenums\">{\n    \"_id\" : ObjectId(\"5f5b0d2f3e3dfbcc11c84444\"),\n    \"employeeId\" : 301,\n    \"name\" : \"Jane Doe\",\n    \"department\" : \"Sales\",\n    \"salary\" : 5000,\n    \"hireDate\" : ISODate(\"2020-01-01T00:00:00.000Z\")\n}</pre><p><br></p><p>What is the correct output for the following query in the <code>employees</code> collection?</p><p><br></p><pre class=\"prettyprint linenums\">db.employees.find().sort({salary: 1}).limit(3)</pre><p><br></p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Documents with the lowest and second lowest salary in ascending order. -&gt; Correct.</p><p>The query <code>db.employees.find().sort({salary: 1}).limit(3)</code> performs a sort operation on the <code>employees</code> collection, where the <code>sort</code> method sorts the documents based on the <code>\"salary\"</code> field in ascending order (<code>{salary: 1}</code>). The <code>limit</code> method limits the number of documents returned to 3. Therefore, the query returns the 3 documents with the lowest salary in ascending order.</p>",
        "answers": [
          "<p>Documents with the highest and second highest salary in ascending order.</p>",
          "<p>Documents with the highest and second highest salary in descending order.</p>",
          "<p>Documents with the lowest and second lowest salary in ascending order.</p>",
          "<p>Documents with the lowest and second lowest salary in descending order.</p>"
        ]
      },
      "correct_response": [
        "c"
      ],
      "section": "",
      "question_plain": "Consider a MongoDB collection named employees which has documents in the following format:{\n    \"_id\" : ObjectId(\"5f5b0d2f3e3dfbcc11c84444\"),\n    \"employeeId\" : 301,\n    \"name\" : \"Jane Doe\",\n    \"department\" : \"Sales\",\n    \"salary\" : 5000,\n    \"hireDate\" : ISODate(\"2020-01-01T00:00:00.000Z\")\n}What is the correct output for the following query in the employees collection?db.employees.find().sort({salary: 1}).limit(3)",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169036,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>How does MongoDB handle documents with duplicate values in a field that has a unique index?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>MongoDB returns an error and prevents insertion of the document in a field that has a unique index. -&gt; Correct. When you create a unique index in MongoDB, MongoDB will enforce the unique constraint and prevent the insertion of duplicate values into the specified field. If a document with a duplicate value is inserted, MongoDB will return an error and prevent the insertion. This helps to ensure the data integrity and prevents duplicates in the collection. In order to insert a document with a duplicate value in a field that has a unique index, you would need to first remove the document with the duplicate value or update the value in the document to make it unique.</p>",
        "answers": [
          "<p>MongoDB allows multiple documents with duplicate values in a field that has a unique index.</p>",
          "<p>MongoDB replaces the older document with the newer document in a field that has a unique index.</p>",
          "<p>MongoDB returns an error and prevents insertion of the document in a field that has a unique index.</p>",
          "<p>MongoDB updates the value in the duplicate document to make it unique in a field that has a unique index.</p>"
        ]
      },
      "correct_response": [
        "c"
      ],
      "section": "",
      "question_plain": "How does MongoDB handle documents with duplicate values in a field that has a unique index?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169038,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>When modeling a relationship between two entities in MongoDB, what is the purpose of using an embedded relationship?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>The purpose of using an embedded relationship in MongoDB is to store multiple related entities in a single document to reduce the need for joins. -&gt; Correct. In MongoDB, data modeling involves deciding how to structure the data to best support the query patterns and performance requirements of the application. An embedded relationship in MongoDB is a type of relationship where related entities are stored in a single document. The purpose of using an embedded relationship is to reduce the need for joins, as all related data is stored in a single document. This can improve query performance, as the data can be retrieved with a single database query. However, there are also some limitations to embedded relationships, such as the size of the document and the fact that updates to the related entities may become more complex. When modeling relationships in MongoDB, it is important to consider the trade-offs between embedded relationships and other types of relationships, such as referenced relationships.</p>",
        "answers": [
          "<p>The purpose of using an embedded relationship in MongoDB is to denormalize the data, duplicating data across multiple documents to improve query performance.</p>",
          "<p>The purpose of using an embedded relationship in MongoDB is to store multiple related entities in a single document to reduce the need for joins.</p>",
          "<p>The purpose of using an embedded relationship in MongoDB is to store related entities in separate collections, improving scalability and maintainability of the data.</p>",
          "<p>The purpose of using an embedded relationship in MongoDB is to store multiple related entities in two documents.</p>"
        ]
      },
      "correct_response": [
        "b"
      ],
      "section": "",
      "question_plain": "When modeling a relationship between two entities in MongoDB, what is the purpose of using an embedded relationship?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169040,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>In a MongoDB database with referenced relationships, what is the advantage of using a separate collection for each entity over using a single collection for all entities?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Improved maintainability and reduced complexity of updates to related entities. -&gt; Correct. When modeling relationships in MongoDB using referenced relationships, it is often beneficial to use separate collections for each entity. This approach can improve maintainability by allowing the collections to be managed and updated independently. Additionally, using separate collections can also reduce the complexity of updates to related entities, as each collection can have its own unique set of updates and data changes. This can be especially useful in large, complex applications where multiple relationships exist between entities. However, it is important to note that using separate collections can also have some disadvantages, such as decreased query performance and increased need for joins. It is important to carefully consider the specific requirements of the application and the data being stored when deciding whether to use separate collections for each entity or a single collection for all entities in a MongoDB database with referenced relationships.</p>",
        "answers": [
          "<p>Improved query performance and increased scalability.</p>",
          "<p>Improved maintainability and increased scalability.</p>",
          "<p>Improved maintainability and reduced complexity of updates to related entities.</p>",
          "<p>Improved query performance and reduced complexity of updates to related entities.</p>"
        ]
      },
      "correct_response": [
        "c"
      ],
      "section": "",
      "question_plain": "In a MongoDB database with referenced relationships, what is the advantage of using a separate collection for each entity over using a single collection for all entities?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169042,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is MongoDB's default port number for client connections?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>MongoDB's default port number for client connections is 27017. This is the standard port number that is used by MongoDB to listen for client connections. It is the default port number specified in the MongoDB configuration file, and it is the one that clients will attempt to connect to if no port number is specified in the connection string.</p>",
        "answers": [
          "<p>27017</p>",
          "<p>22</p>",
          "<p>80</p>",
          "<p>3306</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "What is MongoDB's default port number for client connections?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169044,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>What is the best way to model a one-to-many relationship between a user and their orders in MongoDB?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Store the user data and order data in separate collections, and use a reference field in the order document to link to the user document. -&gt; Correct. This is the best way to model a one-to-many relationship between a user and their orders in MongoDB. By storing the user data and order data in separate collections, you can ensure that each document is small enough to fit within the document size limit and can be easily queried. The reference field in the order document allows you to link an order to its corresponding user, allowing you to retrieve all of the orders for a particular user with a single query. This approach also ensures that you can scale the collections independently as your data grows, without having to worry about performance degradation or data corruption.</p>",
        "answers": [
          "<p>Embed the order documents within the user document.</p>",
          "<p>Use a single collection for both users and orders, and use an array of orders within each user document.</p>",
          "<p>Store the user data and order data in separate collections, and use a reference field in the order document to link to the user document.</p>",
          "<p>Use a single collection for both users and orders, and use a reference field in the order document to link to the user document.</p>"
        ]
      },
      "correct_response": [
        "c"
      ],
      "section": "",
      "question_plain": "What is the best way to model a one-to-many relationship between a user and their orders in MongoDB?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169046,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Which of the following is considered an anti-pattern in MongoDB data modeling?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Using a single collection for all entities, regardless of their relationship to each other. -&gt; Correct. This is considered an anti-pattern in MongoDB data modeling because it can lead to performance issues as the collection grows in size and complexity. By using a single collection for all entities, you are likely to end up with large and unwieldy documents that are difficult to manage and query efficiently. This can lead to slow query performance and decreased overall system performance as your data grows. It is generally better to use separate collections for entities that have different relationships to each other, and to use embedded documents or references to model relationships between entities as needed. This will allow you to scale your collections and data model more easily as your data grows, and will ensure that you are able to retrieve related data in an efficient and scalable manner.</p>",
        "answers": [
          "<p>Using embedded documents to model a one-to-one relationship between entities.</p>",
          "<p>Denormalizing data to reduce the number of read operations required to retrieve related data.</p>",
          "<p>Using a single collection for all entities, regardless of their relationship to each other.</p>",
          "<p>Using references to model a many-to-many relationship between entities.</p>"
        ]
      },
      "correct_response": [
        "c"
      ],
      "section": "",
      "question_plain": "Which of the following is considered an anti-pattern in MongoDB data modeling?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169048,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Which of the following is considered an anti-pattern in MongoDB data modeling for high volume data?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Using a single collection for all entities. -&gt; Correct. This is considered an anti-pattern in MongoDB data modeling for high volume data because it can lead to performance degradation as the size of the collection grows. With a large number of documents in a single collection, queries can become slow, and the size of the collection can become unwieldy and difficult to manage. Additionally, this approach can make it difficult to scale the system as the volume of data grows.</p>",
        "answers": [
          "<p>Using a single collection for all entities.</p>",
          "<p>Using indexes on frequently searched fields to improve query performance.</p>",
          "<p>Denormalizing data to reduce the number of read operations required to retrieve related data.</p>",
          "<p>Using embedded documents to model relationships between entities.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Which of the following is considered an anti-pattern in MongoDB data modeling for high volume data?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56169050,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>In MongoDB, which of the following data modeling techniques is considered best for representing a one-to-many relationship between two entities?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>Embedding one of the entities in the other as an array of documents. -&gt; Correct. This is considered the best data modeling technique for representing a one-to-many relationship in MongoDB because it allows for efficient and accurate retrieval of related data, and can help to simplify data modeling and storage. When one of the entities is embedded in the other as an array of documents, the related data is stored in a single document, and can be retrieved in a single query. This can help to improve query performance, as well as simplify data modeling and storage.</p>",
        "answers": [
          "<p>Embedding one of the entities in the other as an array of documents.</p>",
          "<p>Creating a separate collection for each entity and using a reference from one entity to the other.</p>",
          "<p>Storing both entities in the same collection and using a separate field for the relationship.</p>",
          "<p>Creating a third collection to store the relationship between the two entities.</p>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "In MongoDB, which of the following data modeling techniques is considered best for representing a one-to-many relationship between two entities?",
      "related_lectures": []
    },
    {
      "_class": "assessment",
      "id": 56176748,
      "assessment_type": "multiple-choice",
      "prompt": {
        "question": "<p>Suppose you have a <code>reviews</code><em> </em>collection with the following index:</p><p><br></p><pre class=\"prettyprint linenums\">{ stars: 1, votes: 1 }</pre><p><br></p><p>Which of the following queries would be a covered query?</p>",
        "relatedLectureIds": "",
        "feedbacks": [
          "",
          "",
          "",
          ""
        ],
        "explanation": "<p>A covered query is a query that can be satisfied entirely using an index and does not have to examine any documents. An index covers a query when all of the following apply:</p><ul><li><p>all the fields in the query are part of an index, <strong>and</strong></p></li><li><p>all the fields returned in the results are in the same index.</p></li><li><p>no fields in the query are equal to <code>null</code> (i.e. {<code>\"field\" : null</code>} or {<code>\"field\" : {$eq : null}}</code> ).</p></li></ul><p><br></p><p>https://docs.mongodb.com/manual/core/query-optimization/#query-optimization</p>",
        "answers": [
          "<pre class=\"prettyprint linenums\">db.reviews.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{ stars:&nbsp;{ $gt:&nbsp;4.5 } },\n&nbsp;&nbsp;&nbsp;&nbsp;{ _id:&nbsp;0,&nbsp;votes:&nbsp;1 }\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.reviews.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{ votes:&nbsp;{ $gte:&nbsp;100 } },\n&nbsp;&nbsp;&nbsp;&nbsp;{ _id:&nbsp;0,&nbsp;votes:&nbsp;1 }\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.reviews.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{ votes:&nbsp;{ $gte:&nbsp;100 } },\n&nbsp;&nbsp;&nbsp;&nbsp;{ _id:&nbsp;0,&nbsp;votes:&nbsp;1,&nbsp;stars:&nbsp;1 }\n)</pre>",
          "<pre class=\"prettyprint linenums\">db.reviews.find(\n&nbsp;&nbsp;&nbsp;&nbsp;{ votes:&nbsp;{ $gte:&nbsp;100 },&nbsp;stars:&nbsp;4.5 },\n&nbsp;&nbsp;&nbsp;&nbsp;{ _id:&nbsp;0 }\n)</pre>"
        ]
      },
      "correct_response": [
        "a"
      ],
      "section": "",
      "question_plain": "Suppose you have a reviews collection with the following index:{ stars: 1, votes: 1 }Which of the following queries would be a covered query?",
      "related_lectures": []
    }
  ]
}
